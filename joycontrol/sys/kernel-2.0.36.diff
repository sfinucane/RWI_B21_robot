diff -urN linux-2.0.36/CREDITS linux-2.0.36-joystick/CREDITS
--- linux-2.0.36/CREDITS	Sun Nov 15 19:32:41 1998
+++ linux-2.0.36-joystick/CREDITS	Mon Mar  8 14:48:52 1999
@@ -1095,6 +1095,15 @@
 E: greg@caldera.com
 D: IPX development and support
 
+N: Vojtech Pavlik
+E: vojtech@ucw.cz
+D: Joystick driver
+D: arcnet-hardware readme
+D: Minor ARCnet hacking
+S: Ucitelska 1576
+S: Prague 8
+S: 182 00 Czech Republic
+
 N: Avery Pennarun
 E: apenwarr@bond.net
 D: ARCnet driver
diff -urN linux-2.0.36/Documentation/Configure.help linux-2.0.36-joystick/Documentation/Configure.help
--- linux-2.0.36/Documentation/Configure.help	Sun Nov 15 19:32:42 1998
+++ linux-2.0.36-joystick/Documentation/Configure.help	Mon Mar  8 14:48:52 1999
@@ -4265,6 +4265,117 @@
   periodic data sampling), then say Y here, and go read the file
   Documentation/rtc.txt for details.
 
+Joystick support
+CONFIG_JOYSTICK
+  If you have a joystick, 6dof controller, gamepad, steering wheel,
+  weapon control system or something like that you can say Y here to
+  enable generic support for these controllers. You will also need to
+  say Y or M to at least one of the hardware specific drivers. This
+  will make the controllers available as /dev/jsX devices. Please read
+  the file Documentation/joystick.txt which contains more information
+  and the location of the joystick package that you'll need.
+
+Classic PC analog
+CONFIG_JOY_ANALOG
+  Say Y here if you have a controller that connects to the PC
+  gameport. This supports many different types, including joysticks
+  with throttle control, with rudders, or with extensions like
+  additional hats and buttons compatible with CH Flightstick Pro,
+  ThrustMaster FCS or 6 and 8 button gamepads. For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+FPGaming and MadCatz A3D
+CONFIG_JOY_ASSASSIN
+  Say Y here if you have an FPGaming or MadCatz controller using the
+  A3D protocol over the PC gameport. For more information on how to
+  use the driver please read Documentation/joystick.txt
+
+Gravis GrIP
+CONFIG_JOY_GRAVIS
+  Say Y here if you have a Gravis controller using the GrIP protocol
+  over the PC gameport. For more information on how to use the driver
+  please read Documentation/joystick.txt
+
+PDPI Lightning 4 card
+CONFIG_JOY_LIGHTNING
+  Say Y here if you have a PDPI Lightning 4 gamecard and an analog
+  joystick or gamepad connected to it. For more information on how to
+  use the driver please read Documentation/joystick.txt
+
+Logitech ADI
+CONFIG_JOY_LOGITECH
+  Say Y here if you have a Logitech controller using the ADI
+  protocol over the PC gameport. For more information on how to use
+  the driver please read Documentation/joystick.txt
+
+Microsoft and Genius Digital Overdrive
+CONFIG_JOY_SIDEWINDER
+  Say Y here if you have a Microsoft controller using the Digital
+  Overdrive protocol over PC gameport. For more information on how to
+  use the driver please read Documentation/joystick.txt
+
+ThrustMaster DirectConnect (BSP)
+CONFIG_JOY_THRUSTMASTER
+  Say Y here if you have a ThrustMaster controller using the
+  DirectConnect (BSP) protocol over the PC gameport. For more
+  information on how to use the driver please read
+  Documentation/joystick.txt
+
+Creative Labs Blaster
+CONFIG_JOY_CREATIVE
+  Say Y here if you have a Creative Labs controller using the
+  Blaster protocol over the PC gameport. For more information on how
+  to use the driver please read Documentation/joystick.txt
+
+Magellan and Space Mouse
+CONFIG_JOY_MAGELLAN
+  Say Y here if you have a Magellan or Space Mouse 6DOF controller
+  connected to your computer's serial port.  For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+SpaceTec SpaceOrb 360 and SpaceBall Avenger
+CONFIG_JOY_SPACEORB
+  Say Y here if you have a SpaceOrb 360 or SpaceBall Avenger 6DOF
+  controller connected to your computer's serial port.  For more
+  information on how to use the driver please read
+  Documentation/joystick.txt
+
+Logitech WingMan Warrior
+CONFIG_JOY_WARRIOR
+  Say Y here if you have a Logitech WingMan Warrior controller
+  connected to your computer's serial port.  For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+NES, SNES, PSX, Multi
+CONFIG_JOY_CONSOLE
+  Say Y here if you have a Nintendo Entertainment System gamepad,
+  Super Nintendo Entertainment System gamepad, Sony PlayStation
+  gamepad or a Multisystem -- Atari, Amiga, Commodore, Amstrad CPC
+  joystick. For more information on how to use the driver please read
+  Documentation/joystick.txt and Documentation/joystick-parport.txt
+
+Sega, Multi
+CONFIG_JOY_DB9
+  Say Y here if you have a Sega Master System gamepad, Sega Genesis
+  gamepad, Sega Saturn gamepad, or a Multisystem -- Atari, Amiga,
+  Commodore, Amstrad CPC joystick. For more information on how to use
+  the driver please read Documentation/joystick.txt and
+  Documentation/joystick-parport.txt
+
+TurboGraFX interface
+CONFIG_JOY_TURBOGRAFX
+  Say Y here if you have the TurboGraFX interface by Steffen Schwenke,
+  and want to use it with Multiststem -- Atari, Amiga, Commodore,
+  Amstrad CPC joystick. For more information on how to use the driver
+  please read Documentation/joystick-parport.txt and
+  Documentation/joystick-parport.txt
+
+Amiga joysticks
+CONFIG_JOY_AMIGA
+  Say Y here if you have an Amiga with a digital joystick connected
+  to it. For more information on how to use the driver please read
+  Documentation/joystick.txt
+
 Sound card support
 CONFIG_SOUND
   If you have a Sound Card in your Computer, i.e. if it can say more
diff -urN linux-2.0.36/Documentation/joystick-api.txt linux-2.0.36-joystick/Documentation/joystick-api.txt
--- linux-2.0.36/Documentation/joystick-api.txt	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/Documentation/joystick-api.txt	Mon Feb 22 00:33:42 1999
@@ -0,0 +1,312 @@
+		      Joystick API Documentation                -*-Text-*-
+
+		       Ragnar Hojland Espinosa
+		     <ragnar@lightside.ddns.org>
+
+			      7 Aug 1998
+
+
+1. Initialization
+~~~~~~~~~~~~~~~~~
+
+Open the joystick device following the usual semantics (that is, with open).
+Since the driver now reports events instead of polling for changes,
+immediately after the open it will issue a series of synthetic events
+(JS_EVENT_INIT) that you can read to check the initial state of the
+joystick.
+
+By default, the device is opened in blocking mode.
+
+	int fd = open ("/dev/js0", O_RDONLY);
+
+
+2. Event Reading
+~~~~~~~~~~~~~~~~
+
+	struct js_event e;
+	read (fd, &e, sizeof(struct js_event));
+
+where js_event is defined as
+
+	struct js_event {
+		__u32 time;     /* event timestamp in miliseconds */
+		__s16 value;    /* value */
+		__u8 type;      /* event type */
+		__u8 number;    /* axis/button number */
+	};
+
+If the read is successfull, it will return sizeof(struct js_event), unless
+you wanted to read more than one event per read as described in section 3.1.
+
+
+2.1 js_event.type
+~~~~~~~~~~~~~~~~~
+
+The possible values of ``type'' are
+
+	#define JS_EVENT_BUTTON         0x01    /* button pressed/released */
+	#define JS_EVENT_AXIS           0x02    /* joystick moved */
+	#define JS_EVENT_INIT           0x80    /* initial state of device */
+
+As mentioned above, the driver will issue synthetic JS_EVENT_INIT ORed
+events on open. That is, if it's issuing a INIT BUTTON event, the
+current type value will be
+
+	int type = JS_EVENT_BUTTON | JS_EVENT_INIT;	/* 0x81 */
+
+If you choose not to differentiate between synthetic or real events
+you can turn off the JS_EVENT_INIT bits
+
+	type &= ~JS_EVENT_INIT;				/* 0x01 */
+
+
+2.2 js_event.number
+~~~~~~~~~~~~~~~~~~~
+
+The values of ``number'' correspond to the axis or button that
+generated the event. Note that they carry separate numeration (that
+is, you have both an axis 0 and a button 0). Generally,
+
+			number
+	1st Axis X	0
+	1st Axis Y	1
+	2nd Axis X	2
+	2nd Axis Y	3
+	...and so on
+
+Hats vary from one joystick type to another. Some can be moved in 8
+directions, some only in 4, however, the driver always reports a hat as two
+independent axis, even if the hardware doesn't allow independent movement.
+
+
+2.3 js_event.value
+~~~~~~~~~~~~~~~~~~
+
+For an axis, ``value'' is a signed integer between -32767 and +32767
+representing the position of the joystick along that axis. If you
+don't read a 0 when the joystick is `dead', or if it doesn't span the
+full range, you should recalibrate (with, for example, jscal).
+
+For a button, ``value'' for a press button event is 1 and for a release
+button event is 0.
+
+Though this
+
+	if (js_event.type == JS_EVENT_BUTTON) {
+	   buttons_state ^= (1 << js_event.number);
+	}
+
+may work well if you handle JS_EVENT_INIT events separately,
+
+	if ((js_event.type & ~JS_EVENT_INIT) == JS_EVENT_BUTTON) {
+	   if (js_event.value)
+	      buttons_state |= (1 << js_event.number);
+	   else
+	      buttons_state &= ~(1 << js_event.number);
+	}
+
+is much safer since it can't lose sync with the driver. As you would
+have to write a separate handler for JS_EVENT_INIT events in the first
+snippet, this ends up being shorter.
+
+
+2.4 js_event.time
+~~~~~~~~~~~~~~~~~
+
+The time an event was generated is stored in ``js_event.time''. It's a time
+in miliseconds since ... well, since sometime in the past.  This eases the
+task of detecting double clicks, figuring out if movement of axis and button
+presses happened at the same time, and similar.
+
+
+3. Reading
+~~~~~~~~~~
+
+If you open the device in blocking mode, a read will block (that is,
+wait) forever until an event is generated and effectively read. There
+are two alternatives if you can't afford to wait forever (which is,
+admittedly, a long time;)
+
+	a) use select to wait until there's data to be read on fd, or
+	   until it timeouts. There's a good example on the select(2)
+	   man page.
+
+	b) open the device in non-blocking mode (O_NONBLOCK)
+
+
+3.1 O_NONBLOCK
+~~~~~~~~~~~~~~
+
+If read returns -1 when reading in O_NONBLOCK mode, this isn't
+necessarily a "real" error (check errno(3)); it can just mean there
+are no events pending to be read on the driver queue. You should read
+all events on the queue (that is, until you get a -1).
+
+For example,
+
+	while (1) {
+	   while (read (fd, &e, sizeof(struct js_event)) > 0) {
+	      process_event (e);
+	   }
+	   /* EAGAIN is returned when the queue is empty */
+	   if (errno != EAGAIN) {
+	      /* error */
+	   }
+	   /* do something interesting with processed events */
+	}
+
+One reason for emptying the queue is that if it gets full you'll start
+missing events since the queue is finite, and older events will get
+overwritten.
+
+The other reason is that you want to know all what happened, and not
+delay the processing till later.
+
+Why can get the queue full? Because you don't empty the queue as
+mentioned, or because too much time elapses from one read to another
+and too many events to store in the queue get generated. Note that
+high system load may contribute to space those reads even more.
+
+If time between reads is enough to fill the queue and loose an event,
+the driver will switch to startup mode and next time you read it,
+synthetic events (JS_EVENT_INIT) will be generated to inform you of
+the actual state of the joystick.
+
+[As for version 1.2.8, the queue is circular and able to hold 64
+ events. You can increment this size bumping up JS_BUFF_SIZE in
+ joystick.h and recompiling the driver.]
+
+
+In the above code, you might as well want to read more than one event
+at a time using the typical read(2) functionality. For that, you would
+replace the read above with something like
+
+	struct js_event mybuffer[0xff];
+	int i = read (fd, mybuffer, sizeof(struct mybuffer));
+
+In this case, read would return -1 if the queue was empty, or some
+other value in which the number of events read would be i /
+sizeof(js_event)  Again, if the buffer was full, it's a good idea to
+process the events and keep reading it until you empty the driver queue.
+
+
+4. IOCTLs
+~~~~~~~~~
+
+The joystick driver defines the following ioctl(2) operations.
+
+				/* function			3rd arg  */
+	#define JSIOCGAXES	/* get number of axes		char	 */
+	#define JSIOCGBUTTONS	/* get number of buttons	char	 */
+	#define JSIOCGVERSION	/* get driver version		int	 */
+	#define JSIOCGNAME(len) /* get identifier string	char	 */
+	#define JSIOCSCORR	/* set correction values	&js_corr */
+	#define JSIOCGCORR	/* get correction values	&js_corr */
+
+For example, to read the number of axes
+
+	char number_of_axes;
+	ioctl (fd, JSIOCGAXES, &number_of_axes);
+
+
+4.1 JSIOGCVERSION
+~~~~~~~~~~~~~~~~~
+
+JSIOGCVERSION is a good way to check in run-time whether the running
+driver is 1.0+ and supports the event interface. If it is not, the
+IOCTL will fail. For a compile-time decision, you can test the
+JS_VERSION symbol
+
+	#ifdef JS_VERSION
+	#if JS_VERSION > 0xsomething
+
+4.2 JSIOCGNAME
+~~~~~~~~~~~~~~
+
+JSIOCGNAME(len) allows you to get the name string of the joystick - the same
+as is being printed at boot time. The 'len' argument is the lenght of the
+buffer provided by the application asking for the name. It is used to avoid
+possible overrun should the name be too long.
+
+	char name[128];
+	if (ioctl(fd, JSIOCGNAME(sizeof(name)), name) < 0)
+		strncpy(name, "Unknown", sizeof(name));
+	printf("Name: %s\n", name);
+
+4.3 JSIOC[SG]CORR
+~~~~~~~~~~~~~~~~~
+
+For usage on JSIOC[SG]CORR I suggest you to look into jscal.c  They are
+not needed in a normal program, only in joystick calibration software
+such as jscal or kcmjoy. These IOCTLs and data types aren't considered
+to be in the stable part of the API, and therefore may change without
+warning in following releases of the driver.
+
+Both JSIOCSCORR and JSIOCGCORR expect &js_corr to be able to hold
+information for all axis. That is, struct js_corr corr[MAX_AXIS];
+
+struct js_corr is defined as
+
+	struct js_corr {
+		__s32 coef[8];
+		__u16 prec;
+		__u16 type;
+	};
+
+and ``type''
+
+	#define JS_CORR_NONE            0x00    /* returns raw values */
+	#define JS_CORR_BROKEN          0x01    /* broken line */
+
+
+5. Backward compatibility
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The 0.x joystick driver API is quite limited and its usage is deprecated.
+The driver offers backward compatibility, though. Here's a quick summary:
+
+	struct JS_DATA_TYPE js;
+	while (1) {
+	   if (read (fd, &js, JS_RETURN) != JS_RETURN) {
+	      /* error */
+	   }
+	   usleep (1000);
+	}
+
+As you can figure out from the example, the read returns immediately,
+with the actual state of the joystick.
+
+	struct JS_DATA_TYPE {
+		int buttons;    /* immediate button state */
+		int x;          /* immediate x axis value */
+		int y;          /* immediate y axis value */
+	};
+
+and JS_RETURN is defined as
+
+	#define JS_RETURN       sizeof(struct JS_DATA_TYPE)
+
+To test the state of the buttons,
+
+	first_button_state  = js.buttons & 1;
+	second_button_state = js.buttons & 2;
+
+The axis values do not have a defined range in the original 0.x driver,
+except for that the values are non-negative. The 1.2.8+ drivers use a
+fixed range for reporting the values, 1 being the minimum, 128 the
+center, and 255 maximum value.
+
+The v0.8.0.2 driver also had an interface for 'digital joysticks', (now
+called Multisystem joysticks in this driver), under /dev/djsX. This driver
+doesn't try to be compatible with that interface.
+
+6. Final Notes
+~~~~~~~~~~~~~~
+
+____/|	Comments, additions, and specially corrections are welcome.
+\ o.O|	Documentation valid for at least version 1.2.8 of the joystick
+ =(_)=	driver and as usual, the ultimate source for documentation is
+   U	to "Use The Source Luke" or, at your convenience, Vojtech ;)
+
+					- Ragnar
+EOF
diff -urN linux-2.0.36/Documentation/joystick-parport.txt linux-2.0.36-joystick/Documentation/joystick-parport.txt
--- linux-2.0.36/Documentation/joystick-parport.txt	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/Documentation/joystick-parport.txt	Mon Mar  8 14:51:00 1999
@@ -0,0 +1,547 @@
+		  Linux Joystick parport drivers v1.2 BETA
+	       (c) 1998-1999 Vojtech Pavlik <vojtech@ucw.cz>
+	       (c) 1998 Andree Borrmann <a.borrmann@tu-bs.de>
+----------------------------------------------------------------------------
+
+0. Disclaimer
+~~~~~~~~~~~~~
+  Any information in this file is provided as-is, without any guarantee that
+it will be true. So, use it at your own risk. The possible damages that can
+happen include burning your parallel port, and/or the sticks and joystick
+and maybe even more. Like when a lightning kills you it is not our problem.
+
+1. Intro
+~~~~~~~~
+  The joystick parport drivers are used for joysticks and gamepads not
+originally designed for PCs and other computers Linux runs on. Because of
+that, PCs usually lack the right ports to connect these devices to. Parallel
+port, because of its ability to change single bits at will, and providing
+both output and input bits is the most suitable port on the PC for
+connecting such devices.
+
+2. Devices supported
+~~~~~~~~~~~~~~~~~~~~
+  Many console and 8-bit coputer gamepads and joysticks are supported. The
+following subsections discuss usage of each.
+
+2.1 NES and SNES
+~~~~~~~~~~~~~~~~
+  The Nintendo Entertainment System and Super Nintendo Entertainment System
+gamepads are widely available, and easy to get. Also, they are quite easy to
+connect to a PC, and don't need much processing speed (108 us for NES and
+165 us for SNES, compared to about 1000 us for PC gamepads) to communicate
+with them.
+
+  All NES and SNES use the same synchronous serial protocol, clocked from
+the computer's side (and thus timing insensitive). To allow up to 5 NES
+and/or SNES gamepads connected to the parallel port at once, the output
+lines of the parallel port are shared, while one of 5 available input lines
+is assigned to each gamepad.
+
+  This protocol is handled by the joy-console.c driver, so that's the one
+you'll use for NES and SNES gamepads.
+
+  The main problem with PC parallel ports is that they don't have +5V power
+source on any of their pins. So, if you want a reliable source of power
+for your pads, use either keyboard or joystick port, and make a pass-through
+cable. You can also pull the power directly from the power supply (the red
+wire is +5V).
+
+  If you want to use the parallel port only, you can take the power is from
+some data pin. For most gamepad and parport implementations only one pin is
+needed, and I'd recommend pin 9 for that, the highest data bit. On the other
+hand, if you are not planning to use anything else than NES / SNES on the
+port, anything between and including pin 4 and pin 9 will work.
+
+(pin 9) -----> Power
+
+  Unfortunately, there are pads that need a lot more of power, and parallel
+ports that can't give much current through the data pins. If this is your
+case, you'll need to use diodes (as a prevention of destroying your parallel
+port), and combine the currents of two or more data bits together.
+
+	   Diodes
+(pin 9) ----|>|-------+------> Power
+		      |
+(pin 8) ----|>|-------+
+		      |
+(pin 7) ----|>|-------+
+		      |
+ <and so on>          :
+		      |
+(pin 4) ----|>|-------+
+
+  Ground is quite easy. On PC's parallel port the ground is on any of the
+pins from pin 18 to pin 25. So use any pin of these you like for the ground.
+
+(pin 18) -----> Ground
+
+  NES and SNES pads have two input bits, Clock and Latch, which drive the
+serial transfer. These are connected to pins 2 and 3 of the parallel port,
+respectively.
+
+(pin 2) -----> Clock
+(pin 3) -----> Latch
+
+  And the last thing is the NES / SNES data wire. Only that isn't shared and
+each pad needs its own data pin. The parallel port pins are:
+
+(pin 10) -----> Pad 1 data
+(pin 11) -----> Pad 2 data
+(pin 12) -----> Pad 3 data
+(pin 13) -----> Pad 4 data
+(pin 15) -----> Pad 5 data
+
+  Note that pin 14 is not used, since it is not an input pin on the parallel
+port.
+
+  This is everything you need on the PC's side of the connection, now on to
+the gamepads side. The NES and SNES have different connectors. Also, there
+are quite a lot of NES clones, and because Nintendo used proprietary
+connectors for their machines, the cloners couldn't and used standard D-Cannon
+connectors. Anyway, if you've got a gamepad, and it has buttons A, B, Turbo
+A, Turbo B, Select and Start, and is connected through 5 wires, then it is
+either a NES or NES clone and will work with this connection. SNES gamepads
+also use 5 wires, but have more buttons. They will work as well, of course.
+
+Pinout for NES gamepads                 Pinout for SNES gamepads
+
+	   +----> Power                   +-----------------------\
+	   |                            7 | o  o  o  o |  x  x  o  | 1
+ 5 +---------+  7                         +-----------------------/
+   | x  x  o   \                            |  |  |  |          |
+   | o  o  o  o |                           |  |  |  |          +-> Ground
+ 4 +------------+ 1                         |  |  |  +------------> Data
+     |  |  |  |                             |  |  +---------------> Latch
+     |  |  |  +-> Ground                    |  +------------------> Clock
+     |  |  +----> Clock                     +---------------------> Power
+     |  +-------> Latch
+     +----------> Data
+
+Pinout for NES clone (db9) gamepads     Pinout for NES clone (db15) gamepads
+
+	+---------> Clock                    +-----------------> Data
+	| +-------> Latch                    |             +---> Ground
+	| | +-----> Data                     |             |
+	| | |                              ___________________
+    _____________                        8 \ o x x x x x x o / 1
+  5 \ x o o o x / 1                         \ o x x o x x o /
+     \ x o x o /                          15 `~~~~~~~~~~~~~' 9
+    9 `~~~~~~~' 6                             |     |     |
+	 |   |                                |     |     +----> Clock
+	 |   +----> Power                     |     +----------> Latch
+	 +--------> Ground                    +----------------> Power
+
+2.2 Multisystem joysticks
+~~~~~~~~~~~~~~~~~~~~~~~~~
+  In the era of 8-bit machines, there was something like de-facto standard
+for joystick ports. They were all digital, and all used D-Cannon 9 pin
+connectors (db9). Because of that, a single joystick could be used without
+hassle on Atari (130, 800XE, 800XL, 2600, 7200), Amiga, Commodore C64,
+Amstrad CPC, Sinclair ZX Spectrum and many other machines. That's why these
+joysticks are called "Multisystem".
+
+  Now their pinout:
+
+      +---------> Right
+      | +-------> Left
+      | | +-----> Down
+      | | | +---> Up
+      | | | |
+  _____________
+5 \ x o o o o / 1
+   \ x o x o /
+  9 `~~~~~~~' 6
+       |   |
+       |   +----> Button
+       +--------> Ground
+
+  However, as time passed, extension to this standard developed, and these
+were not compatible with each other:
+
+
+  Atari 130, 800(XL/XE)                    MSX
+
+					 +-----------> Power
+      +---------> Right                  | +---------> Right
+      | +-------> Left                   | | +-------> Left
+      | | +-----> Down                   | | | +-----> Down
+      | | | +---> Up                     | | | | +---> Up
+      | | | |                            | | | | |
+  _____________                        _____________
+5 \ x o o o o / 1                    5 \ o o o o o / 1
+   \ x o o o /                          \ o o o o /
+  9 `~~~~~~~' 6                        9 `~~~~~~~' 6
+       | | |                              | | | |
+       | | +----> Button                  | | | +----> Button 1
+       | +------> Power                   | | +------> Button 2
+       +--------> Ground                  | +--------> Output 3
+					  +----------> Ground
+
+       Amstrad CPC                         Commodore C64
+
+					 +-----------> Analog Y
+      +---------> Right                  | +---------> Right
+      | +-------> Left                   | | +-------> Left
+      | | +-----> Down                   | | | +-----> Down
+      | | | +---> Up                     | | | | +---> Up
+      | | | |                            | | | | |
+  _____________                        _____________
+5 \ x o o o o / 1                    5 \ o o o o o / 1
+   \ x o o o /                          \ o o o o /
+  9 `~~~~~~~' 6                        9 `~~~~~~~' 6
+       | | |                              | | | |
+       | | +----> Button 1                | | | +----> Button
+       | +------> Button 2                | | +------> Power
+       +--------> Ground                  | +--------> Ground
+					  +----------> Analog X
+
+  And there were many others.
+
+2.2.1 Multisystem joysticks using joy-db9.c
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  For the Multisystem joysticks, and their derivatives, the joy-db9.c driver
+was written. It allows only one joystick / gamepad per parallel port, but
+the interface is easy to build and works with almost anything.
+
+  For the basic 1-button Multisystem joystick you connect its wires to the
+parallel port like this:
+
+(pin  1) -----> Power
+(pin 18) -----> Ground
+
+(pin  2) -----> Up
+(pin  3) -----> Down
+(pin  4) -----> Left
+(pin  5) -----> Right
+(pin  6) -----> Button 1
+
+  However, if the joystick is switch based (eg. clicks when you move it),
+you might or might not, depending on your parallel port, need 10 kOhm pullup
+resistors on each of the direction and button signals, like this:
+
+(pin 2) ------------+------> Up
+	  Resistor  |
+(pin 1) --[10kOhm]--+
+
+  Try without, and if it doesn't work, add them. For TTL based joysticks /
+gamepads the pullups are not needed.
+
+  For joysticks with two buttons you connect the second button to pin 7 on
+the parallel port.
+
+(pin 7) -----> Button 2
+
+  And that's it.
+
+  On a side note, if you have already built a different adapter for use with
+the digital joystick driver 0.8.0.2, this is also supported by the joy-db9.c
+driver, as device type 8. (See section 3.2)
+
+2.2.2 Multisystem joysticks using joy-console.c
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  For some people just one joystick per parallel port is not enough, and/or
+want to use them on one parallel port together with NES/SNES/PSX pads. This
+is possible using the joy-console.c. It supports up to 5 devices of the
+above types, including 1 and 2 buttons Multisystem joysticks.
+
+  However, there is nothing for free. To allow more sticks to be used at
+once, you need the sticks to be purely switch based (that is non-TTL), and
+not to need power. Just a plain simple six switches inside. If your
+joystick can do more (eg. turbofire) you'll need to disable it totally first
+if you want to use joy-console.c.
+
+  Also, the connection is a bit more complex. You'll need a bunch of diodes,
+and one pullup resistor. First, you connect the Directions and the button
+the same as for joy-db9, however with the diodes inbetween.
+
+	    Diodes
+(pin 2) -----|<|----> Up
+(pin 3) -----|<|----> Down
+(pin 4) -----|<|----> Left
+(pin 5) -----|<|----> Right
+(pin 6) -----|<|----> Button 1
+
+  For two button sticks you also connect the other button.
+
+(pin 7) -----|<|----> Button 2
+
+  And finally, you connect the Ground wire of the joystick, like done in
+this little schematic to Power and Data on the parallel port, as described
+for the NES / SNES pads in section 2.1 of this file - that is, one data pin
+for each joystick. The power source is shared.
+
+Data    ------------+-----> Ground
+	  Resistor  |
+Power   --[10kOhm]--+
+
+  And that's all, here we go!
+
+2.2.3 Multisystem joysticks using joy-turbografx.c
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  The TurboGraFX interface, designed by
+
+	Steffen Schwenke <schwenke@burg-halle.de>
+
+  allows up to 7 Multisystem joysticks connected to the parallel port. In
+Steffen's version, there is support for up to 5 buttons per joystick.
+However, since this doesn't work reliably on all parallel ports, the
+joy-turbografx.c driver supports only one button per joystick. For more
+information on how to build the interface, see
+
+	http://www2.burg-halle.de/~schwenke/parport.html
+
+2.3 Sony Playstation
+~~~~~~~~~~~~~~~~~~~~
+
+  WARNING: PSX support is experimental, and at the moment doesn't seem to
+work for most people. If you like adventure, you can try yourself.
+
+  The PSX controller is supported by the joy-console.c.
+
+Pinout of the PSX controller:
+
+  +---------+---------+---------+
+9 | o  o  o | o  o  o | o  o  o | 1               parallel
+   \________|_________|________/                  port pins
+    |  |      |  |  |   |
+    |  |      |  |  |   +-------->  Clock    ---  (1)
+    |  |      |  |  +------------>  Select   ---  (17)
+    |  |      |  +--------------->  Power    ---  (16)
+    |  |      +------------------>  Ground   ---  (18-25)
+    |  +------------------------->  Command  ---  (14)
+    +---------------------------->  Data     ---  (10,11,12,13,15) one only...
+
+  You may have to add pull up/down resistors. Maybe your pad also won't like
+the 5V (PSX uses 3.7V).
+
+  Currently the driver supports only ONE psx pad and only one type of
+controller: The normal PSX controller. NEGCON support is planned for the
+next release. ANALOG controller may be too (I do not recommend to connect
+the "force feedback"/"rumble pack" version... it (may) use too much
+power...)
+
+2.4 Sega
+~~~~~~~~
+  All the Sega controllers are more or less based on the standard 2-button
+Multisystem joystick. However, since they don't use switches and use TTL
+logic, the only driver useable with them is the joy-db9.c driver.
+
+2.4.1 Sega Master System
+~~~~~~~~~~~~~~~~~~~~~~~~
+  The SMS gamepads are almost exactly the same as normal 2-button
+Multisystem joysticks. Set the driver to Multi2 mode, use the corresponding
+parallel port pins, and the following schematic:
+
+    +-----------> Power
+    | +---------> Right
+    | | +-------> Left
+    | | | +-----> Down
+    | | | | +---> Up
+    | | | | |
+  _____________
+5 \ o o o o o / 1
+   \ o o x o /
+  9 `~~~~~~~' 6
+     | |   |
+     | |   +----> Button 1
+     | +--------> Ground
+     +----------> Button 2
+
+2.4.2 Sega Genesis aka MegaDrive
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  The Sega Genesis (in Europe sold as Sega MegaDrive) pads are an extension
+to the Sega Master System pads. They use more buttons (3+1, 5+1, 6+1).  Use
+the following schematic:
+
+    +-----------> Power
+    | +---------> Right
+    | | +-------> Left
+    | | | +-----> Down
+    | | | | +---> Up
+    | | | | |
+  _____________
+5 \ o o o o o / 1
+   \ o o o o /
+  9 `~~~~~~~' 6
+     | | | |
+     | | | +----> Button 1
+     | | +------> Select
+     | +--------> Ground
+     +----------> Button 2
+
+  The Select pin goes to pin 14 on the parallel port.
+
+(pin 14) -----> Select
+
+  The rest is the same as for Multi2 joysticks using joy-db9.c
+
+2.4.3 Sega Saturn
+~~~~~~~~~~~~~~~~~
+  Sega Saturn has eight buttons, and to transfer that, without hacks like
+Genesis 6 pads use, it needs one more select pin. Anyway, it is still
+handled by the joy-db9.c driver. Its pinout is very different from anything
+else.  Use this schematic:
+
+    +-----------> Select 1
+    | +---------> Power
+    | | +-------> Up
+    | | | +-----> Down
+    | | | | +---> Ground
+    | | | | |
+  _____________
+5 \ o o o o o / 1
+   \ o o o o /
+  9 `~~~~~~~' 6
+     | | | |
+     | | | +----> Select 2
+     | | +------> Right
+     | +--------> Left
+     +----------> Power
+
+  Select 1 is pin 14 on the parallel port, Select 2 is pin 16 on the
+parallel port.
+
+(pin 14) -----> Select 1
+(pin 16) -----> Select 2
+
+  The other pins (Up, Down, Right, Left, Power, Ground) are the same as for
+Multi joysticks using joy-db9.c
+
+3. The drivers
+~~~~~~~~~~~~~~
+  There are three drivers for the parallel port interfaces. Each, as
+described above, allows to connect a different group of joysticks and pads.
+Here are described their command lines:
+
+3.1 joy-console.c
+~~~~~~~~~~~~~~~~~
+  Using joy-console.c you can connect up to five devices to one parallel
+port. It uses the following kernel/module command line:
+
+	js_console=port,pad1,pad2,pad3,pad4,pad5
+
+  Where 'port' is either the address of the parallel port the joystick/pad
+is connected to (eg. 0x378), or, if you are using the parport driver of 2.1+
+Linux kernels, the number of the parport interface (eg. 0 for parport0).
+
+  And 'pad1' to 'pad5' are pad types connected to different data input pins
+(10,11,12,13,15), as described in section 2.1 of this file.
+
+  The types are:
+
+	Type | Joystick/Pad
+	--------------------
+	  0  | None
+	  1  | SNES pad
+	  2  | NES pad
+	  4  | Multisystem 1-button joystick
+	  5  | Multisystem 2-button joystick
+	  6  | Sony PSX controller
+
+  The exact type of the PSX controller type is autoprobed, so you must have
+your controller plugged in before initializing.
+
+  Should you want to use more than one of parallel ports at once, you can
+use js_console_2 and js_db9_3 as additional command line parameters for two
+more parallel ports.
+
+  Changes:
+    v0.1  : First version (SNES only)
+    v0.2  : X/Y directions were exchanged...
+    v0.3  : Adaptation for kernel 2.1
+    v0.4  : Adaptation for joystick-1.2.6
+	    - added open/close callbacks
+    v0.5  : Renamed to "joy-console" because I have added
+	    PSX controller support.
+    v0.6  : NES support
+    v0.7V : Added "multi system" support
+    v0.8  : Bugfixed PSX driver...
+    v0.9V : Changed multi system support
+	    Added Multi2 support
+	    Fixed parport handling
+	    Cleaned up
+    v0.10 : Fixed PSX buttons 8 and 9
+    v0.11V: Switched to EXCL mode
+	    Removed wakeup
+
+3.2 joy-db9.c
+~~~~~~~~~~~~~
+  Apart from making an interface, there is nothing difficult on using the
+joy-db9.c driver. It uses the following kernel/module command line:
+
+	js_db9=port,type
+
+  Where 'port' is either the address of the parallel port the joystick/pad
+is connected to (eg. 0x378), or, if you are using the parport driver of 2.1+
+Linux kernels, the number of the parport interface (eg. 0 for parport0).
+
+  'Type' is the type of joystick or pad attached:
+
+	Type | Joystick/Pad
+	--------------------
+	  0  | None
+	  1  | Multisystem 1-button joystick
+	  2  | Multisystem 2-button joystick
+	  3  | Genesis pad (3+1 buttons)
+	  5  | Genesis pad (5+1 buttons)
+	  6  | Genesis pad (6+1 buttons)
+	  7  | Saturn pad
+	  8  | Multisystem 1-button joystick (v0.8.0.2 pin-out)
+
+  Should you want to use more than one of these joysticks/pads at once, you
+can use js_db9_2 and js_db9_3 as additional command line parameters for two
+more joysticks/pads.
+
+  Changes:
+    v0.1 : First version
+    v0.2 : Changed kernel parameter format
+    v0.3V: Added Sega Saturn support
+	   Fixed parport and PS/2 mode handling
+	   Cleaned up
+    v0.4V: Switched to EXCL mode
+           Removed wakeup
+    v0.5V: Added 0.8.0.2 HW compatibility for Multi sticks
+    v0.6V: Better timing for Genesis 6
+
+3.3 joy-turbografx.c
+~~~~~~~~~~~~~~~~~~~~
+  The joy-turbografx.c driver uses a very simple kernel/module command line:
+
+	js_tg=port,js1,js2,js3,js4,js5,js6,js7
+
+  Where 'port' is either the address of the parallel port the interface is
+connected to (eg. 0x378), or, if you are using the parport driver of 2.1+
+Linux kernels, the number of the parport interface (eg. 0 for parport0).
+
+  'jsX' is the number of buttons the Multisystem joysticks connected to the
+interface ports 1-7 have. For a standard multisystem joystick, this is 1.
+
+  Should you want to use more than one of these interfaces at once, you can
+use js_tg_2 and js_tg_3 as additional command line parameters for two more
+interfaces.
+
+3.4 PC parallel port pinout
+~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  .----------------------------------------.
+   At the PC:     \ 13 12 11 10  9  8  7  6  5  4  3  2  1 /
+                   \  25 24 23 22 21 20 19 18 17 16 15 14 /
+                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+	  Pin | Name    | Description
+	~~~~~~|~~~~~~~~~|~~~~~~~~~~
+	    1 | /STROBE | Strobe
+	  2-9 | D0-D7   | Data Bit 0-7
+	   10 | /ACK    | Acknowledge
+	   11 | BUSY    | Busy
+	   12 | PE      | Paper End
+	   13 | SELIN   | Select In
+	   14 | /AUTOFD | Autofeed
+	   15 | /ERROR  | Error
+	   16 | /INIT   | Initialize
+	   17 | /SEL    | Select
+	18-25 | GND     | Signal Ground
+
+3.5 End
+~~~~~~~
+  That's all, folks! Have fun!
diff -urN linux-2.0.36/Documentation/joystick.txt linux-2.0.36-joystick/Documentation/joystick.txt
--- linux-2.0.36/Documentation/joystick.txt	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/Documentation/joystick.txt	Mon Mar  8 15:20:58 1999
@@ -0,0 +1,720 @@
+		     Linux Joystick driver v1.2.14
+	       (c) 1996-1999 Vojtech Pavlik <vojtech@ucw.cz>
+----------------------------------------------------------------------------
+
+0. Disclaimer
+~~~~~~~~~~~~~
+  This program is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2 of the License, or (at your option)
+any later version.
+
+  This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+more details.
+
+  You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc., 59
+Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+  Should you need to contact me, the author, you can do so either by e-mail
+- mail your message to <vojtech@ucw.cz>, or by paper mail: Vojtech Pavlik,
+Ucitelska 1576, Prague 8, 182 00 Czech Republic
+
+  For your convenience, the GNU General Public License version 2 is included
+in the package: See the file COPYING.
+
+1. Intro
+~~~~~~~~
+  The joystick driver for Linux provides support for a variety of joysticks
+and similar devices.
+
+  These currently include various analog joysticks and gamepads (both
+variable resistor based and microswitch+resistor based), following IBM PC
+joystick standard, with extensions like additional hats and buttons
+compatible with CH Flightstick Pro, ThrustMaster FCS or 6 and 8 button
+gamepads.
+
+  In addition to these it also supports some of the new PC joysticks that
+use proprietary digital protocols to communicate over the gameport,
+currently by FPGaming, Genius, Gravis, Logitech, MadCatz, Microsoft and
+ThrustMaster. Creative Labs protocol support is still to be done.
+
+  The driver also includes support for many gamepads and joysticks that were
+used by various non-PC computers and game consoles. These include Multi
+system joysticks (Atari, Amiga, Commodore, Amstrad), Sega gamepads (Master
+System, Genesis, Saturn), Nintendo gamepads (NES, SNES), Sony gamepads (PSX).
+Support for N64, Atari Jaguar, Atari 2600, NES FourScore, SNES MultiTap,
+PSX NegCon and others might be added later.
+
+  Last, but not least there is also native Amiga joystick support for the
+Amiga Linux port.
+
+  Should you encounter any problems while using the driver, or joysticks
+this driver can't make complete use of, I'm very interested in hearing about
+them. Bug reports and success stories are also welcome.
+
+  The joystick package is available at the following FTP sites:
+
+	ftp://atrey.karlin.mff.cuni.cz/pub/linux/joystick/
+	ftp://artax.karlin.mff.cuni.cz/pub/linux/joystick/
+
+  The joystick driver is also included in the Linux 2.1 kernels:
+
+	ftp://linux.kernel.org/pub/linux/kernel/v2.1/
+
+  And a homepage of the driver is at:
+
+	http://atrey.karlin.mff.cuni.cz/~vojtech/joystick/
+	http://artax.karlin.mff.cuni.cz/~vojtech/joystick/
+
+  A mirror of the homepage is at:
+
+	http://www.trylinux.com/projects/joystick/
+
+  There is also a mailing list for the driver at:
+
+	listproc@atrey.karlin.mff.cuni.cz
+
+send "subscribe linux-joystick Your Name" to subscribe to it.
+
+2. Usage
+~~~~~~~~
+  You could have obtained this driver in two different ways - either in the
+joystick package or in the kernel. Because, for successful usage of the
+joysticks, the utilities in the package are useful, maybe necessary, and
+definitely recommended, I suggest you getting the package at some of the
+above mentioned locations. The rest of this file assumes you have it.
+
+2.1 Compiling the driver package
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  To compile the utilities in the joystick package, and the driver itself,
+as a standalone module, you first unpack the package, and then edit the
+Makefile to meet your needs (namely whether are you using versioned
+modules). You will also need an unpacked and configured
+
+	make config
+
+kernel in
+	
+	/usr/src/linux
+
+Furthermore, if you're using versioned modules, you'll also need
+
+	make dep
+
+done on the kernel, to create some needed files.
+
+After that, you compile the joystick driver
+
+	make
+
+  And after that you install it
+
+	make install
+
+  In case you have not used the driver before, you'll need to create the
+joystick device files in /dev so that applications can use them:
+
+	make devs
+
+  For manual creation of the joystick devices, check the
+Documentation/devices.txt file in the Linux source tree.
+
+  Should you not want to mess with the kernel, and just use the driver
+standalone, as modules, skip the next two sections, proceeding right to 2.4,
+because all you need is already done.
+
+2.2 Patching the kernel
+~~~~~~~~~~~~~~~~~~~~~~~
+  If you already have the most recent joystick driver in your kernel, skip
+this section. If not, you need to patch the kernel, so that it contains the
+current driver version.  You do that with a command: 
+
+	patch -Esp1 < /usr/src/joystick-1.2.x/kernel-2.x.y.diff
+
+in
+
+	/usr/src/linux
+
+2.3 Compiling the kernel
+~~~~~~~~~~~~~~~~~~~~~~~~
+  To compile joystick support into the kernel, use the kernel configuration
+scripts, and answer 'Y' to Joystick support and also to at least one of the
+hardware specific options. After doing something like
+
+	make bzlilo
+
+  you are done with the driver installation. Just reboot and the driver
+should find all the connected joysticks. Read the notes about the hardware
+specific drivers later in this file, though.
+
+  You can also compile the driver as modules, answering 'M' to all joystick
+support you want to have modules for. It is possible to have the main
+joystick driver compiled into the kernel and the hardware dependent drivers
+as modules. After you compile the modules 
+
+	make modules
+
+  And install them
+
+	make modules_install
+
+ you're set, and can proceed to the next step.
+
+2.4 Inserting the modules into the kernel
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  After installing the modules you'll first need to insert the generic
+joystick driver module into the kernel
+
+	insmod joystick
+
+  and then one or more of the hardware specific modules
+
+	insmod joy-something
+
+  where 'something' is the type of your joystick. See below for more precise
+explanation.
+
+2.5 Verifying that it works
+~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  For testing the joystick driver functionality, there is the jstest
+program. You run it by typing:
+
+	jstest /dev/js0
+
+  And it should show a line with the joystick values, which update as you
+move the stick, and press its buttons. The axes should all be zero when the
+joystick is in the center position. They should not jitter by themselves to
+other close values, and they also should be steady in any other position of
+the stick. They should have the full range from -32767 to 32767. If all this
+is met, then it's all fine, and you can play the games. :)
+
+  If it's not, then there might be a problem. Try to calibrate the joystick,
+and if it still doesn't work, read the drivers section of this file, the
+troubleshooting section, and the FAQ.
+
+2.6. Calibration
+~~~~~~~~~~~~~~~~
+  For most joysticks you won't need any manual calibration, since the
+joystick should be autocalibrated by the driver automagically. However, with
+some analog joysticks, that either do not use linear resistors, or if you
+want better precision, you can use the jscal program
+
+	jscal -c /dev/js0
+
+ included in the joystick package to set better correction coefficients than
+what the driver would choose itself.
+
+  After calibrating the joystick you can verify if you like the new
+calibration using the jstest command, and if you do, you then can save the
+correction coefficients into a file
+
+	jscal -p /dev/js0 > /etc/joystick.cal
+
+  And add a line to your rc script executing that file
+
+	source /etc/joystick.cal
+
+  This way, after the next reboot your joystick will remain calibrated. You
+can also add the jscal -p line to your shutdown script.
+
+
+3. HW specific driver information
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+In this section each of the separate hardware specific drivers is described.
+
+3.1 Analog joysticks
+~~~~~~~~~~~~~~~~~~~~
+  The joy-analog.c uses the standard analog inputs of the gameport, and thus
+supports all standard joysticks and gamepads. It also supports extensions
+like additional hats and buttons compatible with CH Flightstick Pro,
+ThrustMaster FCS or 6 and 8 button gamepads. 
+
+  However the only types that can be autodetected are:
+
+* 2-axis, 4-button joystick
+* 3-axis, 4-button joystick
+* Two 2-axis, 2-button joysticks on an Y-cable
+
+  For other joystick types (more/less axes, hats, and buttons) support
+you'll need to specify the types either on the kernel command line or on the
+module command line, when inserting joy-analog.o into the kernel. The
+parameters are:
+
+	js_an=p0,m0,n0,p1,m1,n1 ...
+
+  Where 'p' is the port number, eg. 0x201, which is the standard address.
+'m' and 'n' are joystick 0 and joystick 1 bitmasks for the specified
+joystick port. The bits in the bitmasks mean:
+
+	Bit |   2^n | Meaning
+	----------------------------------
+	 0  |     1 | Axis X1
+	 1  |     2 | Axis Y1
+	 2  |     4 | Axis X2
+	 3  |     8 | Axis Y2
+	 4  |    16 | Button A
+	 5  |    32 | Button B
+	 6  |    64 | Button C
+	 7  |   128 | Button D
+	 8  |   256 | CHF Buttons X and Y
+	 9  |   512 | CHF Hat 1
+	10  |  1024 | CHF Hat 2
+	11  |  2048 | FCS Hat
+	12  |  4096 | Pad Button X
+	13  |  8192 | Pad Button Y
+	14  | 16384 | Pad Button U
+	15  | 32768 | Pad Button V
+
+(CHF = CH Flightstick Pro, FCS = ThrustMaster FCS)
+
+  Following is a table of joysticks for which the 'm' values are known. If
+you have any additions/corrections to it, e-mail me.
+
+	Joystick				| 'm' value
+	----------------------------------------------------
+	Genius Flight2000 F-12			| 0x00f3
+	Genius Flight2000 F-21			| 0x08f7
+	Genius Flight2000 F-22			| 0x02ff
+	Genius GameHunter G-06			| 0xf0f3
+	Genius MaxFire G-07			| 0xf0f3   
+	Genius PowerStation			| 0xf0f3
+	Laing #1 PC SuperPad			| 0xf0f3
+	Microsoft SideWinder Standard		| 0x003b
+	QuickShot QS-201 SuperWarrior		| 0x00fb
+	Saitek Megapad XII			| 0x30f3
+
+  In case you have one of the joystick in the table below, and it doesn't
+work with a specific driver in digital mode for some reason, you can use
+them in analog mode with the joy-analog driver as well. However, digital
+operation is always better.
+
+	Joystick				| 'm' value
+	----------------------------------------------------
+	Gravis GamePad Pro - analog mode	| 0x00f3
+	Genius Flight2000 F-23 - CHF mode	| 0x02ff
+	Genius Flight2000 F-23 - FCS mode	| 0x08f7
+	Microsoft SideWinder 3D Pro - CHF mode	| 0x02ff
+	Microsoft SideWinder 3D Pro - FCS mode	| 0x08f7
+
+  An example that would configure the driver to use two two axis, two button
+joysticks connected to port 0x201, a single four button four axis joystick
+connected to port 0x202, a four axis, six button and two hat CHF compatible
+joystick on 0x203, and a two axis four button FCS compatible joystick with a
+single hat on 0x207:
+
+	js_an=0x201,0x33,0xcc,0x202,0xff,0,0x203,0x7ff,0,0x207,0x8f3,0
+
+  If you can't sum bits into hex numbers in your head easily, you can simply
+sum the values in the 2^n column decimally and use that number instead.
+Using this method you'd get a command line:
+
+	js_an=0x201,51,204,0x202,255,0,0x203,2047,0,0x207,2291,0
+
+  And it would do the same as the above explained command line. Use
+whichever way you like best.
+
+3.2 Microsoft SideWinder and Genius Digital joysticks
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  Microsoft and Genius 'Digital Overdrive' protocol is supported by the
+joy-sidewinder.c module. All currently supported joysticks:
+
+* Genius Flight2000 Digital F-23
+* SideWinder 3D Pro
+* SideWinder Force Feedback Pro
+* SideWinder Force Feedback Wheel
+* SideWinder FreeStyle Pro
+* SideWinder GamePad (up to four, chained together)
+* SideWinder Precision Pro 
+
+  are autodetected, and thus no module parameters are needed.
+
+  There is one caveat with the 3D Pro and the F-23 models. There are 9
+buttons reported, although the joystick has only 8. The 9th button is the
+mode switch on the rear side of the joystick. However, moving it, you'll
+reset the joystick, and make it unresponsive for about a one third of a
+second. Furthermore, the joystick will also re-center itself, taking the
+position it was in during this time as a new center position. Use it if
+you want, but think first.
+
+  The SideWinder Standard is not a digital joystick, and thus is supported
+by the analog driver described above. 
+
+3.3 Logitech ADI devices
+~~~~~~~~~~~~~~~~~~~~~~~~
+  Logitech ADI protocol is supported by the joy-logitech.c module. It should
+support any Logitech device using this protocol. This includes, but is not
+limited to:
+
+* Logitech CyberMan 2
+* Logitech ThunderPad Digital
+* Logitech WingMan Extreme Digital
+* Logitech WingMan Formula
+* Logitech WingMan GamePad
+* Logitech WingMan Interceptor
+
+  ADI devices are autodetected, and the driver supports up to two (any
+combination of) devices on a single gameport, using an Y-cable or chained
+together.
+
+  Logitech WingMan Joystick, Logitech WingMan Extreme and Logitech
+ThunderPad are not digital joysticks and are handled by the analog driver
+described above. Logitech WingMan Warrior and Logitech Magellan are
+supported by serial drivers described below. Logitech CyberMan, Logitech
+WingMan Force and Logitech WingMan Formula Force are not supported yet.
+
+3.4 Gravis GrIP
+~~~~~~~~~~~~~~~
+  Gravis GrIP protocol is supported by the joy-gravis.c module. It
+currently supports:
+
+* Gravis GamePad Pro
+* Gravis Xterminator
+* Gravis BlackHawk Digital
+
+  All these devices are autodetected, and you can even use any combination
+of up to two of these pads either chained together or using an Y-cable on a
+single gameport.
+
+GrIP MultiPort support is in the works. Gravis Xcalibur, ArcadeXtreme,
+GamePad Pro/M are joysticks/pads that probably never reached mass
+production. Gravis Stinger is a serial device and hopefully will be
+supported in the future.
+
+3.5 FPGaming A3D and MadCatz A3D
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  The Assassin 3D protocol created by FPGaming, is used both by FPGaming
+themselves and is licensed to MadCatz. A3D devices are supported by the
+joy-assassin.c module. It currently supports:
+
+* FPGaming Assassin 3D
+* MadCatz Panther
+* MadCatz Panther XL
+
+  All these devices are autodetected. Because the Assassin 3D and the Panther
+allow connecting analog joysticks to them, these are supported in this
+driver, too. The driver uses the js_as parameter for the analog joysticks,
+which has the same syntax as js_an for the analog driver.
+
+  The trackball support is far from perfect at this stage of development,
+but should be well usable.
+
+3.6 ThrustMaster DirectConnect (BSP)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  The TM DirectConnect (BSP) protocol is supported by the joy-thrustmaster.c
+module. This includes, but is not limited to:
+
+* ThrustMaster Millenium 3D Inceptor
+* ThrustMaster 3D Rage Pad
+
+  Devices not directly supported, but hopefully working are:
+
+* ThrustMaster FragMaster
+* ThrustMaster Fusion Digital Game Pad
+* ThrustMaster Attack Throttle
+
+  If you have one of these, contact me.
+
+  BSP devices are autodetected, and thus no parameters to the module
+are needed.
+
+3.7 Creative Labs Blaster
+~~~~~~~~~~~~~~~~~~~~~~~~~
+  The Blaster protocol is supported by the joy-creative.c module. It
+currently supports only the:
+
+* Creative Blaster GamePad Cobra
+
+  Up to two of these can be used on a single gameport, using an Y-cable.
+
+3.8 PDPI Lightning 4 gamecards
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  PDPI Lightning 4 gamecards are supported by the joy-lightning.c module.
+This driver is only for analog joysticks connected to the card - if you want
+to use some of the digital devices, you need to use its specific driver. The
+card will work in legacy mode with them, though.
+
+  Since all features of analog joysticks can't be detected, this driver
+needs a command line:
+
+	js_l4=p0,m0,n0,p1,m1,n1,....
+
+  As you can see, it's very similar to the analog drivers command line.
+Actually it is the same except for the meaning of p0. p0 in this case is the
+port the joystick is attached to:
+
+	  p  | Port
+	----------------------------
+	  0  | Primary card, port 1
+	  1  | Primary card, port 2
+	  2  | Primary card, port 3
+	  3  | Primary card, port 4
+	  4  | Secondary card, port 1
+	  5  | Secondary card, port 2
+	  6  | Secondary card, port 3
+	  7  | Secondary card, port 4
+
+  Two cards maximum are allowed in one system, because of the card's design.
+
+  See the description of analog joystick driver for explanations of m0 and
+n0 values.
+
+3.9 Amiga
+~~~~~~~~~
+  Amiga joysticks, connected to an Amiga, are supported by the joy-amiga.c
+driver. Since they can't be autodetected, the driver has a command line.
+
+	js_am=a,b
+
+  a and b define the joysticks connected to the JOY0DAT and JOY1DAT ports of
+the Amiga.
+
+	Value | Joystick type
+	---------------------
+	  0   | None
+	  1   | 1-button digital joystick
+
+  No more joystick types are supported now, but that should change in the
+future if I get an Amiga in the reach of my fingers.
+
+3.10 Game console and 8-bit pads and joysticks
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+See joystick-parport.txt for more info.
+
+3.11 SpaceTec devices
+~~~~~~~~~~~~~~~~~~~~~
+  SpaceTec serial devices communicate using the SpaceWare protocol. It is
+supported by the joy-spaceorb driver. The devices currently supported are:
+
+* SpaceTec SpaceBall Avenger
+* SpaceTec SpaceOrb 360
+
+  In addition to having the joy-spaceorb module in the kernel, you also need
+to attach a serial port to it. to do that, run the jsattach program:
+
+	jsattach --spaceorb /dev/ttySx &
+
+where /dev/ttySx is the serial port which the device is connected to. After
+doing this, the device will be reported and will start working.
+
+  There is one caveat with the SpaceOrb. The button #6, the on the bottom
+side of the orb, although reported as an ordinary button, causes internal
+recentering of the spaceorb, moving the zero point to the position in which
+the ball is at the moment of pressing the button. So, think first before
+you bind it to some other function.
+
+SpaceTec SpaceBall 2003 FLX and 3003 FLX are not supported yet. 
+
+3.12 Logitech SWIFT devices
+~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  The SWIFT serial protocol is supported by the joy-warrior module. It
+currently supports only the:
+
+* Logitech WingMan Warrior
+
+but in the future, Logitech CyberMan (the original one, not CM2) could be
+supported as well. To use the module, you need to run jsattach after you
+insert/compile the module into your kernel:
+
+	jsattach --warrior /dev/ttySx &
+
+ttySx is the serial port your Warrior is attached to.
+
+3.13 Magellan / Space Mouse
+~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  The Magellan (or Space Mouse), manufactured by LogiCad3d (formerly Space
+Systems), for many other companies (Logitech, HP, ...) is supported by the
+joy-magellan module. It currently supports only the:
+
+* Magellan 3D
+* Space Mouse
+
+models, the additional buttons on the 'Plus' versions are not supported yet.
+
+  To use it, you need to attach the serial port to the driver using the
+
+	jsattach --magellan /dev/ttySx &
+
+command. After that the Magellan will be detected, initialized, will beep,
+and the /dev/jsX device should become useable.
+
+4. Troubleshooting
+~~~~~~~~~~~~~~~~~~
+  There is quite a high probability that you run into some problems. For
+testing whether the driver works, if in doubt, use the jstest utility in
+some of its modes. The most useful modes are "normal" - for the 1.x
+interface, and "old" for the "0.x" interface. You run it by typing:
+
+	jstest --normal /dev/js0
+	jstest --old    /dev/js0
+
+  If your trouble stems from the fact the drivers can't detect the joystick
+attached to your gameport, and you decide you need my help (which I will
+gladly provide), please use the joydump utility first. It's created just by
+typing
+
+	make joydump.o
+
+  in the directory where you unpacked the joystick package. It is run then
+by typing
+
+	insmod joydump.o
+
+  in the same directory. It will return a 'device busy' or 'initialization
+failed' error. This is perfectly okay. It has already done it's job. The
+results can be found in the system log. Please send me the results along
+with your problem report.
+
+  Oh, and read the FAQ! :)
+
+5. FAQ
+~~~~~~
+Q: The driver doesn't find any joysticks connected to my soundcard with the
+   message "joy-something: no joysticks found" and "joy-something.o:
+   init_module: Device or resource busy." or "Initialization of joy-something
+   failed"  What could be the cause?
+A: The most common cause is that the joystick port on your soundcard is
+   not enabled. If it is an ISA PnP card, you'll need isapnptools to configure
+   the gameport. Non-PnP cards usually use some option to the sound driver -
+   see the sound driver docs and source and enable the port.
+
+Q: Any access to the joystick devices gives me "Operation not supported by
+   device". What am I doing wrong?
+A: You're running a 2.0 kernel and you forgot to insmod the hardware
+   specific module. You not only need the joystick.o, but also one of the other
+   joy-*.o files (most usually joy-analog.o), as described in this document,
+   section 2. If you are not using modules, then you didn't say 'Y' to any of
+   the hardware-specific questions. Again, see section 2. If you did select
+   the specific support, and you still get this message, check that you
+   selected the right one, and if it still doesn't work, go to the previous
+   FAQ.
+
+Q: Everything is fine, except I get "No such device" error when I try to
+   do anything with /dev/js0. What's the cause?
+A: You're running a 2.1 or 2.2. kernel and you want to read the previous FAQ.
+
+Q: Upon 'insmod joystick.o' I get a LOT of unresolved symbols, including
+   'printk' and others. Why?
+A: You either don't have your kernel compiled with module support. If
+   that's the cause, re-compile your kernel with module support switched on.
+   Or, you use versioned symbols, and don't have -DMODVERSIONS in the joystick
+   driver Makefile, or vice versa. Correct the situation by either removing or
+   adding -DMODVERSIONS to the Makefile.
+
+Q: Upon 'insmod joy-something' I get a bunch of unresolved symbols, like
+   'js_register_port, js_unregister device' and others. What's wrong?
+A: You need to 'insmod joystick.o' first.
+
+Q: Running 'jstest 1' or 'jscal 1' doesn't work, and returns with "File
+   not found" error. What is the problem?
+A: The command line interface for these tools is different from what
+   version 0.8.0 used. You have to specify the whole device name, eg. 'jstest
+   /dev/js0'.
+
+Q: Running 'jstest /dev/js0' results in "File not found" error. What's the
+   cause?
+A: The device files don't exist. Run 'make devs'.
+
+Q: Is it possible to connect my old Atari/Commodore/Amiga/console joystick
+   or pad that uses a 9-pin D-type cannon connector to the serial port of my
+   PC?
+A: Yes, it is possible, but it'll burn your serial port or the pad. It
+   won't work, of course.
+
+Q: My joystick doesn't work with Quake / Quake 2. What's the cause?
+A: Quake / Quake 2 don't support joystick. Use joy2key to simulate keypresses
+   for them.
+
+6. Programming Interface
+~~~~~~~~~~~~~~~~~~~~~~~~
+  The 1.0 driver uses a new, event based approach to the joystick driver.
+Instead of the user program polling for the joystick values, the joystick
+driver now reports only any changes of its state. See joystick-api.txt,
+joystick.h and jstest.c included in the joystick package for more
+information. The joystick device can be used in either blocking or
+nonblocking mode and supports select() calls.
+
+  For backward compatibility the old (v0.x) interface is still included.
+Any call to the joystick driver using the old interface will return values
+that are compatible to the old interface.  This interface is still limited
+to 2 axes, and applications using it usually decode only 2 buttons, although
+the driver provides up to 32.
+
+7. Credits
+~~~~~~~~~~
+  Thanks to the following people who contributed code, ideas or specifications
+to the joystick driver development:
+
+	Arthur C. Smith		<asmith@cbnewsd.att.com>
+	Eyal Lebedinsky		<eyal@eyal.emu.id.au>
+	Jeff Tranter		<tranter@software.mitel.com>
+	Carlos Puchol		<cpg@cs.utexas.edu>
+	Matt Rhoten		<mrhoten@oz.net>
+	Dan Fandrich		<dan@fch.wimsey.bc.ca>
+	Sverker Wilberg		<sverkerw@manila.docs.uu.se>
+	Hal Maney		<maney@norden.com>
+	Bernd Schmidt		<crux@pool.informatik.rwth-aachen.de>
+	Alan Cox		<alan@lxorguk.ukuu.org.uk>
+	John Markus Bjorndalen	<johnm@cs.uit.no>
+	Boris Muehmer		<mhs@cybernet-ag.de>
+	Robert W. Grubbs	<rwgrubbs@vt.edu>
+	Pete Chown		<pete.chown@skygate.co.uk>
+	Benji York		<benji@cookeville.com>
+	Leslie F. Donaldson	<donaldlf@cs.rose-hulman.edu>
+	Eng-Jon Ong		<ongej@dcs.qmw.ac.uk>
+	Ragnar Hojland Espinosa	<ragnar@lightside.ddns.org>
+	Brian Gerst		<bgerst@quark.vpplus.com>
+	Andree Borrmann		<a.borrmann@tu-bs.de>
+	Martin Giguere		<zefrench@hotmail.com>
+	David Thompson		<dcthomp@mail.utexas.edu>
+	Justin Wake		<spectre@telefragged.com>
+	Benoit Triquet		<benoit@adsl-216-100-248-201.dsl.pacbell.net>
+
+  If you think you should be in this list and are not, it's possible that
+I forgot to include you - contact me and I'll correct the error. :)
+
+  Thanks to KYE Systems Europe, who provided me with driver sources for the
+Genius Flight2000 Digital F-23, which happens to be identical (in software)
+to Microsoft SideWinder 3D Pro.
+
+  Thanks to ThrustMaster Inc. who provided me with docs for their digital
+protocol specifications, and to Trystan A Larey-Williams <axe@mail.wsu.edu>,
+who wrote an attempt of a driver for them.
+
+  Thanks to Creative Labs Europe, and Ifor Powell <ipowell@cle.creaf.com>,
+who provided me with docs for their first generation Blaster GamePad.
+
+  Special thanks go to FP-Gaming, Inc. and James C Barnes <james@fpgaming.com>,
+who provided me with help and detailed information about the Assassin 3D
+protocol and devices, and even sent me a Panther and Panther XL for testing,
+along with cool T-shirts.
+
+  Special thanks to PDPI, Mike Pelkey <pdpi@email.msn.com> and Brand Kvavle
+<BrandK@blackdiamond.com>, for providing me with documentation and example
+code for their L4 gamecard, and sending me the card to test my driver with
+it.
+
+  Thanks to LogiCad3D for their support, for having the specifications
+online and for the nice music on their telephone.
+
+  Special thanks to Logitech, Jerry de Raad <Jerry_de_Raad@logitech.com>,
+Thomas Burgel <Thomas_Burgel@logitech.com>, Avinash Shinde
+<Avinash_Shinde@logitech.com> for providing me with a lot of documentation
+for their devices, and also for a big box, containing a CyberMan2, Wingman
+Extreme, Magellan, Wingman Warrior, two MouseMan mice, and a NewTouch
+keyboard.
+
+  Thanks to everyone else who helped me develop this package of drivers!
+
+  No thanks to Microsoft and Gravis, who don't release a word about their
+hardware .... :(
+
+8. ChangeLog
+~~~~~~~~~~~~
+  See the ChangeLog file for the log of changes.
+
+9. To do
+~~~~~~~~
+  See the TODO file for the list of things planned.
diff -urN linux-2.0.36/MAINTAINERS linux-2.0.36-joystick/MAINTAINERS
--- linux-2.0.36/MAINTAINERS	Sun Nov 15 19:32:44 1998
+++ linux-2.0.36-joystick/MAINTAINERS	Mon Mar  8 14:48:52 1999
@@ -264,6 +264,13 @@
 W:	http://www.isdn4linux.de
 S:	Maintained
 
+JOYSTICK DRIVER
+P:	Vojtech Pavlik
+M:	vojtech@ucw.cz
+W:	http://atrey.karlin.mff.cuni.cz/~vojtech/joystick/
+L:	linux-joystick@atrey.karlin.mff.cuni.cz
+S:	Maintained
+
 MODULE SUPPORT [GENERAL], KERNELD
 P:	Bjorn Ekwall
 M:	bj0rn@blox.se
diff -urN linux-2.0.36/drivers/char/Config.in linux-2.0.36-joystick/drivers/char/Config.in
--- linux-2.0.36/drivers/char/Config.in	Sun Nov 15 19:32:53 1998
+++ linux-2.0.36-joystick/drivers/char/Config.in	Mon Mar  8 14:48:52 1999
@@ -36,6 +36,11 @@
 
 bool 'Support for user misc device modules' CONFIG_UMISC
 
+tristate 'Joystick support' CONFIG_JOYSTICK
+if [ "$CONFIG_JOYSTICK" != "n" ]; then
+  source drivers/char/joystick/Config.in
+fi
+
 bool 'QIC-02 tape support' CONFIG_QIC02_TAPE
 if [ "$CONFIG_QIC02_TAPE" = "y" ]; then
   bool 'Do you want runtime configuration for QIC-02' CONFIG_QIC02_DYNCONF
diff -urN linux-2.0.36/drivers/char/Makefile linux-2.0.36-joystick/drivers/char/Makefile
--- linux-2.0.36/drivers/char/Makefile	Sun Nov 15 19:32:53 1998
+++ linux-2.0.36-joystick/drivers/char/Makefile	Mon Mar  8 14:48:52 1999
@@ -11,7 +11,7 @@
 
 SUB_DIRS     := 
 MOD_SUB_DIRS := $(SUB_DIRS)
-ALL_SUB_DIRS := $(SUB_DIRS) ftape
+ALL_SUB_DIRS := $(SUB_DIRS) ftape joystick
 
 #
 # This file contains the font map for the default (hardware) font
@@ -119,6 +119,16 @@
 else
   ifeq ($(CONFIG_PRINTER),m)
   M_OBJS += lp.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOYSTICK),y)
+L_OBJS += joystick/js.o
+SUB_DIRS += joystick
+MOD_SUB_DIRS += joystick
+else
+  ifeq ($(CONFIG_JOYSTICK),m)
+  MOD_SUB_DIRS += joystick
   endif
 endif
 
diff -urN linux-2.0.36/drivers/char/joystick/Config.in linux-2.0.36-joystick/drivers/char/joystick/Config.in
--- linux-2.0.36/drivers/char/joystick/Config.in	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/Config.in	Mon Mar  8 14:48:52 1999
@@ -0,0 +1,21 @@
+#
+# Joystick lowlevel driver configuration
+#
+
+tristate '   Classic PC analog' CONFIG_JOY_ANALOG
+tristate '   FPGaming and MadCatz A3D' CONFIG_JOY_ASSASSIN
+tristate '   Gravis GrIP' CONFIG_JOY_GRAVIS
+tristate '   Logitech ADI' CONFIG_JOY_LOGITECH
+tristate '   Microsoft and Genius Digital Overdrive' CONFIG_JOY_SIDEWINDER
+tristate '   ThrustMaster DirectConnect (BSP)' CONFIG_JOY_THRUSTMASTER
+tristate '   Creative Labs Blaster' CONFIG_JOY_CREATIVE
+tristate '   PDPI Lightning 4 card' CONFIG_JOY_LIGHTNING
+tristate '   Magellan and Space Mouse' CONFIG_JOY_MAGELLAN
+tristate '   SpaceTec SpaceOrb 360 and SpaceBall Avenger' CONFIG_JOY_SPACEORB
+tristate '   Logitech WingMan Warrior' CONFIG_JOY_WARRIOR
+tristate '   NES, SNES, PSX, Multi' CONFIG_JOY_CONSOLE
+tristate '   Sega, Multi' CONFIG_JOY_DB9
+tristate '   TurboGraFX interface' CONFIG_JOY_TURBOGRAFX
+if [ "$CONFIG_AMIGA" = "y" ]; then
+  tristate '   Amiga joysticks' CONFIG_JOY_AMIGA
+fi
diff -urN linux-2.0.36/drivers/char/joystick/Makefile linux-2.0.36-joystick/drivers/char/joystick/Makefile
--- linux-2.0.36/drivers/char/joystick/Makefile	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/Makefile	Mon Mar  8 14:48:52 1999
@@ -0,0 +1,144 @@
+#
+# Makefile for the joystick drivers.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definitions are now inherited from the
+# parent makes..
+#
+
+O_TARGET := js.o
+O_OBJS   :=
+M_OBJS   :=
+
+ifeq ($(CONFIG_JOYSTICK),y)
+O_OBJS += joystick.o
+else
+  ifeq ($(CONFIG_JOYSTICK),m)
+  M_OBJS += joystick.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_AMIGA),y)
+O_OBJS += joy-amiga.o
+else
+  ifeq ($(CONFIG_JOY_AMIGA),m)
+  M_OBJS += joy-amiga.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_ANALOG),y)
+O_OBJS += joy-analog.o
+else
+  ifeq ($(CONFIG_JOY_ANALOG),m)
+  M_OBJS += joy-analog.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_ASSASSIN),y)
+O_OBJS += joy-assassin.o
+else
+  ifeq ($(CONFIG_JOY_ASSASSIN),m)
+  M_OBJS += joy-assassin.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_CONSOLE),y)
+O_OBJS += joy-console.o
+else
+  ifeq ($(CONFIG_JOY_CONSOLE),m)
+  M_OBJS += joy-console.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_CREATIVE),y)
+O_OBJS += joy-creative.o
+else
+  ifeq ($(CONFIG_JOY_CREATIVE),m)
+  M_OBJS += joy-creative.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_DB9),y)
+O_OBJS += joy-db9.o
+else
+  ifeq ($(CONFIG_JOY_DB9),m)
+  M_OBJS += joy-db9.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_GRAVIS),y)
+O_OBJS += joy-gravis.o
+else
+  ifeq ($(CONFIG_JOY_GRAVIS),m)
+  M_OBJS += joy-gravis.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_LIGHTNING),y)
+O_OBJS += joy-lightning.o
+else
+  ifeq ($(CONFIG_JOY_LIGHTNING),m)
+  M_OBJS += joy-lightning.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_LOGITECH),y)
+O_OBJS += joy-logitech.o
+else
+  ifeq ($(CONFIG_JOY_LOGITECH),m)
+  M_OBJS += joy-logitech.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_MAGELLAN),y)
+O_OBJS += joy-magellan.o
+else
+  ifeq ($(CONFIG_JOY_MAGELLAN),m)
+  M_OBJS += joy-magellan.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_SIDEWINDER),y)
+O_OBJS += joy-sidewinder.o
+else
+  ifeq ($(CONFIG_JOY_SIDEWINDER),m)
+  M_OBJS += joy-sidewinder.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_SPACEORB),y)
+O_OBJS += joy-spaceorb.o
+else
+  ifeq ($(CONFIG_JOY_SPACEORB),m)
+  M_OBJS += joy-spaceorb.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_THRUSTMASTER),y)
+O_OBJS += joy-thrustmaster.o
+else 
+  ifeq ($(CONFIG_JOY_THRUSTMASTER),m)
+  M_OBJS += joy-thrustmaster.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_TURBOGRAFX),y)
+O_OBJS += joy-turbografx.o
+else 
+  ifeq ($(CONFIG_JOY_TURBOGRAFX),m)
+  M_OBJS += joy-turbografx.o
+  endif
+endif
+
+ifeq ($(CONFIG_JOY_WARRIOR),y)
+O_OBJS += joy-warrior.o
+else
+  ifeq ($(CONFIG_JOY_WARRIOR),m)
+  M_OBJS += joy-warrior.o
+  endif
+endif
+
+include $(TOPDIR)/Rules.make
diff -urN linux-2.0.36/drivers/char/joystick/joy-amiga.c linux-2.0.36-joystick/drivers/char/joystick/joy-amiga.c
--- linux-2.0.36/drivers/char/joystick/joy-amiga.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-amiga.c	Mon Mar  8 15:39:44 1999
@@ -0,0 +1,157 @@
+/*
+ *  joy-amiga.c  Version 1.2
+ *
+ *  Copyright (c) 1998-1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * microswitch based joystick connected to Amiga joystick port.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/system.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/amigahw.h>
+
+static struct js_port* js_am_port __initdata = NULL;
+
+MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
+MODULE_PARM(js_am, "1-2i");
+
+static int __initdata js_am[] = { 0, 0 };
+
+/*
+ * js_am_read() reads and Amiga joystick data.
+ */
+
+static int js_am_read(void *info, int **axes, int **buttons)
+{
+	int data = 0;
+
+	switch (*(int*)info) {
+		case 0:
+			data = ~custom.joy0dat;
+			buttons[0][0] = (~ciaa.pra >> 6) & 1;
+			break;
+
+		case 1:
+			data = ~custom.joy1dat;
+			buttons[0][0] = (~ciaa.pra >> 7) & 1;
+			break;
+
+		default:
+			return -1;
+	}
+
+	axes[0][0] = ((data >> 1) & 1) - ((data >> 9) & 1);
+	data = ~(data ^ (data << 1));
+	axes[0][1] = ((data >> 1) & 1) - ((data >> 9) & 1);
+
+	return 0;
+}
+
+/*
+ * js_am_open() is a callback from the file open routine.
+ */
+
+static int js_am_open(struct js_dev *jd)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_am_close() is a callback from the file release routine.
+ */
+
+static int js_am_close(struct js_dev *jd)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_am_init_corr() initializes correction values of
+ * Amiga joysticks.
+ */
+
+static void __init js_am_init_corr(struct js_corr **corr)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		corr[0][i].type = JS_CORR_BROKEN;
+		corr[0][i].prec = 0;
+		corr[0][i].coef[0] = 0;
+		corr[0][i].coef[1] = 0;
+		corr[0][i].coef[2] = (1 << 29);
+		corr[0][i].coef[3] = (1 << 29);
+	}
+}
+
+#ifndef MODULE
+void __init js_am_setup(char *str, int *ints)
+{
+	int i;
+	for (i = 0; i <= ints[0] && i < 2; i++) js_am[i] = ints[i+1];
+}
+#endif
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_am_init(void)
+#endif
+{
+	int i;
+
+	for (i = 0; i < 2; i++)
+		if (js_am[i]) {
+			js_am_port = js_register_port(js_am_port, &i, 1, sizeof(int), js_am_read);
+			printk(KERN_INFO "js%d: Amiga joystick at joy%ddat\n",
+				js_register_device(js_am_port, 0, 2, 1, "Amiga joystick", js_am_open, js_am_close), i);
+			js_am_init_corr(js_am_port->corr);
+		}
+	if (js_am_port) return 0;
+
+#ifdef MODULE
+	printk(KERN_WARNING "joy-amiga: no joysticks specified\n");
+#endif
+
+	return -ENODEV;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	while (js_am_port) {
+		if (js_am_port->devs[0])
+			js_unregister_device(js_am_port->devs[0]);
+		js_am_port = js_unregister_port(js_am_port);
+	}
+}
+#endif
diff -urN linux-2.0.36/drivers/char/joystick/joy-analog.c linux-2.0.36-joystick/drivers/char/joystick/joy-analog.c
--- linux-2.0.36/drivers/char/joystick/joy-analog.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-analog.c	Mon Mar  8 15:39:55 1999
@@ -0,0 +1,309 @@
+/*
+ *  joy-analog.c  Version 1.2
+ *
+ *  Copyright (c) 1996-1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * up to two analog (or CHF/FCS) joysticks on a single joystick port.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/io.h>
+#include <asm/param.h>
+#include <asm/system.h>
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+
+#define JS_AN_MAX_TIME		3000	/* 3 ms */
+#define JS_AN_LOOP_TIME		2000	/* 2 t */
+
+static int js_an_port_list[] __initdata = {0x201, 0};
+static struct js_port* js_an_port __initdata = NULL;
+
+MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
+MODULE_PARM(js_an, "2-24i");
+
+static int __initdata js_an[] = { -1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0 };
+
+#include "joy-analog.h"
+
+struct js_ax_info {
+        int io;
+	int speed;
+	int loop;
+	int timeout;
+        struct js_an_info an;
+};
+
+/*
+ * Time macros.
+ */
+
+#ifdef __i386__
+#ifdef CONFIG_X86_TSC
+#define GET_TIME(x)	__asm__ __volatile__ ( "rdtsc" : "=a" (x) : : "dx" )
+#define DELTA(x,y)	((x)-(y))
+#define TIME_NAME "TSC"
+#else
+#define GET_TIME(x)	do { outb(0, 0x43); x = inb(0x40); x |= inb(0x40) << 8; } while (0)
+#define DELTA(x,y)	((y)-(x)+((y)<(x)?1193180L/HZ:0))
+#define TIME_NAME "PIT"
+#endif
+#elif __alpha__
+#define GET_TIME(x)	__asm__ __volatile__ ( "rpcc %0" : "=r" (x) )
+#define DELTA(x,y)	((x)-(y))
+#define TIME_NAME "PCC"
+#endif
+
+#ifndef GET_TIME
+#define FAKE_TIME
+static unsigned long js_an_faketime = 0;
+#define GET_TIME(x)     do { x = js_an_faketime++; } while(0)
+#define DELTA(x,y)	((x)-(y))
+#define TIME_NAME "Unreliable"
+#endif
+
+/*
+ * js_an_read() reads analog joystick data.
+ */
+
+static int js_an_read(void *xinfo, int **axes, int **buttons)
+{
+	struct js_ax_info *info = xinfo;
+	struct js_an_info *an = &info->an;
+	int io = info->io;
+	unsigned long flags;
+	unsigned char buf[4];
+	unsigned int time[4];
+	unsigned char u, v, w;
+	unsigned int p, q, r, s, t;
+	int i, j;
+
+	an->buttons = (~inb(io) & JS_AN_BUTTONS_STD) >> 4;
+
+	i = 0;
+	w = ((an->mask[0] | an->mask[1]) & JS_AN_AXES_STD) | (an->extensions & JS_AN_HAT_FCS)
+	  | ((an->extensions & JS_AN_BUTTONS_PXY_XY) >> 2) | ((an->extensions & JS_AN_BUTTONS_PXY_UV) >> 4);
+	p = info->loop;
+	q = info->timeout;
+	
+	__save_flags(flags);
+	__cli();
+	outb(0xff,io);
+	GET_TIME(r);
+	__restore_flags(flags);
+	t = r;
+	v = w;
+	do {
+		s = t;
+		u = v;
+		__cli();
+		v = inb(io) & w;
+		GET_TIME(t);
+		__restore_flags(flags);
+		if ((u ^ v) && (DELTA(t,s) < p)) {
+			time[i] = t;
+			buf[i] = u ^ v;
+			i++;
+		}
+	} while (v && (i < 4) && (DELTA(t,r) < q));
+
+	v <<= 4;
+
+	for (--i; i >= 0; i--) {
+		v |= buf[i];
+		for (j = 0; j < 4; j++)
+			if (buf[i] & (1 << j)) an->axes[j] = (DELTA(time[i],r) << 10) / info->speed;
+	}
+
+	js_an_decode(an, axes, buttons);
+
+	return -(v != w);
+}
+
+/*
+ * js_an_open() is a callback from the file open routine.
+ */
+
+static int js_an_open(struct js_dev *jd)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_an_close() is a callback from the file release routine.
+ */
+
+static int js_an_close(struct js_dev *jd)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_an_calibrate_timer() calibrates the timer and computes loop
+ * and timeout values for a joystick port.
+ */
+
+static void __init js_an_calibrate_timer(struct js_ax_info *info)
+{
+	unsigned int i, t, tx, t1, t2, t3;
+	unsigned long flags;
+	int io = info->io;
+
+	save_flags(flags);
+	cli();
+	GET_TIME(t1);
+#ifdef FAKE_TIME
+	js_an_faketime += 830;
+#endif
+	udelay(1000);
+	GET_TIME(t2);
+	GET_TIME(t3);
+	restore_flags(flags);
+
+	info->speed = DELTA(t2, t1) - DELTA(t3, t2);
+
+	tx = 1 << 30;
+
+	for(i = 0; i < 50; i++) {
+		save_flags(flags);
+		cli();
+		GET_TIME(t1);
+		for(t = 0; t < 50; t++) { inb(io); GET_TIME(t2); }
+		GET_TIME(t3);
+		restore_flags(flags);
+		udelay(i);
+		if ((t = DELTA(t2,t1) - DELTA(t3,t2)) < tx) tx = t;
+	}
+
+        info->loop = (JS_AN_LOOP_TIME * t) / 50000;
+	info->timeout = (JS_AN_MAX_TIME * info->speed) / 1000;
+}
+
+/*
+ * js_an_probe() probes for analog joysticks.
+ */
+
+static struct js_port __init *js_an_probe(int io, int mask0, int mask1, struct js_port *port)
+{
+	struct js_ax_info info, *ax;
+	int i, numdev;
+	unsigned char u;
+
+	if (io < 0) return port;
+
+	if (check_region(io, 1)) return port;
+
+	outb(0xff,io);
+	u = inb(io);
+	udelay(JS_AN_MAX_TIME);
+	u = (inb(io) ^ u) & u;
+
+	if (!u) return port;
+	if (u & 0xf0) return port;
+
+	if ((numdev = js_an_probe_devs(&info.an, u, mask0, mask1, port)) <= 0)
+		return port;
+
+	info.io = io;
+	js_an_calibrate_timer(&info);
+
+	request_region(info.io, 1, "joystick (analog)");
+	port = js_register_port(port, &info, numdev, sizeof(struct js_ax_info), js_an_read);
+	ax = port->info;	
+
+	for (i = 0; i < numdev; i++)
+		printk(KERN_INFO "js%d: %s ["TIME_NAME" timer, %d %sHz clock, %d0 ns res] at %#x\n",
+			js_register_device(port, i, js_an_axes(i, &ax->an), js_an_buttons(i, &ax->an),
+				js_an_name(i, &ax->an), js_an_open, js_an_close),
+			js_an_name(i, &ax->an),
+			ax->speed > 10000 ? (ax->speed + 800) / 1000 : ax->speed,
+			ax->speed > 10000 ? "M" : "k",
+			ax->loop * 100000000 / JS_AN_LOOP_TIME / ax->speed,
+			ax->io);
+
+	js_an_read(ax, port->axes, port->buttons);
+	js_an_init_corr(&ax->an, port->axes, port->corr, 8);
+
+	return port;
+}
+
+#ifndef MODULE
+void __init js_an_setup(char *str, int *ints)
+{
+	int i;
+	for (i = 0; i <= ints[0] && i < 24; i++) js_an[i] = ints[i+1];
+}
+#endif
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_an_init(void)
+#endif
+{
+	int i;
+
+	if (js_an[0] >= 0) {
+		for (i = 0; (js_an[i*3] >= 0) && i < 8; i++)
+			js_an_port = js_an_probe(js_an[i*3], js_an[i*3+1], js_an[i*3+2], js_an_port);
+	} else {
+		for (i = 0; js_an_port_list[i]; i++)
+			js_an_port = js_an_probe(js_an_port_list[i], 0, 0, js_an_port);
+	}
+	if (js_an_port) return 0;
+
+#ifdef MODULE
+	printk(KERN_WARNING "joy-analog: no joysticks found\n");
+#endif
+
+	return -ENODEV;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	int i;
+	struct js_ax_info *info;
+
+	while (js_an_port) {
+		for (i = 0; i < js_an_port->ndevs; i++)
+			if (js_an_port->devs[i])
+				js_unregister_device(js_an_port->devs[i]);
+		info = js_an_port->info;
+		release_region(info->io, 1);
+		js_an_port = js_unregister_port(js_an_port);
+	}
+
+}
+#endif
diff -urN linux-2.0.36/drivers/char/joystick/joy-analog.h linux-2.0.36-joystick/drivers/char/joystick/joy-analog.h
--- linux-2.0.36/drivers/char/joystick/joy-analog.h	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-analog.h	Sun Feb 28 00:48:22 1999
@@ -0,0 +1,296 @@
+/*
+ *  joy-analog.h  Version 1.2
+ *
+ *  Copyright (c) 1996-1999 Vojtech Pavlik
+ */
+
+/*
+ * This file is designed to be included in any joystick driver
+ * that communicates with standard analog joysticks. This currently
+ * is: joy-analog.c, joy-assassin.c, and joy-lightning.c
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#define JS_AN_AXES_STD		0x0f
+#define JS_AN_BUTTONS_STD	0xf0
+
+#define JS_AN_BUTTONS_CHF	0x01
+#define JS_AN_HAT1_CHF		0x02
+#define JS_AN_HAT2_CHF		0x04
+#define JS_AN_ANY_CHF		0x07
+#define JS_AN_HAT_FCS		0x08
+#define JS_AN_HATS_ALL		0x0e
+#define JS_AN_BUTTON_PXY_X	0x10
+#define JS_AN_BUTTON_PXY_Y	0x20
+#define JS_AN_BUTTON_PXY_U	0x40
+#define JS_AN_BUTTON_PXY_V	0x80
+#define JS_AN_BUTTONS_PXY_XY	0x30
+#define JS_AN_BUTTONS_PXY_UV	0xc0
+#define JS_AN_BUTTONS_PXY	0xf0
+
+static struct {
+	int x;
+	int y;
+} js_an_hat_to_axis[] = {{ 0, 0}, { 0,-1}, { 1, 0}, { 0, 1}, {-1, 0}};
+
+struct js_an_info {
+	unsigned char mask[2];
+	unsigned int extensions;
+	int axes[4];
+	int initial[4];
+	unsigned char buttons;
+};
+
+/*
+ * js_an_decode() decodes analog joystick data.
+ */
+
+static void js_an_decode(struct js_an_info *info, int **axes, int **buttons)
+{
+	int i, j, k;
+	int hat1, hat2, hat3;
+
+	hat1 = hat2 = hat3 = 0;
+	if (info->mask[0] & JS_AN_BUTTONS_STD) buttons[0][0] = 0;
+	if (info->mask[1] & JS_AN_BUTTONS_STD) buttons[1][0] = 0;
+
+	if (info->extensions & JS_AN_ANY_CHF) {
+		switch (info->buttons) {
+			case 0x1: buttons[0][0] = 0x01; break;
+			case 0x2: buttons[0][0] = 0x02; break;
+			case 0x4: buttons[0][0] = 0x04; break;
+			case 0x8: buttons[0][0] = 0x08; break;
+			case 0x5: buttons[0][0] = 0x10; break;
+			case 0x9: buttons[0][0] = 0x20; break;
+			case 0xf: hat1 = 1; break;
+			case 0xb: hat1 = 2; break;
+			case 0x7: hat1 = 3; break;
+			case 0x3: hat1 = 4; break;
+			case 0xe: hat2 = 1; break;
+			case 0xa: hat2 = 2; break;
+			case 0x6: hat2 = 3; break;
+			case 0xc: hat2 = 4; break;
+		}
+		k = info->extensions & JS_AN_BUTTONS_CHF ? 6 : 4;
+	} else {
+		for (i = 1; i >= 0; i--)
+			for (j = k = 0; j < 4; j++)
+				if (info->mask[i] & (0x10 << j))
+					buttons[i][0] |= ((info->buttons >> j) & 1) << k++;
+	}
+
+	if (info->extensions & JS_AN_BUTTON_PXY_X)
+		buttons[0][0] |= (info->axes[2] < (info->initial[2] >> 1)) << k++;
+	if (info->extensions & JS_AN_BUTTON_PXY_Y)
+		buttons[0][0] |= (info->axes[3] < (info->initial[3] >> 1)) << k++;
+	if (info->extensions & JS_AN_BUTTON_PXY_U)
+		buttons[0][0] |= (info->axes[2] > (info->initial[2] + (info->initial[2] >> 1))) << k++;
+	if (info->extensions & JS_AN_BUTTON_PXY_V)
+		buttons[0][0] |= (info->axes[3] > (info->initial[3] + (info->initial[3] >> 1))) << k++;
+
+	if (info->extensions & JS_AN_HAT_FCS)
+		for (j = 0; j < 4; j++)
+			if (info->axes[3] < ((info->initial[3] * ((j << 1) + 1)) >> 3)) {
+				hat3 = j + 1;
+				break;
+			}
+
+	for (i = 1; i >= 0; i--)
+		for (j = k = 0; j < 4; j++)
+			if (info->mask[i] & (1 << j))
+				axes[i][k++] = info->axes[j];
+
+	if (info->extensions & JS_AN_HAT1_CHF) {
+		axes[0][k++] = js_an_hat_to_axis[hat1].x;
+		axes[0][k++] = js_an_hat_to_axis[hat1].y;
+	}
+	if (info->extensions & JS_AN_HAT2_CHF) {
+		axes[0][k++] = js_an_hat_to_axis[hat2].x;
+		axes[0][k++] = js_an_hat_to_axis[hat2].y;
+	}
+	if (info->extensions & JS_AN_HAT_FCS) {
+		axes[0][k++] = js_an_hat_to_axis[hat3].x;
+		axes[0][k++] = js_an_hat_to_axis[hat3].y;
+	}
+}
+
+/*
+ * js_an_count_bits() counts set bits in a byte.
+ */
+
+static inline int js_an_count_bits(unsigned long c)
+{
+	int i = 0;
+	while (c) {
+		i += c & 1;
+		c >>= 1;
+	}
+	return i;
+}
+
+/*
+ * js_an_init_corr() initializes the correction values for
+ * analog joysticks.
+ */
+
+static void __init js_an_init_corr(struct js_an_info *info, int **axes, struct js_corr **corr, int prec)
+{
+	int i, j, t;
+
+	for (i = 0; i < 2; i++)
+	for (j = 0; j < js_an_count_bits(info->mask[i] & 0xf); j++) {
+
+		if ((j == 2 && (info->mask[i] & 0xb) == 0xb) ||
+		    (j == 3 && (info->mask[i] & 0xf) == 0xf)) {
+			t = (axes[i][0] + axes[i][1]) >> 1;
+		} else {
+			t = axes[i][j];
+		}
+
+		corr[i][j].type = JS_CORR_BROKEN;
+		corr[i][j].prec = prec;
+		corr[i][j].coef[0] = t - (t >> 3);
+		corr[i][j].coef[1] = t + (t >> 3);
+		corr[i][j].coef[2] = (1 << 29) / (t - (t >> 2) + 1);
+		corr[i][j].coef[3] = (1 << 29) / (t - (t >> 2) + 1);
+	}
+
+	i = js_an_count_bits(info->mask[0] & 0xf);
+
+	for (j = i; j < i + (js_an_count_bits(info->extensions & JS_AN_HATS_ALL) << 1); j++) {
+		corr[0][j].type = JS_CORR_BROKEN;
+		corr[0][j].prec = 0;
+		corr[0][j].coef[0] = 0;
+		corr[0][j].coef[1] = 0;
+		corr[0][j].coef[2] = (1 << 29);
+		corr[0][j].coef[3] = (1 << 29);
+	}
+
+	for (i = 0; i < 4; i++)
+		info->initial[i] = info->axes[i];
+}
+
+
+/*
+ * js_an_probe_devs() probes for analog joysticks.
+ */
+
+static int __init js_an_probe_devs(struct js_an_info *info, int exist, int mask0, int mask1, struct js_port *port)
+{
+	info->mask[0] = info->mask[1] = info->extensions = 0;
+
+	if (mask0 || mask1) {
+		info->mask[0] = mask0 & (exist | 0xf0);
+		info->mask[1] = mask1 & (exist | 0xf0) & ~info->mask[0];
+		info->extensions = (mask0 >> 8) & ((exist & JS_AN_HAT_FCS) | ((exist << 2) & JS_AN_BUTTONS_PXY_XY) |
+					((exist << 4) & JS_AN_BUTTONS_PXY_UV) | JS_AN_ANY_CHF);
+		if (info->extensions & JS_AN_BUTTONS_PXY) {
+			info->mask[0] &= ~((info->extensions & JS_AN_BUTTONS_PXY_XY) >> 2);
+			info->mask[0] &= ~((info->extensions & JS_AN_BUTTONS_PXY_UV) >> 4);
+			info->mask[1] = 0;
+		}
+		if (info->extensions & JS_AN_HAT_FCS) {
+			info->mask[0] &= ~JS_AN_HAT_FCS;
+			info->mask[1] = 0;
+			info->extensions &= ~(JS_AN_BUTTON_PXY_Y | JS_AN_BUTTON_PXY_U);
+		}
+		if (info->extensions & JS_AN_ANY_CHF) {
+			info->mask[0] |= 0xf0;
+			info->mask[1] = 0;
+		}
+		if (!(info->mask[0] | info->mask[1])) return -1;
+	} else {
+		switch (exist) {
+			case 0x0:
+				return -1;
+			case 0x3:
+				info->mask[0] = 0xf3; /* joystick 0, assuming 4-button */
+				break;
+			case 0xb:
+				info->mask[0] = 0xfb; /* 3-axis, 4-button joystick */
+				break;
+			case 0xc:
+				info->mask[0] = 0xcc; /* joystick 1 */
+				break;
+			case 0xf:
+				info->mask[0] = 0x33; /* joysticks 0 and 1 */
+				info->mask[1] = 0xcc;
+				break;
+			default:
+				printk(KERN_WARNING "joy-analog: Unknown joystick device detected "
+					"(data=%#x), contact <vojtech@ucw.cz>\n", exist);
+				return -1;
+		}
+	}
+
+	return !!info->mask[0] + !!info->mask[1];
+}
+
+/*
+ * js_an_axes() returns the number of axes for an analog joystick.
+ */
+
+static inline int js_an_axes(int i, struct js_an_info *info)
+{
+	return js_an_count_bits(info->mask[i] & 0x0f) + js_an_count_bits(info->extensions & JS_AN_HATS_ALL) * 2;
+}
+
+/*
+ * js_an_buttons() returns the number of buttons for an analog joystick.
+ */
+
+static inline int js_an_buttons(int i, struct js_an_info *info)
+{
+	return js_an_count_bits(info->mask[i] & 0xf0) +
+	       (info->extensions & JS_AN_BUTTONS_CHF) * 2 +
+	       js_an_count_bits(info->extensions & JS_AN_BUTTONS_PXY);
+}
+
+/*
+ * js_an_name() constructs a name for an analog joystick.
+ */
+
+static char js_an_name_buf[128] __initdata = "";
+
+static char __init *js_an_name(int i, struct js_an_info *info)
+{
+
+	sprintf(js_an_name_buf, "Analog %d-axis %d-button",
+		js_an_count_bits(info->mask[i] & 0x0f),
+		js_an_buttons(i, info));
+
+	if (info->extensions & JS_AN_HATS_ALL)
+		sprintf(js_an_name_buf, "%s %d-hat",
+			js_an_name_buf,
+			js_an_count_bits(info->extensions & JS_AN_HATS_ALL));
+
+	strcat(js_an_name_buf, " joystick");
+
+	if (info->extensions)
+		sprintf(js_an_name_buf, "%s with%s%s%s extensions",
+			js_an_name_buf,
+			info->extensions & JS_AN_ANY_CHF ? " CHF" : "",
+			info->extensions & JS_AN_HAT_FCS ? " FCS" : "",
+			info->extensions & JS_AN_BUTTONS_PXY ? " XY/UV" : "");
+
+	return js_an_name_buf;
+}
diff -urN linux-2.0.36/drivers/char/joystick/joy-assassin.c linux-2.0.36-joystick/drivers/char/joystick/joy-assassin.c
--- linux-2.0.36/drivers/char/joystick/joy-assassin.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-assassin.c	Mon Mar  8 15:40:08 1999
@@ -0,0 +1,414 @@
+/*
+ *  joy-assassin.c  Version 1.2
+ *
+ *  Copyright (c) 1998-1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * joysticks using FP-Gaming's Assassin 3D protocol.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+
+#define JS_AS_MAX_START		400
+#define JS_AS_MAX_STROBE	45
+#define JS_AS_MAX_TIME		3000
+#define JS_AS_MAX_LENGTH	40
+
+#define JS_AS_MODE_A3D		1	/* Assassin 3D */
+#define JS_AS_MODE_PAN		2	/* Panther */
+#define JS_AS_MODE_OEM		3	/* Panther OEM version */
+#define JS_AS_MODE_PXL		4	/* Panther XL */
+
+MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
+MODULE_PARM(js_as, "2-24i");
+
+static int __initdata js_as[] = { -1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0 };
+
+static int js_as_port_list[] __initdata = {0x201, 0};
+static struct js_port* js_as_port __initdata = NULL;
+
+#include "joy-analog.h"
+
+struct js_as_info {
+	int io;
+	char mode;
+	char rudder;
+	struct js_an_info an;
+};
+
+/*
+ * js_as_read_packet() reads an Assassin 3D packet.
+ */
+
+static int js_as_read_packet(int io, int length, char *data)
+{
+	unsigned char u, v;
+	int i;
+	unsigned int t;
+	unsigned long flags;
+
+	int start = (js_io_speed * JS_AS_MAX_START) >> 10;
+	int strobe = (js_io_speed * JS_AS_MAX_STROBE) >> 10;
+
+	i = 0;
+
+	__save_flags(flags);
+	__cli();
+
+	outb(0xff,io);
+	v = inb(io);
+	t = start;
+
+	while (t > 0 && i < length) {
+		t--;
+		u = v; v = inb(io);
+		if (~v & u & 0x10) {
+			data[i++] = v >> 5;
+			t = strobe;
+		}
+	}
+
+	__restore_flags(flags);
+
+	return i;
+}
+
+/*
+ * js_as_csum() computes checksum of triplet packet
+ */
+
+static int js_as_csum(char *data, int count)
+{
+	int i, csum = 0;
+	for (i = 0; i < count - 2; i++) csum += data[i];
+	return (csum & 0x3f) != ((data[count - 2] << 3) | data[count - 1]);
+}
+
+/*
+ * js_as_read() reads and analyzes A3D joystick data.
+ */
+
+static int js_as_read(void *xinfo, int **axes, int **buttons)
+{
+	struct js_as_info *info = xinfo;
+	char data[JS_AS_MAX_LENGTH];
+
+	switch (info->mode) {
+
+		case JS_AS_MODE_A3D:
+		case JS_AS_MODE_OEM:
+		case JS_AS_MODE_PAN:
+
+			if (js_as_read_packet(info->io, 29, data) != 29) return -1;
+			if (data[0] != info->mode) return -1;
+			if (js_as_csum(data, 29)) return -1;
+
+			axes[0][0] = ((data[5] << 6) | (data[6] << 3) | data[ 7]) - ((data[5] & 4) << 7);
+			axes[0][1] = ((data[8] << 6) | (data[9] << 3) | data[10]) - ((data[8] & 4) << 7);
+
+			buttons[0][0] = (data[2] << 2) | (data[3] >> 1);
+
+			info->an.axes[0] = ((char)((data[11] << 6) | (data[12] << 3) | (data[13]))) + 128;
+			info->an.axes[1] = ((char)((data[14] << 6) | (data[15] << 3) | (data[16]))) + 128;
+			info->an.axes[2] = ((char)((data[17] << 6) | (data[18] << 3) | (data[19]))) + 128;
+			info->an.axes[3] = ((char)((data[20] << 6) | (data[21] << 3) | (data[22]))) + 128;
+
+			info->an.buttons = ((data[3] << 3) | data[4]) & 0xf;
+
+			js_an_decode(&info->an, axes + 1, buttons + 1);
+
+			return 0;
+
+		case JS_AS_MODE_PXL:
+
+			if (js_as_read_packet(info->io, 33, data) != 33) return -1;
+			if (data[0] != info->mode) return -1;
+			if (js_as_csum(data, 33)) return -1;
+
+			axes[0][0] = ((char)((data[15] << 6) | (data[16] << 3) | (data[17]))) + 128;
+			axes[0][1] = ((char)((data[18] << 6) | (data[19] << 3) | (data[20]))) + 128;
+			info->an.axes[0] = ((char)((data[21] << 6) | (data[22] << 3) | (data[23]))) + 128;
+			axes[0][2] = ((char)((data[24] << 6) | (data[25] << 3) | (data[26]))) + 128;
+
+			axes[0][3] = ( data[5]       & 1) - ((data[5] >> 2) & 1);
+			axes[0][4] = ((data[5] >> 1) & 1) - ((data[6] >> 2) & 1);
+			axes[0][5] = ((data[4] >> 1) & 1) - ( data[3]       & 1);
+			axes[0][6] = ((data[4] >> 2) & 1) - ( data[4]       & 1);
+
+			axes[0][7] = ((data[ 9] << 6) | (data[10] << 3) | data[11]) - ((data[ 9] & 4) << 7);
+			axes[0][8] = ((data[12] << 6) | (data[13] << 3) | data[14]) - ((data[12] & 4) << 7);
+
+			buttons[0][0] = (data[2] << 8) | ((data[3] & 6) << 5) | (data[7] << 3) | data[8];
+
+			if (info->rudder) axes[1][0] = info->an.axes[0];
+
+			return 0;
+	}
+	return -1;
+}
+
+/*
+ * js_as_open() is a callback from the file open routine.
+ */
+
+static int js_as_open(struct js_dev *jd)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_as_close() is a callback from the file release routine.
+ */
+
+static int js_as_close(struct js_dev *jd)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_as_pxl_init_corr() initializes the correction values for
+ * the Panther XL.
+ */
+
+static void __init js_as_pxl_init_corr(struct js_corr **corr, int **axes)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		corr[0][i].type = JS_CORR_BROKEN;
+		corr[0][i].prec = 0;
+		corr[0][i].coef[0] = axes[0][i] - 4;
+		corr[0][i].coef[1] = axes[0][i] + 4;
+		corr[0][i].coef[2] = (1 << 29) / (127 - 32);
+		corr[0][i].coef[3] = (1 << 29) / (127 - 32);
+	}
+
+	corr[0][2].type = JS_CORR_BROKEN;
+	corr[0][2].prec = 0;
+	corr[0][2].coef[0] = 127 - 4;
+	corr[0][2].coef[1] = 128 + 4;
+	corr[0][2].coef[2] = (1 << 29) / (127 - 6);
+	corr[0][2].coef[3] = (1 << 29) / (127 - 6);
+
+	for (i = 3; i < 7; i++) {
+		corr[0][i].type = JS_CORR_BROKEN;
+		corr[0][i].prec = 0;
+		corr[0][i].coef[0] = 0;
+		corr[0][i].coef[1] = 0;
+		corr[0][i].coef[2] = (1 << 29);
+		corr[0][i].coef[3] = (1 << 29);
+	}
+
+	for (i = 7; i < 9; i++) {
+		corr[0][i].type = JS_CORR_BROKEN;
+		corr[0][i].prec = -1;
+		corr[0][i].coef[0] = 0;
+		corr[0][i].coef[1] = 0;
+		corr[0][i].coef[2] = (104 << 14);
+		corr[0][i].coef[3] = (104 << 14);
+	}
+}
+
+/*
+ * js_as_as_init_corr() initializes the correction values for
+ * the Panther and Assassin.
+ */
+
+static void __init js_as_as_init_corr(struct js_corr **corr)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		corr[0][i].type = JS_CORR_BROKEN;
+		corr[0][i].prec = -1;
+		corr[0][i].coef[0] = 0;
+		corr[0][i].coef[1] = 0;
+		corr[0][i].coef[2] = (104 << 14);
+		corr[0][i].coef[3] = (104 << 14);
+	}
+}
+
+/*
+ * js_as_rudder_init_corr() initializes the correction values for
+ * the Panther XL connected rudder.
+ */
+
+static void __init js_as_rudder_init_corr(struct js_corr **corr, int **axes)
+{
+	corr[1][0].type = JS_CORR_BROKEN;
+	corr[1][0].prec = 0;
+	corr[1][0].coef[0] = axes[1][0] - (axes[1][0] >> 3);
+	corr[1][0].coef[1] = axes[1][0] + (axes[1][0] >> 3);
+	corr[1][0].coef[2] = (1 << 29) / (axes[1][0] - (axes[1][0] >> 2) + 1);
+	corr[1][0].coef[3] = (1 << 29) / (axes[1][0] - (axes[1][0] >> 2) + 1);
+}
+
+/*
+ * js_as_probe() probes for A3D joysticks.
+ */
+
+static struct js_port __init *js_as_probe(int io, int mask0, int mask1, struct js_port *port)
+{
+	struct js_as_info iniinfo;
+	struct js_as_info *info = &iniinfo;
+	char *name;
+	char data[JS_AS_MAX_LENGTH];
+	unsigned char u;
+	int i;
+	int numdev;
+
+	memset(info, 0, sizeof(struct js_as_info));
+
+	if (io < 0) return port;
+
+	if (check_region(io, 1)) return port;
+
+	i = js_as_read_packet(io, JS_AS_MAX_LENGTH, data);
+
+	printk("read %d\n", i);
+
+	if (!i) return port;
+	if (js_as_csum(data, i)) return port;
+
+	if (data[0] && data[0] <= 4) {
+		info->mode = data[0];
+		info->io = io;
+		request_region(io, 1, "joystick (assassin)");
+		port = js_register_port(port, info, 3, sizeof(struct js_as_info), js_as_read);
+		info = port->info;
+	} else {
+		printk(KERN_WARNING "joy-assassin: unknown joystick device detected "
+			"(io=%#x, id=%d), contact <vojtech@ucw.cz>\n", io, data[0]);
+		return port;
+	}
+
+	udelay(JS_AS_MAX_TIME);
+
+	if (info->mode == JS_AS_MODE_PXL) {
+			printk(KERN_INFO "js%d: MadCatz Panther XL at %#x\n",
+				js_register_device(port, 0, 9, 9, "MadCatz Panther XL", js_as_open, js_as_close),
+				info->io);
+			js_as_read(port->info, port->axes, port->buttons);
+			js_as_pxl_init_corr(port->corr, port->axes);
+			if (info->an.axes[0] < 254) {
+			printk(KERN_INFO "js%d: Analog rudder on MadCatz Panther XL\n",
+				js_register_device(port, 1, 1, 0, "Analog rudder", js_as_open, js_as_close));
+				info->rudder = 1;
+				port->axes[1][0] = info->an.axes[0];
+				js_as_rudder_init_corr(port->corr, port->axes);
+			}
+			return port;
+	}
+
+	switch (info->mode) {
+		case JS_AS_MODE_A3D: name = "FP-Gaming Assassin 3D"; break;
+		case JS_AS_MODE_PAN: name = "MadCatz Panther"; break;
+		case JS_AS_MODE_OEM: name = "OEM Assassin 3D"; break;
+		default: name = "This cannot happen"; break;
+	}
+
+	printk(KERN_INFO "js%d: %s at %#x\n",
+		js_register_device(port, 0, 2, 3, name, js_as_open, js_as_close),
+		name, info->io);
+
+	js_as_as_init_corr(port->corr);
+
+	js_as_read(port->info, port->axes, port->buttons);
+
+	for (i = u = 0; i < 4; i++) if (info->an.axes[i] < 254) u |= 1 << i;
+
+	if ((numdev = js_an_probe_devs(&info->an, u, mask0, mask1, port)) <= 0)
+		return port;
+
+	for (i = 0; i < numdev; i++)
+		printk(KERN_INFO "js%d: %s on %s\n",
+			js_register_device(port, i + 1, js_an_axes(i, &info->an), js_an_buttons(i, &info->an),
+				js_an_name(i, &info->an), js_as_open, js_as_close),
+			js_an_name(i, &info->an), name);
+
+	js_an_decode(&info->an, port->axes + 1, port->buttons + 1);
+	js_an_init_corr(&info->an, port->axes + 1, port->corr + 1, 0);
+
+	return port;
+}
+
+#ifndef MODULE
+void __init js_as_setup(char *str, int *ints)
+{
+	int i;
+	for (i = 0; i <= ints[0] && i < 24; i++) js_as[i] = ints[i+1];
+}
+#endif
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_as_init(void)
+#endif
+{
+	int i;
+
+	if (js_as[0] >= 0) {
+		for (i = 0; (js_as[i*3] >= 0) && i < 8; i++)
+			js_as_port = js_as_probe(js_as[i*3], js_as[i*3+1], js_as[i*3+2], js_as_port);
+	} else {
+		for (i = 0; js_as_port_list[i]; i++) js_as_port = js_as_probe(js_as_port_list[i], 0, 0, js_as_port);
+	}
+	if (js_as_port) return 0;
+
+#ifdef MODULE
+	printk(KERN_WARNING "joy-assassin: no joysticks found\n");
+#endif
+
+	return -ENODEV;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	int i;
+	struct js_as_info *info;
+
+	while (js_as_port) {
+		for (i = 0; i < js_as_port->ndevs; i++)
+			if (js_as_port->devs[i])
+				js_unregister_device(js_as_port->devs[i]);
+		info = js_as_port->info;
+		release_region(info->io, 1);
+		js_as_port = js_unregister_port(js_as_port);
+	}
+
+}
+#endif
diff -urN linux-2.0.36/drivers/char/joystick/joy-console.c linux-2.0.36-joystick/drivers/char/joystick/joy-console.c
--- linux-2.0.36/drivers/char/joystick/joy-console.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-console.c	Mon Mar  8 15:40:35 1999
@@ -0,0 +1,597 @@
+/*
+ *  joy-console.c  Version 0.11V
+ *
+ *  Copyright (c) 1998 Andree Borrmann
+ *  Copyright (c) 1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * console (NES, SNES, Multi1, Multi2, PSX) gamepads connected
+ * via parallel port. Up to five such controllers can be
+ * connected to one parallel port.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+
+
+MODULE_AUTHOR("Andree Borrmann <A.Borrmann@tu-bs.de>");
+MODULE_PARM(js_console, "2-6i");
+MODULE_PARM(js_console2,"2-6i");
+MODULE_PARM(js_console3,"2-6i");
+
+
+#define JS_NO_PAD	0
+#define JS_SNES_PAD	1
+#define JS_NES_PAD	2
+#define JS_NES4_PAD	3
+#define JS_MULTI_STICK	4
+#define JS_MULTI2_STICK	5
+#define JS_PSX_PAD	6
+
+#define JS_MAX_PAD	JS_PSX_PAD
+
+struct js_console_info {
+#ifdef USE_PARPORT
+	struct pardevice *port;	/* parport device */
+#else
+	int port;		/* hw port */
+#endif
+	int pads;		/* total number of pads */
+	int snes;		/* SNES pads */
+	int nes;		/* NES pads */
+	int multi;		/* Multi joysticks */
+	int multi2;		/* Multi joysticks with 2 buttons */
+	int psx;		/* Normal PSX controllers */
+	int negcon;		/* PSX NEGCON controllers */
+};
+
+static struct js_port* js_console_port = NULL;
+
+static int js_console[] __initdata = { -1, 0, 0, 0, 0, 0 };
+static int js_console2[] __initdata = { -1, 0, 0, 0, 0, 0 };
+static int js_console3[] __initdata = { -1, 0, 0, 0, 0, 0 };
+
+static int status_bit[] = { 0x40, 0x80, 0x20, 0x10, 0x08 };
+
+/*
+ * NES/SNES support.
+ */
+
+#define JS_NES_DELAY	6	/* Delay between bits - 6us */
+
+#define JS_NES_LENGTH	8	/* The NES pads use 8 bits of data */
+
+#define JS_NES_A	0
+#define JS_NES_B	1
+#define JS_NES_START	2
+#define JS_NES_SELECT	3
+#define JS_NES_UP	4
+#define JS_NES_DOWN	5
+#define JS_NES_LEFT	6
+#define JS_NES_RIGHT	7
+
+#define JS_SNES_LENGTH	12	/* The SNES true length is 16, but the last 4 bits are unused */
+
+#define JS_SNES_B	0
+#define JS_SNES_Y	1
+#define JS_SNES_START	2
+#define JS_SNES_SELECT	3
+#define JS_SNES_UP	4
+#define JS_SNES_DOWN	5
+#define JS_SNES_LEFT	6
+#define JS_SNES_RIGHT	7
+#define JS_SNES_A	8
+#define JS_SNES_X	9
+#define JS_SNES_L	10
+#define JS_SNES_R	11
+
+#define JS_NES_POWER	0xf8
+#define JS_NES_CLOCK	0x01
+#define JS_NES_LATCH	0x02
+
+/*
+ * js_nes_read_packet() reads a NES/SNES packet.
+ * Each pad uses one bit per byte. So all pads connected to
+ * this port are read in parallel.
+ */
+
+static void js_nes_read_packet(struct js_console_info *info, int length, unsigned char *data)
+{
+	int i;
+
+	JS_PAR_DATA_OUT(JS_NES_POWER | JS_NES_CLOCK | JS_NES_LATCH, info->port);
+	udelay(JS_NES_DELAY * 2);
+	JS_PAR_DATA_OUT(JS_NES_POWER | JS_NES_CLOCK, info->port);
+
+	for (i = 0; i < length; i++) {
+		udelay(JS_NES_DELAY);
+		JS_PAR_DATA_OUT(JS_NES_POWER, info->port);
+		data[i] = JS_PAR_STATUS(info->port) ^ ~JS_PAR_STATUS_INVERT;
+		udelay(JS_NES_DELAY);
+		JS_PAR_DATA_OUT(JS_NES_POWER | JS_NES_CLOCK, info->port);
+	}
+}
+
+/*
+ * Multisystem joystick support
+ */
+
+#define JS_MULTI_LENGTH		5	/* Multi system joystick packet lenght is 5 */
+#define JS_MULTI2_LENGTH	6	/* One more bit for one more button */
+
+#define JS_MULTI_UP		0
+#define JS_MULTI_DOWN		1
+#define JS_MULTI_LEFT		2
+#define JS_MULTI_RIGHT		3
+#define JS_MULTI_BUTTON		4
+#define JS_MULTI_BUTTON2	5
+
+/*
+ * js_multi_read_packet() reads a Multisystem joystick packet.
+ */
+
+static void js_multi_read_packet(struct js_console_info *info, int length, unsigned char *data)
+{
+	int i;
+
+	for (i = 0; i < length; i++) {
+		JS_PAR_DATA_OUT(~(1 << i), info->port);
+		data[i] = JS_PAR_STATUS(info->port) ^ ~JS_PAR_STATUS_INVERT;
+	}
+}
+
+/*
+ * PSX support
+ */
+
+#define JS_PSX_DELAY	15
+
+#define JS_PSX_LENGTH	8
+
+#define JS_PSX_NORMAL	0x41
+#define JS_PSX_NEGCON	0x23
+#define JS_PSX_MOUSE	0x12
+
+#define JS_PSX_SELBUT	0x01
+#define JS_PSX_START	0x08
+#define JS_PSX_UP	0x10
+#define JS_PSX_RIGHT	0x20
+#define JS_PSX_DOWN	0x40
+#define JS_PSX_LEFT	0x80
+
+#define JS_PSX_CLOCK	0x01
+#define JS_PSX_COMMAND	0x02
+#define JS_PSX_POWER	0xf8
+#define JS_PSX_NOPOWER	0x04
+#define JS_PSX_SELECT	0x08
+
+#define JS_PSX_CTRL_OUT(X,Y)	JS_PAR_CTRL_OUT((X)^0x0f, Y)
+
+/*
+ * js_psx_command() writes 8bit command and reads 8bit data from
+ * the psx pad.
+ */
+
+static int js_psx_command(struct js_console_info *info, int b)
+{
+	int i, cmd, ret=0;
+
+	cmd = (b&1)?JS_PSX_COMMAND:0;
+	for (i=0; i<8; i++) {
+		JS_PSX_CTRL_OUT(cmd, info->port);
+		udelay(JS_PSX_DELAY);
+		ret |= ((JS_PAR_STATUS(info->port) ^ JS_PAR_STATUS_INVERT ) & info->psx) ? (1<<i) : 0;
+		cmd = (b&1)?JS_PSX_COMMAND:0;
+		JS_PSX_CTRL_OUT(JS_PSX_CLOCK | cmd, info->port);
+		udelay(JS_PSX_DELAY);
+		b >>= 1;
+	}
+	return ret;
+}
+
+/*
+ * js_psx_read_packet() reads a whole psx packet and returns
+ * device identifier code.
+ */
+
+static int js_psx_read_packet(struct js_console_info *info, int length, unsigned char *data)
+{
+	int i, ret;
+	unsigned long flags;
+
+	__save_flags(flags);
+	__cli();
+
+	JS_PAR_DATA_OUT(JS_PSX_POWER, info->port);
+
+	JS_PSX_CTRL_OUT(JS_PSX_CLOCK | JS_PSX_SELECT, info->port);	/* Select pad */
+	udelay(JS_PSX_DELAY*2);
+	js_psx_command(info, 0x01);					/* Access pad */
+	ret = js_psx_command(info, 0x42);				/* Get device id */
+	if (js_psx_command(info, 0)=='Z')				/* okay? */
+		for (i=0; i<length; i++)
+			data[i]=js_psx_command(info, 0);
+	else ret = -1;
+
+	JS_PSX_CTRL_OUT(JS_PSX_SELECT | JS_PSX_CLOCK, info->port);
+	__restore_flags(flags);
+
+	return ret;
+}
+
+
+/*
+ * js_console_read() reads and analyzes console pads data.
+ */
+
+#define JS_MAX_LENGTH JS_SNES_LENGTH
+
+static int js_console_read(void *xinfo, int **axes, int **buttons)
+{
+	struct js_console_info *info = xinfo;
+	unsigned char data[JS_MAX_LENGTH];
+
+	int i, s;
+	int n = 0;
+
+/*
+ * NES and SNES pads
+ */
+
+	if (info->nes || info->snes) {
+
+		js_nes_read_packet(info, info->snes ? JS_SNES_LENGTH : JS_NES_LENGTH, data);
+
+		for (i = 0; i < 5; i++) {
+			s = status_bit[i];
+			if (info->nes & s) {
+				axes[n][0] = (data[JS_SNES_RIGHT]&s?1:0) - (data[JS_SNES_LEFT]&s?1:0);
+				axes[n][1] = (data[JS_SNES_DOWN] &s?1:0) - (data[JS_SNES_UP]  &s?1:0);
+
+				buttons[n][0] = ((data[JS_NES_A]    &s)?1:0) | ((data[JS_NES_B]     &s)?2:0)
+					      | ((data[JS_NES_START]&s)?4:0) | ((data[JS_NES_SELECT]&s)?8:0);
+
+				n++;
+			} else
+			if (info->snes & s) {
+				axes[n][0] = (data[JS_SNES_RIGHT]&s?1:0) - (data[JS_SNES_LEFT]&s?1:0);
+				axes[n][1] = (data[JS_SNES_DOWN] &s?1:0) - (data[JS_SNES_UP]  &s?1:0);
+
+				buttons[n][0] = ((data[JS_SNES_A]    &s)?0x01:0) | ((data[JS_SNES_B]     &s)?0x02:0)
+					      | ((data[JS_SNES_X]    &s)?0x04:0) | ((data[JS_SNES_Y]     &s)?0x08:0)
+					      | ((data[JS_SNES_L]    &s)?0x10:0) | ((data[JS_SNES_R]     &s)?0x20:0)
+					      | ((data[JS_SNES_START]&s)?0x40:0) | ((data[JS_SNES_SELECT]&s)?0x80:0);
+				n++;
+			}
+		}
+	}
+
+/*
+ * Multi and Multi2 joysticks
+ */
+
+	if (info->multi || info->multi2) {
+
+		js_multi_read_packet(info, info->multi2 ? JS_MULTI2_LENGTH : JS_MULTI_LENGTH, data);
+
+		for (i = 0; i < 5; i++) {
+			s = status_bit[i];
+			if (info->multi & s) {
+				axes[n][0] = (data[JS_MULTI_RIGHT]&s?1:0) - (data[JS_MULTI_LEFT]&s?1:0);
+				axes[n][1] = (data[JS_MULTI_DOWN] &s?1:0) - (data[JS_MULTI_UP]  &s?1:0);
+
+				buttons[n][0] = (data[JS_MULTI_BUTTON]&s)?1:0;
+
+				n++;
+			} else
+			if (info->multi2 & s) {
+				axes[n][0] = (data[JS_MULTI_RIGHT]&s?1:0) - (data[JS_MULTI_LEFT]&s?1:0);
+				axes[n][1] = (data[JS_MULTI_DOWN] &s?1:0) - (data[JS_MULTI_UP]  &s?1:0);
+
+				buttons[n][0] = (data[JS_MULTI_BUTTON]&s)?1:0 | (data[JS_MULTI_BUTTON2]&s)?2:0;
+
+				n++;
+			}
+		}
+	}
+
+/*
+ * PSX controllers
+ */
+
+	if (info->psx && (js_psx_read_packet(info, 2, data) == JS_PSX_NORMAL)) {	/* FIXME? >1 PSX pads? */
+
+		axes[n][0] = (data[0]&JS_PSX_RIGHT?0:1) - (data[0]&JS_PSX_LEFT?0:1);
+		axes[n][1] = (data[0]&JS_PSX_DOWN ?0:1) - (data[0]&JS_PSX_UP  ?0:1);
+
+		buttons[n][0] = ((~data[1]&0xf)<<4) | ((~data[1]&0xf0)>>4) |
+				(data[0]&JS_PSX_START?0:0x200) | (data[0]&JS_PSX_SELBUT?0:0x100);
+
+		n++;
+	}
+
+	return -(n != info->pads);
+}
+
+/*
+ * open callback: claim parport.
+ */
+
+int js_console_open(struct js_dev *dev)
+{
+#ifdef USE_PARPORT
+	struct js_console_info *info = dev->port->info;
+	if (!MOD_IN_USE && parport_claim(info->port)) return -EBUSY;
+#endif
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * close callback: release parport
+ */
+
+int js_console_close(struct js_dev *dev)
+{
+#ifdef USE_PARPORT
+	struct js_console_info *info = dev->port->info;
+#endif
+	MOD_DEC_USE_COUNT;
+#ifdef USE_PARPORT
+	if (!MOD_IN_USE) parport_release(info->port);
+#endif
+	return 0;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	struct js_console_info *info;
+	int i;
+
+	while (js_console_port) {
+		for (i = 0; i < js_console_port->ndevs; i++)
+			if (js_console_port->devs[i])
+				js_unregister_device(js_console_port->devs[i]);
+		info = js_console_port->info;
+#ifdef USE_PARPORT
+		parport_unregister_device(info->port);
+#else
+		release_region(info->port, 3);
+#endif
+		js_console_port = js_unregister_port(js_console_port);
+	}
+}
+#endif
+
+/*
+ * js_console_init_corr() initializes correction values of
+ * console gamepads.
+ */
+
+static void __init js_console_init_corr(int num_axes, struct js_corr *corr)
+{
+	int i;
+
+	for (i = 0; i < num_axes; i++) {
+		corr[i].type = JS_CORR_BROKEN;
+		corr[i].prec = 0;
+		corr[i].coef[0] = 0;
+		corr[i].coef[1] = 0;
+		corr[i].coef[2] = (1 << 29);
+		corr[i].coef[3] = (1 << 29);
+	}
+}
+
+/*
+ * js_console_probe() probes for console gamepads.
+ * Only PSX pads can really be probed for.
+ */
+
+static struct js_port __init *js_console_probe(int *config, struct js_port *port)
+{
+	char *name[5];
+	int i, psx, axes[5], buttons[5];
+	unsigned char data[2];			/* used for PSX probe */
+	struct js_console_info info;
+
+	memset(&info, 0, sizeof(struct js_console_info));
+
+	if (config[0] < 0) return port;
+
+#ifdef USE_PARPORT
+	{
+		struct parport *pp;
+
+		if (config[0] > 0x10)
+			for (pp=parport_enumerate(); pp && (pp->base!=config[0]); pp=pp->next);
+		else
+			for (pp=parport_enumerate(); pp && (config[0]>0); pp=pp->next) config[0]--;
+
+		if (!pp) {
+			printk(KERN_ERR "joy-console: no such parport\n");
+			return port;
+		}
+
+		info.port = parport_register_device(pp, "joystick (console)", NULL, NULL, NULL, PARPORT_DEV_EXCL, NULL);
+		if (!info.port)
+			return port;
+	}
+
+	if (parport_claim(info.port))
+	{
+		parport_unregister_device(info.port);	/* port currently not available ... */
+		return port;
+	}
+#else
+	info.port = config[0];
+	if (check_region(info.port, 3)) return port;
+	request_region(info.port, 3, "joystick (console pad)");
+#endif
+
+	for (i = 0; i < 5; i++)
+		switch(config[i+1]) {
+
+			case JS_NO_PAD:
+
+				break;
+
+			case JS_SNES_PAD:
+
+				axes[info.pads]    = 2;
+				buttons[info.pads] = 8;
+				name[info.pads]    = "SNES pad";
+				info.snes |= status_bit[i];
+				info.pads++;
+				break;
+
+			case JS_NES_PAD:
+
+				axes[info.pads]    = 2;
+				buttons[info.pads] = 4;
+				name[info.pads]    = "NES pad";
+				info.nes |= status_bit[i];
+				info.pads++;
+				break;
+
+			case JS_MULTI_STICK:
+
+				axes[info.pads]    = 2;
+				buttons[info.pads] = 1;
+				name[info.pads]    = "Multisystem joystick";
+				info.multi |= status_bit[i];
+				info.pads++;
+				break;
+
+			case JS_MULTI2_STICK:
+
+				axes[info.pads]    = 2;
+				buttons[info.pads] = 2;
+				name[info.pads]    = "Multisystem joystick (2 fire)";
+				info.multi |= status_bit[i];
+				info.pads++;
+				break;
+
+			case JS_PSX_PAD:
+
+				info.psx |= status_bit[i];
+				psx = js_psx_read_packet(&info, 2, data);
+				psx = js_psx_read_packet(&info, 2, data);
+				info.psx &= ~status_bit[i];
+
+				switch(psx) {
+					case JS_PSX_NORMAL:
+						axes[info.pads]    = 2;
+						buttons[info.pads] = 10;
+						name[info.pads]    = "PSX controller";
+						info.psx |= status_bit[i];
+						info.pads++;
+						break;
+					case JS_PSX_NEGCON:
+						printk(KERN_WARNING "joy-console: NegCon not yet supported...\n");
+						break;
+					case JS_PSX_MOUSE:
+						printk(KERN_WARNING "joy-console: PSX mouse not supported...\n");
+						break;
+					case -1:
+						printk(KERN_ERR "joy-console: no PSX controller found...\n");
+						break;
+					default:
+						printk(KERN_WARNING "joy-console: unknown PSX controller 0x%x\n", psx);
+				}
+				break;
+
+			default:
+
+				printk(KERN_WARNING "joy-console: pad type %d unknown\n", config[i+1]);
+		}
+
+	if (!info.pads) {
+#ifdef USE_PARPORT
+		parport_release(info.port);
+		parport_unregister_device(info.port);
+#else
+		release_region(info.port, 3);
+#endif
+		return port;
+	}
+
+	port = js_register_port(port, &info, info.pads, sizeof(struct js_console_info), js_console_read);
+
+	for (i = 0; i < info.pads; i++) {
+#ifdef USE_PARPORT
+		printk(KERN_INFO "js%d: %s on %s\n",
+			js_register_device(port, i, axes[i], buttons[i], name[i], js_console_open, js_console_close),
+			name[i], info.port->port->name);
+#else
+		printk(KERN_INFO "js%d: %s at %#x\n",
+			js_register_device(port, i, axes[i], buttons[i], name[i], js_console_open, js_console_close),
+			name[i], info.port);
+#endif
+
+		js_console_init_corr(axes[i], port->corr[i]);
+	}
+
+#ifdef USE_PARPORT
+	parport_release(info.port);
+#endif
+	return port;
+}
+
+#ifndef MODULE
+void __init js_console_setup(char *str, int *ints)
+{
+	int i;
+
+	if (!strcmp(str,"js_console"))
+		for (i = 0; i <= ints[0] && i < 6; i++) js_console[i] = ints[i+1];
+	if (!strcmp(str,"js_console2"))
+		for (i = 0; i <= ints[0] && i < 6; i++) js_console2[i] = ints[i+1];
+	if (!strcmp(str,"js_console3"))
+		for (i = 0; i <= ints[0] && i < 6; i++) js_console3[i] = ints[i+1];
+
+}
+#endif
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_console_init(void)
+#endif
+{
+	js_console_port = js_console_probe(js_console, js_console_port);
+	js_console_port = js_console_probe(js_console2, js_console_port);
+	js_console_port = js_console_probe(js_console3, js_console_port);
+
+	if (js_console_port) return 0;
+
+#ifdef MODULE
+	printk(KERN_WARNING "joy-console: no joysticks specified\n");
+#endif
+	return -ENODEV;
+}
diff -urN linux-2.0.36/drivers/char/joystick/joy-creative.c linux-2.0.36-joystick/drivers/char/joystick/joy-creative.c
--- linux-2.0.36/drivers/char/joystick/joy-creative.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-creative.c	Mon Mar  8 15:40:50 1999
@@ -0,0 +1,282 @@
+/*
+ *  joy-creative.c  Version 1.2
+ *
+ *  Copyright (c) 1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * Creative Labs Blaster gamepad family.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+
+#define JS_CR_MAX_STROBE	45
+#define JS_CR_LENGTH		36
+
+#define JS_CR_MODE_BGPC		8
+
+static int js_cr_port_list[] __initdata = {0x201, 0};
+static struct js_port* js_cr_port __initdata = NULL;
+
+struct js_cr_info {
+	int io;
+	unsigned char mode[2];
+};
+
+/*
+ * js_cr_read_packet() reads a Blaster gamepad packet.
+ */
+
+static int js_cr_read_packet(int io, unsigned int *data)
+{
+	unsigned long flags;
+	unsigned char u, v, w;
+	__u64 buf[2];
+	int r[2], t[2];
+	int i, j, ret;
+
+	int strobe = (js_io_speed * JS_CR_MAX_STROBE) >> 10;
+	i = r[0] = r[1] = buf[0] = buf[1] = 0;
+	t[0] = t[1] = strobe;
+	
+	__save_flags(flags);
+	__cli();
+
+	u = inb(io);
+
+	do {
+		t[0]--; t[1]--;
+		v = inb(io);
+		for (i = 0, w = u ^ v; i < 2 && w; i++, w >>= 2)
+			if (w & 0x30) {
+				if ((w & 0x30) < 0x30 && r[i] < JS_CR_LENGTH && t[i] > 0) {
+					buf[i] |= (__u64)((w >> 5) & 1) << r[i]++;
+					t[i] = strobe;
+					u = v;
+				} else t[i] = 0;
+			}
+	} while (t[0] > 0 || t[1] > 0);
+
+	__restore_flags(flags);
+
+
+	ret = 0;
+
+	for (i = 0; i < 2; i++) {
+
+		if (r[i] != JS_CR_LENGTH) continue;
+
+		for (j = 0; j < JS_CR_LENGTH && (buf[i] & 0x04104107f) ^ 0x041041040; j++)
+			buf[i] = (buf[i] >> 1) | ((__u64)(buf[i] & 1) << (JS_CR_LENGTH - 1));
+
+		if (j < JS_CR_LENGTH) ret |= (1 << i);
+
+		data[i] = ((buf[i] >>  7) & 0x000001f) | ((buf[i] >>  8) & 0x00003e0)
+			| ((buf[i] >>  9) & 0x0007c00) | ((buf[i] >> 10) & 0x00f8000)
+			| ((buf[i] >> 11) & 0x1f00000);
+
+	}
+
+	return ret;
+}
+
+/*
+ * js_cr_read() reads and analyzes Blaster gamepad data.
+ */
+
+static int js_cr_read(void *xinfo, int **axes, int **buttons)
+{
+	struct js_cr_info *info = xinfo;
+	unsigned int data[2];
+	int i, r;
+
+	if (!(r = js_cr_read_packet(info->io, data)))
+		return -1;
+
+	for (i = 0; i < 2; i++)
+		if (r & (1 << i)) {
+			switch (info->mode[i]) {
+
+				case JS_CR_MODE_BGPC:
+
+					axes[i][0] = ((data[i] >> 4) & 1) - ((data[i] >> 3) & 1);
+					axes[i][1] = ((data[i] >> 2) & 1) - ((data[i] >> 1) & 1);
+
+					buttons[i][0] = ((data[i] >> 12) & 0x007) | ((data[i] >> 6) & 0x038)
+						      | ((data[i] >>  1) & 0x0c0) | ((data[i] >> 7) & 0x300)
+						      | ((data[i] <<  5) & 0xc00);
+
+					break;
+
+				default:
+					break;
+
+			}
+		}
+
+	return 0;
+}
+
+/*
+ * js_cr_open() is a callback from the file open routine.
+ */
+
+static int js_cr_open(struct js_dev *jd)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_cr_close() is a callback from the file release routine.
+ */
+
+static int js_cr_close(struct js_dev *jd)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_cr_init_corr() initializes correction values of
+ * Blaster gamepads.
+ */
+
+static void __init js_cr_init_corr(int mode, struct js_corr *corr)
+{
+	int i;
+
+	switch (mode) {
+
+		case JS_CR_MODE_BGPC:
+
+			for (i = 0; i < 2; i++) {
+				corr[i].type = JS_CORR_BROKEN;
+				corr[i].prec = 0;
+				corr[i].coef[0] = 0;
+				corr[i].coef[1] = 0;
+				corr[i].coef[2] = (1 << 29);
+				corr[i].coef[3] = (1 << 29);
+			}
+
+			break;
+
+	}
+}
+
+/*
+ * js_cr_probe() probes for Blaster gamepads.
+ */
+
+static struct js_port __init *js_cr_probe(int io, struct js_port *port)
+{
+	struct js_cr_info info;
+	char *names[] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, "Blaster GamePad Cobra" };
+	char axes[] = { 0, 0, 0, 0, 0, 0, 0, 0, 2 };
+	char buttons[] = { 0, 0, 0, 0, 0, 0, 0, 0, 12 };
+	unsigned int data[2];
+	int i, r;
+
+	if (check_region(io, 1)) return port;
+
+	info.mode[0] = info.mode[1] = 0;
+
+	if (!(r = js_cr_read_packet(io, data)))
+		return port;
+
+	for (i = 0; i < 2; i++) {
+		if (r & (1 << i)) {
+			if (~data[i] & 1) {
+				info.mode[i] = JS_CR_MODE_BGPC;
+			} else {
+				info.mode[i] = (data[i] >> 2) & 7;
+			}
+			if (!names[info.mode[i]]) {
+				printk(KERN_WARNING "joy-creative: Unknown Creative device %d at %#x\n",
+					info.mode[i], io);
+				info.mode[i] = 0;
+			}
+		}
+	}
+
+	if (!info.mode[0] && !info.mode[1]) return port;
+
+	info.io = io;
+
+	request_region(io, 1, "joystick (creative)");
+	port = js_register_port(port, &info, 2, sizeof(struct js_cr_info), js_cr_read);
+
+	for (i = 0; i < 2; i++)
+		if (info.mode[i]) {
+			printk(KERN_INFO "js%d: %s at %#x\n",
+				js_register_device(port, i, axes[info.mode[i]], buttons[info.mode[i]],
+					names[info.mode[i]], js_cr_open, js_cr_close),
+				names[info.mode[i]], io);
+			js_cr_init_corr(info.mode[i], port->corr[i]);
+		}
+
+	return port;
+}
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_cr_init(void)
+#endif
+{
+	int *p;
+
+	for (p = js_cr_port_list; *p; p++) js_cr_port = js_cr_probe(*p, js_cr_port);
+	if (js_cr_port) return 0;
+
+#ifdef MODULE
+	printk(KERN_WARNING "joy-creative: no joysticks found\n");
+#endif
+
+	return -ENODEV;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	int i;
+	struct js_cr_info *info;
+
+	while (js_cr_port) {
+		for (i = 0; i < js_cr_port->ndevs; i++)
+			if (js_cr_port->devs[i])
+				js_unregister_device(js_cr_port->devs[i]);
+		info = js_cr_port->info;
+		release_region(info->io, 1);
+		js_cr_port = js_unregister_port(js_cr_port);
+	}
+}
+#endif
diff -urN linux-2.0.36/drivers/char/joystick/joy-db9.c linux-2.0.36-joystick/drivers/char/joystick/joy-db9.c
--- linux-2.0.36/drivers/char/joystick/joy-db9.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-db9.c	Mon Mar  8 15:41:10 1999
@@ -0,0 +1,407 @@
+/*
+ *  joy-db9.c  Version 0.6V
+ *
+ *  Copyright (c) 1998 Andree Borrmann
+ *  Copyright (c) 1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * console (Atari, Amstrad, Commodore, Amiga, Sega) joysticks
+ * and gamepads connected to the parallel port.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+
+MODULE_AUTHOR("Andree Borrmann <A.Borrmann@tu-bs.de>");
+MODULE_PARM(js_db9, "2i");
+MODULE_PARM(js_db9_2, "2i");
+MODULE_PARM(js_db9_3, "2i");
+
+#define JS_MULTI_STICK	0x01
+#define JS_MULTI2_STICK 0x02
+#define JS_GENESIS_PAD  0x03
+#define JS_GENESIS5_PAD 0x05
+#define JS_GENESIS6_PAD	0x06
+#define JS_SATURN_PAD	0x07
+#define JS_MULTI_0802	0x08
+#define JS_MAX_PAD	0x09
+
+#define JS_DB9_UP	0x01
+#define JS_DB9_DOWN	0x02
+#define JS_DB9_LEFT	0x04
+#define JS_DB9_RIGHT	0x08
+#define JS_DB9_FIRE1	0x10
+#define JS_DB9_FIRE2	0x20
+#define JS_DB9_FIRE3	0x40
+#define JS_DB9_FIRE4	0x80
+
+#define JS_DB9_NORMAL	0x22
+#define JS_DB9_NOSELECT	0x20
+
+#define JS_DB9_SATURN0	0x20
+#define JS_DB9_SATURN1	0x22
+#define JS_DB9_SATURN2	0x24
+#define JS_DB9_SATURN3	0x26
+
+#define JS_GENESIS6_DELAY	14
+
+static struct js_port* js_db9_port = NULL;
+
+static int js_db9[] __initdata = { -1, 0 };
+static int js_db9_2[] __initdata = { -1, 0 };
+static int js_db9_3[] __initdata = { -1, 0 };
+
+struct js_db9_info {
+#ifdef USE_PARPORT
+	struct pardevice *port;	/* parport device */
+#else
+	int port;		/* hw port */
+#endif
+	int mode;		/* pad mode */
+};
+
+/*
+ * js_db9_read() reads and analyzes db9 joystick data.
+ */
+
+static int js_db9_read(void *xinfo, int **axes, int **buttons)
+{
+	struct js_db9_info *info = xinfo;
+	int data;
+
+	switch(info->mode)
+	{
+	  case JS_MULTI_0802:
+
+		data = JS_PAR_STATUS(info->port) >> 3;
+
+		axes[0][1] = (data&JS_DB9_DOWN ?0:1) - (data&JS_DB9_UP  ?0:1);
+		axes[0][0] = (data&JS_DB9_RIGHT?0:1) - (data&JS_DB9_LEFT?0:1);
+
+		buttons[0][0] = (data&JS_DB9_FIRE1?1:0);
+
+		break;
+
+	  case JS_MULTI_STICK:
+
+		data = JS_PAR_DATA_IN(info->port);
+
+		axes[0][1] = (data&JS_DB9_DOWN ?0:1) - (data&JS_DB9_UP  ?0:1);
+		axes[0][0] = (data&JS_DB9_RIGHT?0:1) - (data&JS_DB9_LEFT?0:1);
+
+		buttons[0][0] = (data&JS_DB9_FIRE1?0:1);
+
+		break;
+
+	  case JS_MULTI2_STICK:
+
+		data=JS_PAR_DATA_IN(info->port);
+
+		axes[0][1] = (data&JS_DB9_DOWN ?0:1) - (data&JS_DB9_UP  ?0:1);
+		axes[0][0] = (data&JS_DB9_RIGHT?0:1) - (data&JS_DB9_LEFT?0:1);
+
+		buttons[0][0] = (data&JS_DB9_FIRE1?0:1) | (data&JS_DB9_FIRE2?0:2);
+
+		break;
+
+	  case JS_GENESIS_PAD:
+
+		JS_PAR_CTRL_OUT(JS_DB9_NOSELECT, info->port);
+		data = JS_PAR_DATA_IN(info->port);
+
+		axes[0][1] = (data&JS_DB9_DOWN ?0:1) - (data&JS_DB9_UP  ?0:1);
+		axes[0][0] = (data&JS_DB9_RIGHT?0:1) - (data&JS_DB9_LEFT?0:1);
+
+		buttons[0][0] = (data&JS_DB9_FIRE1?0:2) | (data&JS_DB9_FIRE2?0:4);
+
+		JS_PAR_CTRL_OUT(JS_DB9_NORMAL,info->port);
+		data=JS_PAR_DATA_IN(info->port);
+
+		buttons[0][0] |= (data&JS_DB9_FIRE1?0:1) | (data&JS_DB9_FIRE2?0:8);
+
+		break;
+
+	  case JS_GENESIS5_PAD:
+
+		JS_PAR_CTRL_OUT(JS_DB9_NOSELECT,info->port);
+		data=JS_PAR_DATA_IN(info->port);
+
+		axes[0][1] = (data&JS_DB9_DOWN ?0:1) - (data&JS_DB9_UP  ?0:1);
+		axes[0][0] = (data&JS_DB9_RIGHT?0:1) - (data&JS_DB9_LEFT?0:1);
+
+		buttons[0][0] = (data&JS_DB9_FIRE1?0:0x02) | (data&JS_DB9_FIRE2?0:0x04);
+
+		JS_PAR_CTRL_OUT(JS_DB9_NORMAL, info->port);
+		data=JS_PAR_DATA_IN(info->port);
+
+		buttons[0][0] |= (data&JS_DB9_FIRE1?0:0x01) | (data&JS_DB9_FIRE2?0:0x08) |
+				 (data&JS_DB9_LEFT ?0:0x10) | (data&JS_DB9_RIGHT?0:0x20);
+		break;
+
+	  case JS_GENESIS6_PAD:
+
+		JS_PAR_CTRL_OUT(JS_DB9_NOSELECT,info->port); /* 1 */
+		udelay(JS_GENESIS6_DELAY);
+		data=JS_PAR_DATA_IN(info->port);
+
+		axes[0][1] = (data&JS_DB9_DOWN ?0:1) - (data&JS_DB9_UP  ?0:1);
+		axes[0][0] = (data&JS_DB9_RIGHT?0:1) - (data&JS_DB9_LEFT?0:1);
+
+		buttons[0][0] = (data&JS_DB9_FIRE1?0:0x02) | (data&JS_DB9_FIRE2?0:0x04);
+
+		JS_PAR_CTRL_OUT(JS_DB9_NORMAL, info->port);
+		udelay(JS_GENESIS6_DELAY);
+		data=JS_PAR_DATA_IN(info->port);
+
+		buttons[0][0] |= (data&JS_DB9_FIRE1?0:0x01) | (data&JS_DB9_FIRE2?0:0x08);
+
+		JS_PAR_CTRL_OUT(JS_DB9_NOSELECT, info->port); /* 2 */
+		udelay(JS_GENESIS6_DELAY);
+		JS_PAR_CTRL_OUT(JS_DB9_NORMAL, info->port);
+		udelay(JS_GENESIS6_DELAY);
+		JS_PAR_CTRL_OUT(JS_DB9_NOSELECT, info->port); /* 3 */
+		udelay(JS_GENESIS6_DELAY);
+		JS_PAR_CTRL_OUT(JS_DB9_NORMAL, info->port);
+		udelay(JS_GENESIS6_DELAY);
+		data=JS_PAR_DATA_IN(info->port);
+
+		buttons[0][0] |= (data&JS_DB9_LEFT?0:0x10) | (data&JS_DB9_DOWN?0:0x20) | (data&JS_DB9_UP?0:0x40);
+
+		JS_PAR_CTRL_OUT(JS_DB9_NOSELECT, info->port); /* 4 */
+		udelay(JS_GENESIS6_DELAY);
+		JS_PAR_CTRL_OUT(JS_DB9_NORMAL, info->port);
+
+		break;
+
+	  case JS_SATURN_PAD:
+
+		JS_PAR_CTRL_OUT(JS_DB9_SATURN0, info->port);
+		data = JS_PAR_DATA_IN(info->port);
+
+		buttons[0][0] = (data&JS_DB9_UP  ?0:0x20) | (data&JS_DB9_DOWN ?0:0x10) |
+				(data&JS_DB9_LEFT?0:0x08) | (data&JS_DB9_RIGHT?0:0x40);
+
+		JS_PAR_CTRL_OUT(JS_DB9_SATURN2, info->port);
+		data = JS_PAR_DATA_IN(info->port);
+
+		axes[0][1] = (data&JS_DB9_DOWN ?0:1) - (data&JS_DB9_UP  ?0:1);
+		axes[0][0] = (data&JS_DB9_RIGHT?0:1) - (data&JS_DB9_LEFT?0:1);
+
+		JS_PAR_CTRL_OUT(JS_DB9_NORMAL, info->port);
+		data = JS_PAR_DATA_IN(info->port);
+
+		buttons[0][0] |= (data&JS_DB9_UP  ?0:0x02) | (data&JS_DB9_DOWN ?0:0x04) |
+				 (data&JS_DB9_LEFT?0:0x01) | (data&JS_DB9_RIGHT?0:0x80);
+
+
+		break;
+
+	  default:
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * open callback: claim parport.
+ */
+
+int js_db9_open(struct js_dev *dev)
+{
+	struct js_db9_info *info = dev->port->info;
+
+	if (!MOD_IN_USE) {
+#ifdef USE_PARPORT
+		if (parport_claim(info->port)) return -EBUSY;
+#endif
+
+		JS_PAR_ECTRL_OUT(0x35,info->port);		/* enable PS/2 mode: */
+		JS_PAR_CTRL_OUT(JS_DB9_NORMAL,info->port);	/* reverse direction, enable Select signal */
+	}
+		
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * close callback: release parport
+ */
+
+int js_db9_close(struct js_dev *dev)
+{
+	struct js_db9_info *info = dev->port->info;
+
+	MOD_DEC_USE_COUNT;
+
+	if (!MOD_IN_USE) {
+
+		JS_PAR_CTRL_OUT(0x00,info->port);	/* normal direction */
+		JS_PAR_ECTRL_OUT(0x15,info->port);	/* enable normal mode */
+
+#ifdef USE_PARPORT
+		parport_release(info->port);
+#endif
+	}
+	return 0;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	struct js_db9_info *info;
+
+	while (js_db9_port) {
+		js_unregister_device(js_db9_port->devs[0]);
+		info = js_db9_port->info;
+#ifdef USE_PARPORT
+		parport_unregister_device(info->port);
+#else
+		release_region(info->port, 3);
+		release_region(info->port+0x402, 1);
+#endif
+		js_db9_port = js_unregister_port(js_db9_port);
+	}
+
+}
+#endif
+
+/*
+ * js_db9_init_corr() initializes correction values of
+ * db9 gamepads.
+ */
+
+static void __init js_db9_init_corr(struct js_corr **corr)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		corr[0][i].type = JS_CORR_BROKEN;
+		corr[0][i].prec = 0;
+		corr[0][i].coef[0] = 0;
+		corr[0][i].coef[1] = 0;
+		corr[0][i].coef[2] = (1 << 29);
+		corr[0][i].coef[3] = (1 << 29);
+	}
+}
+
+/*
+ * js_db9_probe() probes for db9 gamepads.
+ */
+
+static struct js_port __init *js_db9_probe(int *config, struct js_port *port)
+{
+	struct js_db9_info info;
+	char buttons[JS_MAX_PAD] = {0,1,2,4,0,6,7,8,1};
+	char *name[JS_MAX_PAD] = {NULL, "Multisystem joystick", "Multisystem joystick (2 fire)", "Genesis pad",
+					NULL, "Genesis 5 pad", "Genesis 6 pad", "Saturn pad", "Multisystem (0.8.0.2) joystick"};
+
+	if (config[0] < 0) return port;
+	if (config[1] < 0 || config[1] >= JS_MAX_PAD || !name[config[1]]) return port;
+
+#ifdef USE_PARPORT
+	{
+		struct parport *pp;
+
+		if (config[0] > 0x10)
+			for (pp=parport_enumerate(); pp && (pp->base!=config[0]); pp=pp->next);
+		else
+			for (pp=parport_enumerate(); pp && (config[0]>0); pp=pp->next) config[0]--;
+
+		if (pp) {
+			printk(KERN_ERR "joy-db9: no such parport\n");
+			return port;
+		}
+
+		if (!(pp->modes & (PARPORT_MODE_PCPS2 | PARPORT_MODE_PCECPPS2))) {
+			printk(KERN_ERR "js-db9: specified parport is not bidirectional\n");
+			return port;
+		}
+
+		info.port = parport_register_device(pp, "joystick (db9)", NULL, NULL, NULL, PARPORT_DEV_EXCL, NULL);
+		if (!info.port)
+			return port;
+	}
+#else
+	info.port = config[0];
+	if (check_region(info.port, 3) || check_region(info.port+0x402,1)) return port;
+	request_region(info.port, 3, "joystick (db9)");
+	request_region(info.port+0x402, 1, "joystick (db9)");
+#endif
+
+	info.mode = config[1];
+
+	port = js_register_port(port, &info, 1, sizeof(struct js_db9_info), js_db9_read);
+
+#ifdef USE_PARPORT
+	printk(KERN_INFO "js%d: %s on %s\n",
+		js_register_device(port, 0, 2, buttons[info.mode], name[info.mode], js_db9_open, js_db9_close),
+		name[info.mode], info.port->port->name);
+#else
+	printk(KERN_INFO "js%d: %s at %#x\n",
+		js_register_device(port, 0, 2, buttons[info.mode], name[info.mode], js_db9_open, js_db9_close),
+		name[info.mode], info.port);
+#endif
+
+	js_db9_init_corr(port->corr);
+
+	return port;
+}
+
+#ifndef MODULE
+void __init js_db9_setup(char *str, int *ints)
+{
+	int i;
+
+	if (!strcmp(str,"js_db9"))
+		for (i = 0; i <= ints[0] && i < 2; i++) js_db9[i] = ints[i+1];
+	if (!strcmp(str,"js_db9_2"))
+		for (i = 0; i <= ints[0] && i < 2; i++) js_db9_2[i] = ints[i+1];
+	if (!strcmp(str,"js_db9_3"))
+		for (i = 0; i <= ints[0] && i < 2; i++) js_db9_3[i] = ints[i+1];
+
+}
+#endif
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_db9_init(void)
+#endif
+{
+	js_db9_port = js_db9_probe(js_db9, js_db9_port);
+	js_db9_port = js_db9_probe(js_db9_2, js_db9_port);
+	js_db9_port = js_db9_probe(js_db9_3, js_db9_port);
+
+	if (js_db9_port) return 0;
+
+#ifdef MODULE
+	printk(KERN_WARNING "joy-db9: no joysticks specified\n");
+#endif
+	return -ENODEV;
+}
diff -urN linux-2.0.36/drivers/char/joystick/joy-gravis.c linux-2.0.36-joystick/drivers/char/joystick/joy-gravis.c
--- linux-2.0.36/drivers/char/joystick/joy-gravis.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-gravis.c	Mon Mar  8 15:41:19 1999
@@ -0,0 +1,401 @@
+/*
+ *  joy-gravis.c  Version 1.2
+ *
+ *  Copyright (c) 1998-1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * Gravis GrIP digital joystick family.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+
+#define JS_GR_MODE_GPP		1
+#define JS_GR_LENGTH_GPP	24
+#define JS_GR_STROBE_GPP	200
+
+#define JS_GR_MODE_XT		2
+#define JS_GR_MODE_BD		3
+#define JS_GR_LENGTH_XT		4
+#define JS_GR_STROBE_XT		64
+#define JS_GR_MAX_CHUNKS_XT	10	
+#define JS_GR_MAX_BITS_XT	30	
+
+static int js_gr_port_list[] __initdata = {0x201, 0};
+static struct js_port* js_gr_port __initdata = NULL;
+
+struct js_gr_info {
+	int io;
+	unsigned char mode[2];
+};
+
+/*
+ * js_gr_gpp_read_packet() reads a Gravis GamePad Pro packet.
+ */
+
+static int js_gr_gpp_read_packet(int io, int shift, unsigned int *data)
+{
+	unsigned long flags;
+	unsigned char u, v;
+	unsigned int t;
+	int i;
+
+	int strobe = (js_io_speed * JS_GR_STROBE_GPP) >> 10;
+
+	i = 0;
+	data[0] = 0;
+
+	__save_flags(flags);
+	__cli();
+
+	v = inb(io) >> shift;
+	t = strobe;
+
+	do {
+		t--;
+		u = v; v = (inb(io) >> shift) & 3;
+		if (~v & u & 1) {
+			data[0] |= (v >> 1) << i++;
+			t = strobe;
+		}
+	} while (i < JS_GR_LENGTH_GPP && t > 0);
+
+	__restore_flags(flags);
+
+	if (i < JS_GR_LENGTH_GPP) return -1;
+
+	for (i = 0; i < JS_GR_LENGTH_GPP && (data[0] & 0xfe4210) ^ 0x7c0000; i++)
+		data[0] = data[0] >> 1 | (data[0] & 1) << (JS_GR_LENGTH_GPP - 1);
+
+	return -(i == JS_GR_LENGTH_GPP);
+}
+
+/*
+ * js_gr_xt_read_packet() reads a Gravis Xterminator packet.
+ */
+
+static int js_gr_xt_read_packet(int io, int shift, unsigned int *data)
+{
+	unsigned int i, j, buf, crc;
+	unsigned char u, v, w;
+	unsigned long flags;
+	unsigned int t;
+	char status;
+
+	int strobe = (js_io_speed * JS_GR_STROBE_XT) >> 10;
+
+	data[0] = data[1] = data[2] = data[3] = 0;
+	status = buf = i = j = 0;
+
+	__save_flags(flags);
+	__cli();
+
+	v = w = (inb(io) >> shift) & 3;
+	t = strobe;
+
+	do {
+		t--;
+		u = (inb(io) >> shift) & 3;
+
+		if (u ^ v) {
+
+			if ((u ^ v) & 1) {
+				buf = (buf << 1) | (u >> 1);
+				i++;
+			} else 
+
+			if ((((u ^ v) & (v ^ w)) >> 1) & ~(u | v | w) & 1) {
+				if (i == 20) {
+					crc = buf ^ (buf >> 7) ^ (buf >> 14);
+					if (!((crc ^ (0x25cb9e70 >> ((crc >> 2) & 0x1c))) & 0xf)) {
+						data[buf >> 18] = buf >> 4;
+						status |= 1 << (buf >> 18);
+					}
+					j++;
+				}
+				buf = 0;
+				i = 0;
+			}
+
+			t = strobe;
+			w = v;
+			v = u;
+		}
+
+	} while (status != 0xf && i < JS_GR_MAX_BITS_XT && j < JS_GR_MAX_CHUNKS_XT && t > 0);
+
+	__restore_flags(flags);
+
+	return -(status != 0xf);
+}
+
+/*
+ * js_gr_read() reads and analyzes GrIP joystick data.
+ */
+
+static int js_gr_read(void *xinfo, int **axes, int **buttons)
+{
+	struct js_gr_info *info = xinfo;
+	unsigned int data[JS_GR_LENGTH_XT];
+	int i;
+
+	for (i = 0; i < 2; i++)
+		switch (info->mode[i]) {
+
+			case JS_GR_MODE_GPP:
+
+				if (js_gr_gpp_read_packet(info->io, (i << 1) + 4, data)) return -1;
+
+				axes[i][0] = ((data[0] >> 15) & 1) - ((data[0] >> 16) & 1);
+				axes[i][1] = ((data[0] >> 13) & 1) - ((data[0] >> 12) & 1);
+
+				data[0] = ((data[0] >> 6) & 0x37) | (data[0] & 0x08) | ((data[0] << 1) & 0x40) |
+				       ((data[0] << 5) & 0x80) | ((data[0] << 8) & 0x300);
+
+				buttons[i][0] = (data[0] & 0xfc) | ((data[0] >> 1) & 0x101) | ((data[0] << 1) & 0x202);
+
+				break;
+
+			case JS_GR_MODE_XT:
+
+				if (js_gr_xt_read_packet(info->io, (i << 1) + 4, data)) return -1;
+
+				axes[i][0] =       (data[0] >> 2) & 0x3f;
+				axes[i][1] = 63 - ((data[0] >> 8) & 0x3f);
+				axes[i][2] =       (data[1] >> 2) & 0x3f;
+				axes[i][3] =       (data[1] >> 8) & 0x3f;
+				axes[i][4] =       (data[2] >> 8) & 0x3f;
+
+				axes[i][5] = ((data[2] >> 1) & 1) - ( data[2]       & 1);
+				axes[i][6] = ((data[2] >> 2) & 1) - ((data[2] >> 3) & 1);
+				axes[i][7] = ((data[2] >> 5) & 1) - ((data[2] >> 4) & 1);
+				axes[i][8] = ((data[2] >> 6) & 1) - ((data[2] >> 7) & 1);
+
+				buttons[i][0] = (data[3] >> 3) & 0x7ff;
+
+				break;
+
+			case JS_GR_MODE_BD:
+
+				if (js_gr_xt_read_packet(info->io, (i << 1) + 4, data)) return -1;
+
+				axes[i][0] =       (data[0] >> 2) & 0x3f;
+				axes[i][1] = 63 - ((data[0] >> 8) & 0x3f);
+				axes[i][2] =       (data[2] >> 8) & 0x3f;
+
+				axes[i][3] = ((data[2] >> 1) & 1) - ( data[2]       & 1);
+				axes[i][4] = ((data[2] >> 2) & 1) - ((data[2] >> 3) & 1);
+
+				buttons[i][0] = ((data[3] >> 6) & 0x01) | ((data[3] >> 3) & 0x06)
+					      | ((data[3] >> 4) & 0x18);
+
+				break;
+
+			default:
+				break;
+
+		}
+
+
+	return 0;
+}
+
+/*
+ * js_gr_open() is a callback from the file open routine.
+ */
+
+static int js_gr_open(struct js_dev *jd)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_gr_close() is a callback from the file release routine.
+ */
+
+static int js_gr_close(struct js_dev *jd)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_gr_init_corr() initializes correction values of
+ * GrIP joysticks.
+ */
+
+static void __init js_gr_init_corr(int mode, struct js_corr *corr)
+{
+	int i;
+
+	switch (mode) {
+
+		case JS_GR_MODE_GPP:
+
+			for (i = 0; i < 2; i++) {
+				corr[i].type = JS_CORR_BROKEN;
+				corr[i].prec = 0;
+				corr[i].coef[0] = 0;
+				corr[i].coef[1] = 0;
+				corr[i].coef[2] = (1 << 29);
+				corr[i].coef[3] = (1 << 29);
+			}
+
+			break;
+
+		case JS_GR_MODE_XT:
+
+			for (i = 0; i < 5; i++) {
+				corr[i].type = JS_CORR_BROKEN;
+				corr[i].prec = 0;
+				corr[i].coef[0] = 31 - 4;
+				corr[i].coef[1] = 32 + 4;
+				corr[i].coef[2] = (1 << 29) / (32 - 14);
+				corr[i].coef[3] = (1 << 29) / (32 - 14);
+			}
+
+			for (i = 5; i < 9; i++) {
+				corr[i].type = JS_CORR_BROKEN;
+				corr[i].prec = 0;
+				corr[i].coef[0] = 0;
+				corr[i].coef[1] = 0;
+				corr[i].coef[2] = (1 << 29);
+				corr[i].coef[3] = (1 << 29);
+			}
+
+			break;
+
+		case JS_GR_MODE_BD:
+
+			for (i = 0; i < 3; i++) {
+				corr[i].type = JS_CORR_BROKEN;
+				corr[i].prec = 0;
+				corr[i].coef[0] = 31 - 4;
+				corr[i].coef[1] = 32 + 4;
+				corr[i].coef[2] = (1 << 29) / (32 - 14);
+				corr[i].coef[3] = (1 << 29) / (32 - 14);
+			}
+
+			for (i = 3; i < 5; i++) {
+				corr[i].type = JS_CORR_BROKEN;
+				corr[i].prec = 0;
+				corr[i].coef[0] = 0;
+				corr[i].coef[1] = 0;
+				corr[i].coef[2] = (1 << 29);
+				corr[i].coef[3] = (1 << 29);
+			}
+			
+			break;
+
+	}
+}
+
+/*
+ * js_gr_probe() probes for GrIP joysticks.
+ */
+
+static struct js_port __init *js_gr_probe(int io, struct js_port *port)
+{
+	struct js_gr_info info;
+	char *names[] = { NULL, "Gravis GamePad Pro", "Gravis Xterminator", "Gravis Blackhawk Digital"};
+	char axes[] = { 0, 2, 9, 5};
+	char buttons[] = { 0, 10, 11, 5};
+	unsigned int data[JS_GR_LENGTH_XT];
+	int i;
+
+	if (check_region(io, 1)) return port;
+
+	info.mode[0] = info.mode[1] = 0;
+
+	for (i = 0; i < 2; i++) {
+		if (!js_gr_gpp_read_packet(io, (i << 1) + 4, data)) info.mode[i] = JS_GR_MODE_GPP;
+		if (!js_gr_xt_read_packet(io, (i << 1) + 4, data)) {
+			if ((data[3] & 7) == 7)
+				info.mode[i] = JS_GR_MODE_XT;
+			if ((data[3] & 7) == 0)
+				info.mode[i] = JS_GR_MODE_BD;
+		}
+	}
+
+	if (!info.mode[0] && !info.mode[1]) return port;
+
+	info.io = io;
+
+	request_region(io, 1, "joystick (gravis)");
+	port = js_register_port(port, &info, 2, sizeof(struct js_gr_info), js_gr_read);
+
+	for (i = 0; i < 2; i++)
+		if (info.mode[i]) {
+			printk(KERN_INFO "js%d: %s at %#x\n",
+				js_register_device(port, i, axes[info.mode[i]], buttons[info.mode[i]],
+					names[info.mode[i]], js_gr_open, js_gr_close),
+				names[info.mode[i]], io);
+			js_gr_init_corr(info.mode[i], port->corr[i]);
+		}
+
+	return port;
+}
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_gr_init(void)
+#endif
+{
+	int *p;
+
+	for (p = js_gr_port_list; *p; p++) js_gr_port = js_gr_probe(*p, js_gr_port);
+	if (js_gr_port) return 0;
+
+#ifdef MODULE
+	printk(KERN_WARNING "joy-gravis: no joysticks found\n");
+#endif
+
+	return -ENODEV;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	int i;
+	struct js_gr_info *info;
+
+	while (js_gr_port) {
+		for (i = 0; i < js_gr_port->ndevs; i++)
+			if (js_gr_port->devs[i])
+				js_unregister_device(js_gr_port->devs[i]);
+		info = js_gr_port->info;
+		release_region(info->io, 1);
+		js_gr_port = js_unregister_port(js_gr_port);
+	}
+}
+#endif
diff -urN linux-2.0.36/drivers/char/joystick/joy-lightning.c linux-2.0.36-joystick/drivers/char/joystick/joy-lightning.c
--- linux-2.0.36/drivers/char/joystick/joy-lightning.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-lightning.c	Mon Mar  8 15:41:39 1999
@@ -0,0 +1,365 @@
+/*
+ *  joy-lightning.c  Version 1.2
+ *
+ *  Copyright (c) 1998-1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * PDPI Lightning 4 gamecards and analog joysticks connected
+ * to them.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+
+#define JS_L4_PORT		0x201
+#define JS_L4_SELECT_ANALOG	0xa4
+#define JS_L4_SELECT_DIGITAL	0xa5
+#define JS_L4_SELECT_SECONDARY	0xa6
+#define JS_L4_CMD_ID		0x80
+#define JS_L4_CMD_GETCAL	0x92
+#define JS_L4_CMD_SETCAL	0x93
+#define JS_L4_ID		0x04
+#define JS_L4_BUSY		0x01
+#define JS_L4_TIMEOUT		80	/* 80 us */
+
+static struct js_port* __initdata js_l4_port = NULL;
+
+MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
+MODULE_PARM(js_l4, "2-24i");
+
+static int __initdata js_l4[] = { -1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0 };
+
+#include "joy-analog.h"
+
+struct js_l4_info {
+	int port;
+	struct js_an_info an;
+};
+
+/*
+ * js_l4_wait_ready() waits for the L4 to become ready.
+ */
+
+static int js_l4_wait_ready(void)
+{
+	unsigned int t;
+	t = (JS_L4_TIMEOUT * js_io_speed) >> 10;
+	while ((inb(JS_L4_PORT) & JS_L4_BUSY) && t > 0) t--;
+	return -(t<=0);
+}
+
+/*
+ * js_l4_read() reads data from the Lightning 4.
+ */
+
+static int js_l4_read(void *xinfo, int **axes, int **buttons)
+{
+	struct js_l4_info *info = xinfo;
+	int i;
+	unsigned char status;
+
+	outb(JS_L4_SELECT_ANALOG, JS_L4_PORT);
+	outb(JS_L4_SELECT_DIGITAL + (info->port >> 2), JS_L4_PORT);
+
+	if (inb(JS_L4_PORT) & JS_L4_BUSY) return -1;
+	outb(info->port & 3, JS_L4_PORT);
+
+	if (js_l4_wait_ready()) return -1;
+	status = inb(JS_L4_PORT);
+
+	for (i = 0; i < 4; i++)
+		if (status & (1 << i)) {
+			if (js_l4_wait_ready()) return -1;
+			info->an.axes[i] = inb(JS_L4_PORT);
+		}
+
+	if (status & 0x10) {
+		if (js_l4_wait_ready()) return -1;
+		info->an.buttons = inb(JS_L4_PORT);
+	}
+
+	js_an_decode(&info->an, axes, buttons);
+
+	return 0;
+}
+
+/*
+ * js_l4_getcal() reads the L4 with calibration values.
+ */
+
+static int js_l4_getcal(int port, int *cal)
+{
+	int i;
+	
+	outb(JS_L4_SELECT_ANALOG, JS_L4_PORT);
+	outb(JS_L4_SELECT_DIGITAL + (port >> 2), JS_L4_PORT);
+
+	if (inb(JS_L4_PORT) & JS_L4_BUSY) return -1;
+	outb(JS_L4_CMD_GETCAL, JS_L4_PORT);
+
+	if (js_l4_wait_ready()) return -1;
+	if (inb(JS_L4_PORT) != JS_L4_SELECT_DIGITAL + (port >> 2)) return -1;
+
+	if (js_l4_wait_ready()) return -1;
+        outb(port & 3, JS_L4_PORT);
+
+	for (i = 0; i < 4; i++) {
+		if (js_l4_wait_ready()) return -1;
+		cal[i] = inb(JS_L4_PORT);
+	}
+
+	return 0;
+}
+
+/*
+ * js_l4_setcal() programs the L4 with calibration values.
+ */
+
+static int js_l4_setcal(int port, int *cal)
+{
+	int i;
+
+	outb(JS_L4_SELECT_ANALOG, JS_L4_PORT);
+	outb(JS_L4_SELECT_DIGITAL + (port >> 2), JS_L4_PORT);
+
+	if (inb(JS_L4_PORT) & JS_L4_BUSY) return -1;
+	outb(JS_L4_CMD_SETCAL, JS_L4_PORT);
+
+	if (js_l4_wait_ready()) return -1;
+	if (inb(JS_L4_PORT) != JS_L4_SELECT_DIGITAL + (port >> 2)) return -1;
+
+	if (js_l4_wait_ready()) return -1;
+        outb(port & 3, JS_L4_PORT);
+
+	for (i = 0; i < 4; i++) {
+		if (js_l4_wait_ready()) return -1;
+		outb(cal[i], JS_L4_PORT);
+	}
+
+	return 0;
+}
+
+/*
+ * js_l4_calibrate() calibrates the L4 for the attached device, so
+ * that the device's resistance fits into the L4's 8-bit range.
+ */
+
+static void js_l4_calibrate(struct js_l4_info *info)
+{
+	int i;
+	int cal[4];
+	int axes[4];
+	int t;
+
+	js_l4_getcal(info->port, cal);
+
+	for (i = 0; i < 4; i++)
+		axes[i] = info->an.axes[i];
+	
+	if ((info->an.extensions & JS_AN_BUTTON_PXY_X) && !(info->an.extensions & JS_AN_BUTTON_PXY_U))
+		axes[2] >>= 1;							/* Pad button X */
+
+	if ((info->an.extensions & JS_AN_BUTTON_PXY_Y) && !(info->an.extensions & JS_AN_BUTTON_PXY_V))
+		axes[3] >>= 1;							/* Pad button Y */
+
+	if (info->an.extensions & JS_AN_HAT_FCS) 
+		axes[3] >>= 1;							/* FCS hat */
+
+	if (((info->an.mask[0] & 0xb) == 0xb) || ((info->an.mask[1] & 0xb) == 0xb))
+		axes[3] = (axes[0] + axes[1]) >> 1;				/* Throttle */
+
+	for (i = 0; i < 4; i++) {
+		t = (axes[i] * cal[i]) / 100;
+		if (t > 255) t = 255;
+		info->an.axes[i] = (info->an.axes[i] * cal[i]) / t;
+		cal[i] = t;
+	}
+
+	js_l4_setcal(info->port, cal);
+}
+	
+/*
+ * js_l4_open() is a callback from the file open routine.
+ */
+
+static int js_l4_open(struct js_dev *jd)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_l4_close() is a callback from the file release routine.
+ */
+
+static int js_l4_close(struct js_dev *jd)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_l4_probe() probes for joysticks on the L4 cards.
+ */
+
+static struct js_port __init *js_l4_probe(unsigned char *cards, int l4port, int mask0, int mask1, struct js_port *port)
+{
+	struct js_l4_info iniinfo;
+	struct js_l4_info *info = &iniinfo;
+	int cal[4] = {255,255,255,255};
+	int i, numdev;
+	unsigned char u;
+
+	if (l4port < 0) return port;
+	if (!cards[(l4port >> 2)]) return port;
+
+	memset(info, 0, sizeof(struct js_l4_info));
+	info->port = l4port;
+
+	if (cards[l4port >> 2] > 0x28) js_l4_setcal(info->port, cal);
+	if (js_l4_read(info, NULL, NULL)) return port;
+
+	for (i = u = 0; i < 4; i++) if (info->an.axes[i] < 253) u |= 1 << i;
+
+	if ((numdev = js_an_probe_devs(&info->an, u, mask0, mask1, port)) <= 0)
+		return port;
+
+	port = js_register_port(port, info, numdev, sizeof(struct js_l4_info), js_l4_read);
+
+	for (i = 0; i < numdev; i++)
+		printk(KERN_INFO "js%d: %s on L4 port %d\n",
+			js_register_device(port, i, js_an_axes(i, &info->an), js_an_buttons(i, &info->an),
+				js_an_name(i, &info->an), js_l4_open, js_l4_close),
+			js_an_name(i, &info->an), info->port);
+
+	info = port->info;
+
+	js_l4_calibrate(info);
+	js_l4_read(info, port->axes, port->buttons);
+	js_an_init_corr(&info->an, port->axes, port->corr, 0);
+
+	return port;
+}
+
+/*
+ * js_l4_card_probe() probes for presence of the L4 card(s).
+ */
+
+static void __init js_l4_card_probe(unsigned char *cards)
+{
+	int i;
+	unsigned char rev = 0;
+
+	if (check_region(JS_L4_PORT, 1)) return;
+
+	for (i = 0; i < 2; i++) {
+
+		outb(JS_L4_SELECT_ANALOG, JS_L4_PORT);
+		outb(JS_L4_SELECT_DIGITAL + i, JS_L4_PORT);		/* Select card 0-1 */
+
+		if (inb(JS_L4_PORT) & JS_L4_BUSY) continue;
+		outb(JS_L4_CMD_ID, JS_L4_PORT);				/* Get card ID & rev */
+
+		if (js_l4_wait_ready()) continue;
+		if (inb(JS_L4_PORT) != JS_L4_SELECT_DIGITAL + i) continue;
+
+		if (js_l4_wait_ready()) continue;
+		if (inb(JS_L4_PORT) != JS_L4_ID) continue;
+
+		if (js_l4_wait_ready()) continue;
+		rev = inb(JS_L4_PORT);
+
+		cards[i] = rev; 
+
+		printk(KERN_INFO "js: PDPI Lightning 4 %s card (ports %d-%d) firmware v%d.%d at %#x\n",
+			i ? "secondary" : "primary", (i << 2), (i << 2) + 3, rev >> 4, rev & 0xf, JS_L4_PORT);
+	}
+
+}
+
+#ifndef MODULE
+void __init js_l4_setup(char *str, int *ints)
+{
+	int i;
+	for (i = 0; i <= ints[0] && i < 24; i++) js_l4[i] = ints[i+1];
+}
+#endif
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_l4_init(void)
+#endif
+{
+	int i;
+	unsigned char cards[2] = {0, 0};
+
+	js_l4_card_probe(cards);
+
+	if (js_l4[0] >= 0) {
+		for (i = 0; (js_l4[i*3] >= 0) && i < 8; i++)
+			js_l4_port = js_l4_probe(cards, js_l4[i*3], js_l4[i*3+1], js_l4[i*3+2], js_l4_port);
+	} else {
+		for (i = 0; i < 8; i++)
+			js_l4_port = js_l4_probe(cards, i, 0, 0, js_l4_port);
+	}
+
+	if (!js_l4_port) {
+#ifdef MODULE
+		printk(KERN_WARNING "joy-lightning: no joysticks found\n");
+#endif
+		return -ENODEV;
+	}
+
+	request_region(JS_L4_PORT, 1, "joystick (lightning)");
+
+	return 0;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	int i;
+	int cal[4] = {59, 59, 59, 59};
+	struct js_l4_info *info;
+
+	while (js_l4_port) {
+		for (i = 0; i < js_l4_port->ndevs; i++)
+			if (js_l4_port->devs[i])
+				js_unregister_device(js_l4_port->devs[i]);
+		info = js_l4_port->info;
+		js_l4_setcal(info->port, cal);
+		js_l4_port = js_unregister_port(js_l4_port);
+	}
+	outb(JS_L4_SELECT_ANALOG, JS_L4_PORT);
+	release_region(JS_L4_PORT, 1);
+}
+#endif
diff -urN linux-2.0.36/drivers/char/joystick/joy-logitech.c linux-2.0.36-joystick/drivers/char/joystick/joy-logitech.c
--- linux-2.0.36/drivers/char/joystick/joy-logitech.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-logitech.c	Mon Mar  8 15:41:48 1999
@@ -0,0 +1,478 @@
+/*
+ *  joy-logitech.c  Version 1.2
+ *
+ *  Copyright (c) 1998-1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * Logitech ADI joystick family.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/malloc.h>
+
+/*
+ * Times array sizes, flags, ids.
+ */
+
+#define JS_LT_MAX_START		400
+#define JS_LT_MAX_STROBE	45
+
+#define JS_LT_MAX_LENGTH	256
+#define JS_LT_MIN_LENGTH	8
+#define JS_LT_MIN_ID_LENGTH	66
+#define JS_LT_MAX_NAME_LENGTH	16
+
+#define JS_LT_SYNC_DELAY	10000
+#define JS_LT_STATUS_DELAY	10000
+#define JS_LT_EXTRA_DELAY	10000
+
+#define JS_LT_FLAG_CHAIN	0x01
+#define JS_LT_FLAG_HAT		0x04
+#define JS_LT_FLAG_10BIT	0x08
+
+#define JS_LT_ID_TPD		0x01
+#define JS_LT_ID_WGP		0x06
+
+/*
+ * Timing sequences for magic commands.
+ */
+
+static int js_lt_seq_digital[] __initdata = { 6000, 11000, 7000, 9000, 0 };
+static int js_lt_seq_analog[] __initdata = { 2000, 3000, 0 };
+
+/*
+ * Port probing variables.
+ */
+
+static int js_lt_port_list[] __initdata = { 0x201, 0 };
+static struct js_port* js_lt_port __initdata = NULL;
+
+/*
+ * Device names.
+ */
+
+#define JS_LT_MAX_ID		7
+
+static char *js_lt_names[] = {"WingMan Extreme Digital", "ThunderPad Digital", "Sidecar", "CyberMan 2",
+				"WingMan Interceptor", "WingMan Formula", "WingMan GamePad", 
+				  "Unknown Device %#x"};
+
+/*
+ * Hat to axis conversion arrays.
+ */
+
+static struct {
+	int x;
+	int y;
+} js_lt_hat_to_axis[] = {{ 0, 0}, { 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};
+
+/*
+ * Per-port information.
+ */
+
+struct js_lt_info {
+	int  io;
+	int  length[2];
+	int  ret[2];
+	int  idx[2];
+	unsigned char id[2];
+	char buttons[2];
+	char axes10[2];
+	char axes8[2];
+	char pad[2];
+	char hats[2];
+	char name[2][JS_LT_MAX_NAME_LENGTH];
+	unsigned char data[2][JS_LT_MAX_LENGTH];
+};
+
+/*
+ * js_lt_read_packet() reads a Logitech ADI packet.
+ */
+
+static void js_lt_read_packet(struct js_lt_info *info)
+{
+	unsigned char u, v, w;
+	int t[2];
+	unsigned long flags;
+	int i;
+
+	int strobe = (js_io_speed * JS_LT_MAX_STROBE) >> 10;
+	t[0] = t[1] = (js_io_speed * JS_LT_MAX_START) >> 10;
+	i = info->ret[0] = info->ret[1] = info->idx[0] = info->idx[1] = 0;
+
+	__save_flags(flags);
+	__cli();
+
+	outb(0xff, info->io);
+	u = inb(info->io);
+
+	do {
+		t[0]--; t[1]--;
+		v = inb(info->io);
+		for (i = 0, w = u ^ v; i < 2 && w; i++, w >>= 2)
+			if (w & 0x30) {
+				if ((w & 0x30) < 0x30 && info->ret[i] < JS_LT_MAX_LENGTH && t[i] > 0) {
+					info->data[i][info->ret[i]++] = w;
+					t[i] = strobe;
+					u = v;
+				} else t[i] = 0;
+			}
+	} while (t[0] > 0 || t[1] > 0);
+
+	__restore_flags(flags);
+
+	info->ret[0]--;
+	info->ret[1]--;
+
+	if (info->ret[0] > 0 && info->ret[1] > 0 &&
+		~info->data[0][0] & 0x20 && info->data[1][0] & 0x20) {
+
+		for (i = 1; i <= info->ret[1]; i++)
+			info->data[0][info->ret[1] + i] = info->data[1][i];
+	
+		info->ret[0] += info->ret[1];
+		info->ret[1] = -1;
+	}
+
+	return;
+}
+
+/*
+ * js_lt_get_bits() gathers bits from the data packet.
+ */
+
+static inline int js_lt_get_bits(struct js_lt_info *info, int device, int count)
+{
+	int bits = 0;
+	int i;
+	if ((info->idx[device] += count) > info->ret[device]) return 0;
+	for (i = 0; i < count; i++) bits |= ((info->data[device][info->idx[device] - i] >> 5) & 1) << i; 
+	return bits;
+}
+
+/*
+ * js_lt_read() reads and analyzes Logitech joystick data.
+ */
+
+static int js_lt_read(void *xinfo, int **axes, int **buttons)
+{
+	struct js_lt_info *info = xinfo;
+	int i, j, k, l, t;
+
+	js_lt_read_packet(info);
+
+	for (i = 0; i < 2; i++) {
+
+		if (!info->length[i]) continue;
+		if (info->length[i] != info->ret[i]) return -1;
+
+		if (info->id[i] != (js_lt_get_bits(info, i, 4) 
+					| (js_lt_get_bits(info, i, 4) << 4))) return -1;
+		k = l = 0;
+
+		for (j = 0; j < info->axes10[i]; j++) 
+			axes[i][k++] = js_lt_get_bits(info, i, 10);
+
+		for (j = 0; j < info->axes8[i]; j++) 
+			axes[i][k++] = js_lt_get_bits(info, i, 8);
+
+		for (j = 0; j <= (info->buttons[i] - 1) >> 5; j++) buttons[i][j] = 0;
+
+		for (j = 0; j < info->buttons[i] && j < 63; j++) {
+			if (j == info->pad[i]) {
+				t = js_lt_get_bits(info, i, 4);
+				axes[i][k++] = ((t >> 2) & 1) - ( t       & 1);
+				axes[i][k++] = ((t >> 1) & 1) - ((t >> 3) & 1);
+			}
+			buttons[i][l >> 5] |= js_lt_get_bits(info, i, 1) << (l & 0x1f);
+			l++;
+		}
+
+		for (j = 0; j < info->hats[i]; j++) {
+			if((t = js_lt_get_bits(info, i, 4)) > 8) return -1;
+			axes[i][k++] = js_lt_hat_to_axis[t].x;
+			axes[i][k++] = js_lt_hat_to_axis[t].y;
+		}
+
+		if (info->buttons[i] > 63)
+			for (j = 63; j < info->buttons[i]; j++) {
+				buttons[i][l >> 5] |= js_lt_get_bits(info, i, 1) << (l & 0x1f);
+				l++;
+			}
+
+	}
+
+	return 0;
+}
+
+/*
+ * js_lt_open() is a callback from the file open routine.
+ */
+
+static int js_lt_open(struct js_dev *jd)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_lt_close() is a callback from the file release routine.
+ */
+
+static int js_lt_close(struct js_dev *jd)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_lt_trigger_sequence() sends a trigger & delay sequence
+ * to reset/initialize a Logitech joystick.
+ */
+
+static void __init js_lt_trigger_sequence(int io, int *seq)
+{
+	unsigned long flags;
+
+	__save_flags(flags);
+	__cli();
+
+	while (*seq) {
+		outb(0xff,io);
+		udelay(*seq++);
+	}
+	outb(0xff,io);
+
+	__restore_flags(flags);
+}
+
+/*
+ * js_lt_init_corr() initializes the correction values for
+ * Logitech joysticks.
+ */
+
+static void __init js_lt_init_corr(int naxes10, int naxes8, int naxes1, int *axes, struct js_corr *corr)
+{
+	int j;
+	
+	if (!naxes8 && (naxes10 == 3)) axes[2] = 512;	/* Throttle fixup */
+	if (!naxes10 && (naxes8 == 3)) axes[2] = 128;
+
+	for (j = 0; j < naxes10; j++) {
+		corr[j].type = JS_CORR_BROKEN;
+		corr[j].prec = 4;
+		corr[j].coef[0] = axes[j] - 8;
+		corr[j].coef[1] = axes[j] + 8;
+		corr[j].coef[2] = (1 << 29) / (256 - 64);
+		corr[j].coef[3] = (1 << 29) / (256 - 64);
+	}
+
+	for (; j < naxes8 + naxes10; j++) {
+		corr[j].type = JS_CORR_BROKEN;
+		corr[j].prec = 1;
+		corr[j].coef[0] = axes[j] - 2;
+		corr[j].coef[1] = axes[j] + 2;
+		corr[j].coef[2] = (1 << 29) / (64 - 16);
+		corr[j].coef[3] = (1 << 29) / (64 - 16);
+	}
+
+	for (; j < naxes1 + naxes8 + naxes10; j++) {
+		corr[j].type = JS_CORR_BROKEN;
+		corr[j].prec = 0;
+		corr[j].coef[0] = 0;
+		corr[j].coef[1] = 0;
+		corr[j].coef[2] = (1 << 29);
+		corr[j].coef[3] = (1 << 29);
+	}
+
+}
+
+/*
+ * js_lt_probe() probes for Logitech type joysticks.
+ */
+
+static struct js_port __init *js_lt_probe(int io, struct js_port *port)
+{
+	struct js_lt_info info;
+	char name[32];
+	int i, j, t;
+
+	if (check_region(io, 1)) return port;
+
+	js_lt_trigger_sequence(io, js_lt_seq_analog);
+	udelay(JS_LT_SYNC_DELAY);
+	js_lt_trigger_sequence(io, js_lt_seq_digital);
+	udelay(JS_LT_STATUS_DELAY);
+
+	memset(&info, 0, sizeof(struct js_lt_info));
+
+	info.length[0] = info.length[1] = JS_LT_MAX_LENGTH;
+
+	info.io = io;
+	js_lt_read_packet(&info);
+	udelay(JS_LT_EXTRA_DELAY);
+
+	info.length[0] = info.length[1] = 0;
+
+	for (i = 0; i < 2; i++) {
+
+		if (info.ret[i] < JS_LT_MIN_ID_LENGTH) continue; /* Minimum ID packet length */
+
+		if (info.ret[i] != (t = js_lt_get_bits(&info, i, 10))) {
+			printk(KERN_WARNING "joy-logitech: Wrong ID packet length: reported: %d != read: %d\n",
+				t, info.ret[i]); 
+			continue;
+		}
+
+		info.id[i] = js_lt_get_bits(&info, i, 4) | (js_lt_get_bits(&info, i, 4) << 4);
+
+		t = js_lt_get_bits(&info, i, 4);
+
+		if (t & JS_LT_FLAG_CHAIN) {
+			printk(KERN_WARNING "joy-logitech: Daisy-chained devices not supported yet. Ignoring device.\n");
+			continue;
+		}
+
+		if (t & JS_LT_FLAG_HAT) info.hats[i]++;
+
+		if ((info.length[i] = js_lt_get_bits(&info, i, 10)) >= JS_LT_MAX_LENGTH) {
+			printk(KERN_WARNING "joy-logitech: Expected packet length too long (%d).\n",
+				info.length[i]);
+			continue;
+		}
+
+		if (info.length[i] < JS_LT_MIN_LENGTH) {
+			printk(KERN_WARNING "joy-logitech: Expected packet length too short (%d).\n",
+				info.length[i]);
+			continue;
+		}
+
+		info.axes8[i] = js_lt_get_bits(&info, i, 4);
+		info.buttons[i] = js_lt_get_bits(&info, i, 6);
+
+		if (js_lt_get_bits(&info, i, 6) != 8 && info.hats[i]) {
+			printk(KERN_WARNING "joy-logitech: Other than 8-dir POVs not supported yet.\n");
+			continue;
+		}
+
+		info.buttons[i] += js_lt_get_bits(&info, i, 6);
+		info.hats[i] += js_lt_get_bits(&info, i, 4);
+
+		j = js_lt_get_bits(&info, i, 4);
+
+		if (t & JS_LT_FLAG_10BIT) {
+			info.axes10[i] = info.axes8[i];
+			info.axes8[i] = j;
+		}
+
+		t = js_lt_get_bits(&info, i, 4);
+
+		for (j = 0; j < t; j++)
+			info.name[i][j] = js_lt_get_bits(&info, i, 8);
+		info.name[i][j] = 0;
+
+		switch (info.id[i]) {
+			case JS_LT_ID_TPD:
+				info.pad[i] = 4;
+				info.buttons[i] -= 4;
+				break;
+			case JS_LT_ID_WGP:
+				info.pad[i] = 0;
+				info.buttons[i] -= 4;
+				break;
+			default:
+				info.pad[i] = -1;
+				break;
+		}
+	}
+
+	if (!info.length[0] && !info.length[1])
+		return port;
+
+	request_region(io, 1, "joystick (logitech)");
+
+	port = js_register_port(port, &info, 2, sizeof(struct js_lt_info), js_lt_read);
+
+	for (i = 0; i < 2; i++)
+		if (info.length[i] > 0) {
+			sprintf(name, info.id[i] < JS_LT_MAX_ID ? js_lt_names[info.id[i]] : js_lt_names[JS_LT_MAX_ID], info.id[i]); 
+			printk(KERN_INFO "js%d: %s [%s] at %#x\n",
+				js_register_device(port, i,
+					info.axes10[i] + info.axes8[i] + ((info.hats[i] + (info.pad[i] >= 0)) << 1),
+					info.buttons[i], name, js_lt_open, js_lt_close), name, info.name[i], io);
+		}
+
+	js_lt_read(port->info, port->axes, port->buttons);
+
+	for (i = 0; i < 2; i++)
+		if (info.length[i] > 0)
+				js_lt_init_corr(info.axes10[i], info.axes8[i],
+					((info.pad[i] >= 0) + info.hats[i]) << 1, port->axes[i], port->corr[i]);
+
+	return port;
+}
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_lt_init(void)
+#endif
+{
+	int *p;
+
+	for (p = js_lt_port_list; *p; p++) js_lt_port = js_lt_probe(*p, js_lt_port);
+	if (js_lt_port) return 0;
+
+#ifdef MODULE
+	printk(KERN_WARNING "joy-logitech: no joysticks found\n");
+#endif
+
+	return -ENODEV;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	int i;
+	struct js_lt_info *info;
+
+	while (js_lt_port) {
+		for (i = 0; i < js_lt_port->ndevs; i++)
+			 if (js_lt_port->devs[i])
+				js_unregister_device(js_lt_port->devs[i]);
+		info = js_lt_port->info;
+		release_region(info->io, 1);
+		js_lt_port = js_unregister_port(js_lt_port);
+	}
+}
+#endif
diff -urN linux-2.0.36/drivers/char/joystick/joy-magellan.c linux-2.0.36-joystick/drivers/char/joystick/joy-magellan.c
--- linux-2.0.36/drivers/char/joystick/joy-magellan.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-magellan.c	Mon Mar  8 15:41:57 1999
@@ -0,0 +1,394 @@
+/*
+ *  joy-magellan.c  Version 0.1
+ *
+ *  Copyright (c) 1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * the Magellan and Space Mouse 6dof controllers.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ *  Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/errno.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/tty.h>
+
+/*
+ * Constants.
+ */
+
+#define	N_JOYSTICK_MAG		14
+#define JS_MAG_MAX_LENGTH	64
+
+/*
+ * List of Magellans.
+ */
+
+static struct js_port* js_mag_port = NULL;
+
+/*
+ * Per-Magellan data.
+ */
+
+struct js_mag_info {
+	struct tty_struct* tty;
+	struct js_port* port;
+	int idx;
+	unsigned char data[JS_MAG_MAX_LENGTH];
+	unsigned char name[JS_MAG_MAX_LENGTH];
+	char ack;
+	char used;
+};
+
+/*
+ * js_mag_crunch_nibbles() verifies that the bytes sent from the Magellan
+ * have correct upper nibbles for the lower ones, if not, the packet will
+ * be thrown away. It also strips these upper halves to simplify further
+ * processing.
+ */
+
+static int js_mag_crunch_nibbles(unsigned char *data, int count)
+{
+	static unsigned char nibbles[16] = "0AB3D56GH9:K<MN?";
+
+	do {
+		if (data[count] == nibbles[data[count] & 0xf])
+			data[count] = data[count] & 0xf;
+		else
+			return -1;
+	} while (--count);
+
+	return 0;
+}
+
+/*
+ * js_mag_process_packet() decodes packets the driver receives from the
+ * Magellan. It updates the data accordingly, and sets an ACK flag
+ * to the type of last packet received, if received OK.
+ */
+
+static void js_mag_process_packet(struct js_mag_info* info)
+{
+	int i;
+
+	if (!info->idx) return;
+
+	switch (info->data[0]) {
+
+		case 'd':				/* Axis data */
+			if (info->idx != 25) return;
+			if (js_mag_crunch_nibbles(info->data, 24)) return;
+			if (!info->port->devs[0]) return;
+			for (i = 0; i < 6; i++) {
+				info->port->axes[0][i] = 
+					( info->data[(i << 2) + 1] << 12 | info->data[(i << 2) + 2] << 8 |
+					  info->data[(i << 2) + 3] <<  4 | info->data[(i << 2) + 4] )
+					 - 32768;
+			}
+			break;
+
+		case 'e':				/* Error packet */
+			if (info->idx != 4) return;
+			if (js_mag_crunch_nibbles(info->data, 3)) return;
+			switch (info->data[1]) {
+				case 1:
+					printk(KERN_ERR "joy-magellan: Received command error packet. Failing command byte: %c\n",
+						info->data[2] | (info->data[3] << 4));
+					break;
+				case 2:
+					printk(KERN_ERR "joy-magellan: Received framing error packet.\n");
+					break;
+				default:
+					printk(KERN_ERR "joy-magellan: Received unknown error packet.\n");
+			}
+			break;
+
+		case 'k':				/* Button data */
+			if (info->idx != 4) return;
+			if (js_mag_crunch_nibbles(info->data, 3)) return;
+			if (!info->port->devs[0]) return;
+			info->port->buttons[0][0] = (info->data[1] << 1) | (info->data[2] << 5) | info->data[3];
+			break;
+
+		case 'm':				/* Mode */
+			if (info->idx != 2) return;
+			if (js_mag_crunch_nibbles(info->data, 1)) return; 
+			break;
+
+		case 'n':				/* Null radius */
+			if (info->idx != 2) return;
+			if (js_mag_crunch_nibbles(info->data, 1)) return; 
+			break;
+
+		case 'p':				/* Data rate */
+			if (info->idx != 3) return;
+			if (js_mag_crunch_nibbles(info->data, 2)) return;
+			break;
+
+		case 'q':				/* Sensitivity */
+			if (info->idx != 3) return;
+			if (js_mag_crunch_nibbles(info->data, 2)) return; 
+			break;
+
+		case 'v':				/* Version string */
+			info->data[info->idx] = 0;
+			for (i = 1; i < info->idx && info->data[i] == ' '; i++);
+			memcpy(info->name, info->data + i, info->idx - i);
+			break;
+
+		case 'z':				/* Zero position */
+			break;
+
+		default:
+			printk("joy-magellan: Unknown packet %d length %d:", info->data[0], info->idx);
+			for (i = 0; i < info->idx; i++) printk(" %02x", info->data[i]);
+			printk("\n");
+			return;
+	}
+
+	info->ack = info->data[0];
+}
+
+/*
+ * js_mag_command() sends a command to the Magellan, and waits for
+ * acknowledge.
+ */
+
+static int js_mag_command(struct js_mag_info *info, char *command, int timeout)
+{
+	info->ack = 0;
+	if (info->tty->driver.write(info->tty, 0, command, strlen(command)) != strlen(command)) return -1;
+	while (!info->ack && timeout--) mdelay(1);
+	return -(info->ack != command[0]);
+}
+
+/*
+ * js_mag_init() initializes the Magellan to sane state. Also works as
+ * a probe for Magellan existence.
+ */
+
+static int js_mag_init(struct js_mag_info *info)
+{
+
+	if (js_mag_command(info, "vQ\r", 800))	/* Read version */
+		return -1;
+	if (js_mag_command(info, "m3\r", 50))	/* Set full 3d mode */
+		return -1;
+	if (js_mag_command(info, "pBB\r", 50))	/* Set 16 reports/second (max) */
+		return -1;
+	if (js_mag_command(info, "z\r", 50))	/* Set zero position */
+		return -1;
+
+	return 0;
+}
+
+/*
+ * js_mag_read() updates the axis and button data upon startup.
+ */
+
+static int js_mag_read(struct js_mag_info *info)
+{
+	memset(info->port->axes[0],0, sizeof(int) * 6);		/* Axes are 0 after zero postition cmd */ 
+
+	if (js_mag_command(info, "kQ\r", 50))			/* Read buttons */
+		return -1;
+
+	return 0;
+}
+
+/*
+ * js_mag_open() is a callback from the joystick device open routine.
+ */
+
+static int js_mag_open(struct js_dev *jd)
+{
+	struct js_mag_info *info = jd->port->info;
+	info->used++;	
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_mag_close() is a callback from the joystick device release routine.
+ */
+
+static int js_mag_close(struct js_dev *jd)
+{
+	struct js_mag_info *info = jd->port->info;
+	if (!--info->used) {
+		js_unregister_device(jd->port->devs[0]);
+		js_mag_port = js_unregister_port(jd->port);
+	}
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_mag_init_corr() initializes the correction values for the Magellan.
+ * It asumes gain setting of 0, question is, what we should do for higher
+ * gain settings ...
+ */
+
+static void js_mag_init_corr(struct js_corr **corr)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		corr[0][i].type = JS_CORR_BROKEN;
+		corr[0][i].prec = 0;
+		corr[0][i].coef[0] = 0;
+		corr[0][i].coef[1] = 0;
+		corr[0][i].coef[2] = (1 << 29) / 256;
+		corr[0][i].coef[3] = (1 << 29) / 256;
+	}
+}
+
+/*
+ * js_mag_ldisc_open() is the routine that is called upon setting our line
+ * discipline on a tty. It looks for the Magellan, and if found, registers
+ * it as a joystick device.
+ */
+
+static int js_mag_ldisc_open(struct tty_struct *tty)
+{
+	struct js_mag_info iniinfo;
+	struct js_mag_info *info = &iniinfo;
+
+	info->tty = tty;
+	info->idx = 0;
+	info->used = 1;
+
+	js_mag_port = js_register_port(js_mag_port, info, 1, sizeof(struct js_mag_info), NULL);
+
+	info = js_mag_port->info;
+	info->port = js_mag_port;
+	tty->disc_data = info;
+
+	if (js_mag_init(info)) {
+		js_mag_port = js_unregister_port(info->port);
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "js%d: Magellan [%s] on %s%d\n",
+		js_register_device(js_mag_port, 0, 6, 9, "Magellan", js_mag_open, js_mag_close),
+		info->name, tty->driver.name, MINOR(tty->device) - tty->driver.minor_start);
+
+
+	js_mag_read(info);
+	js_mag_init_corr(js_mag_port->corr);
+
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+/*
+ * js_mag_ldisc_close() is the opposite of js_mag_ldisc_open()
+ */
+
+static void js_mag_ldisc_close(struct tty_struct *tty)
+{
+	struct js_mag_info* info = (struct js_mag_info*) tty->disc_data;
+	if (!--info->used) {
+		js_unregister_device(info->port->devs[0]);
+		js_mag_port = js_unregister_port(info->port);
+	}
+	MOD_DEC_USE_COUNT;
+}
+
+/*
+ * js_mag_ldisc_receive() is called by the low level driver when characters
+ * are ready for us. We then buffer them for further processing, or call the
+ * packet processing routine.
+ */
+
+static void js_mag_ldisc_receive(struct tty_struct *tty, const unsigned char *cp, char *fp, int count)
+{
+	struct js_mag_info* info = (struct js_mag_info*) tty->disc_data;
+	int i;
+
+	for (i = 0; i < count; i++)
+		if (cp[i] == '\r') {
+			js_mag_process_packet(info);
+			info->idx = 0;
+		} else {
+			if (info->idx < JS_MAG_MAX_LENGTH)
+				info->data[info->idx++] = cp[i];
+		} 
+}
+
+/*
+ * js_mag_ldisc_room() reports how much room we do have for receiving data.
+ * Although we in fact have infinite room, we need to specify some value
+ * here, so why not the size of our packet buffer. It's big anyway.
+ */
+
+static int js_mag_ldisc_room(struct tty_struct *tty)
+{
+	return JS_MAG_MAX_LENGTH;
+}
+
+/*
+ * The line discipline structure.
+ */
+
+static struct tty_ldisc js_mag_ldisc = {
+        magic:          TTY_LDISC_MAGIC,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+        name:           "magellan",
+#endif
+	open:		js_mag_ldisc_open,
+	close:		js_mag_ldisc_close,
+	receive_buf:	js_mag_ldisc_receive,
+	receive_room:	js_mag_ldisc_room,
+};
+
+/*
+ * The functions for inserting/removing us as a module.
+ */
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_mag_init(void)
+#endif
+{
+        if (tty_register_ldisc(N_JOYSTICK_MAG, &js_mag_ldisc)) {
+                printk(KERN_ERR "joy-magellan: Error registering line discipline.\n");
+		return -ENODEV;
+	}
+
+	return  0;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	tty_register_ldisc(N_JOYSTICK_MAG, NULL);
+}
+#endif
diff -urN linux-2.0.36/drivers/char/joystick/joy-sidewinder.c linux-2.0.36-joystick/drivers/char/joystick/joy-sidewinder.c
--- linux-2.0.36/drivers/char/joystick/joy-sidewinder.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-sidewinder.c	Mon Mar  8 15:42:06 1999
@@ -0,0 +1,766 @@
+/*
+ *  joy-sidewinder.c  Version 1.2
+ *
+ *  Copyright (c) 1998-1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * Microsoft SideWinder digital joystick family.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+
+/*
+ * These are really magic values. Changing them can make a problem go away,
+ * as well as break everything.
+ */
+
+#define JS_SW_START		400	/* The time we wait for the first bit [400 us] */
+#define JS_SW_STROBE		45	/* Max time per bit in the relaxed case [45 us] */
+#define JS_SW_TIMEOUT		4000	/* Wait for everything to settle [4 ms] */
+#define JS_SW_KICK		45	/* Wait after A0 fall till kick [45 us] */
+#define JS_SW_END		8	/* Number of bits before end of packet to kick */
+#define JS_SW_FAIL		16	/* Number of packet read errors to fail and reinitialize */
+#define JS_SW_BAD		2	/* Number of packet read errors to switch off 3d Pro optimization */
+#define JS_SW_OK		64	/* Number of packet read successes to switch optimization back on */
+#define JS_SW_LENGTH		512	/* Max number of bits in a packet */
+
+/*
+ * SideWinder joystick types ...
+ */
+
+#define JS_SW_TYPE_3DP		1
+#define JS_SW_TYPE_F23		2
+#define JS_SW_TYPE_GP		3
+#define JS_SW_TYPE_PP		4
+#define JS_SW_TYPE_FFP		5
+#define JS_SW_TYPE_FSP		6
+#define JS_SW_TYPE_FFW		7
+
+static int js_sw_port_list[] __initdata = {0x201, 0};
+static struct js_port* js_sw_port __initdata = NULL;
+
+static struct {
+	int x;
+	int y;
+} js_sw_hat_to_axis[] = {{ 0, 0}, { 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};
+
+struct js_sw_info {
+	int io;
+	int length;
+	int strobe;
+	unsigned char type;
+	unsigned char bits;
+	unsigned char number;
+	unsigned char fail;
+	unsigned char ok;
+};
+
+/*
+ * js_sw_read_packet() is a function which reads either a data packet, or an
+ * identification packet from a SideWinder joystick. Better don't try to
+ * understand this, since all the ugliness of the Microsoft Digital
+ * Overdrive protocol is concentrated in this function. If you really want
+ * to know how this works, first go watch a couple horror movies, so that
+ * you are well prepared, read US patent #5628686 and then e-mail me,
+ * and I'll send you an explanation.
+ *					Vojtech <vojtech@ucw.cz>
+ */
+
+static int js_sw_read_packet(int io, unsigned char *buf, int length, int id)
+{
+	unsigned long flags;
+	int timeout, bitout, sched, i, kick;
+	unsigned char pending, u, v;
+	
+	int start = (js_io_speed * JS_SW_START) >> 10;
+	int strobe = (js_io_speed * JS_SW_STROBE) >> 10;
+
+	i = -id;						/* Don't care about data, only want ID */
+	timeout = id ? (js_io_speed * JS_SW_TIMEOUT) >> 10 : 0;	/* Set up global timeout for ID packet */
+	kick = id ? (js_io_speed * JS_SW_KICK) >> 10 : 0;	/* Set up kick timeout for ID packet */
+	bitout = start;
+	pending = 0;
+	sched = 0;
+
+        __save_flags(flags);					/* Quiet, please */
+        __cli();
+
+	outb(0xff, io);						/* Trigger */
+	v = inb(io);
+
+	do {
+		bitout--;
+		u = v;
+		v = inb(io);
+	} while (!(~v & u & 0x10) && (bitout > 0));		/* Wait for first falling edge on clock */
+
+	if (bitout > 0) bitout = strobe;			/* Extend time if not timed out */
+
+	while ((timeout > 0 || bitout > 0) && (i < length)) {
+
+		timeout--;
+		bitout--;					/* Decrement timers */
+		sched--;
+
+		u = v;
+		v = inb(io);
+
+		if ((~u & v & 0x10) && (bitout > 0)) {		/* Rising edge on clock - data bit */
+			if (i >= 0)				/* Want this data */
+				buf[i] = v >> 5;		/* Store it */
+			i++;					/* Advance index */
+			bitout = strobe;			/* Extend timeout for next bit */
+		} 
+
+		if (kick && (~v & u & 0x01)) {			/* Falling edge on axis */
+			sched = kick;				/* Schedule second trigger */
+			kick = 0;				/* Don't schedule next time on falling edge */
+			pending = 1;				/* Mark schedule */
+		} 
+
+		if (pending && sched < 0 && (i > -JS_SW_END)) {	/* Second trigger time */
+			outb(0xff, io);				/* Trigger */
+			bitout = start;				/* Long bit timeout */
+			pending = 0;				/* Unmark schedule */
+			timeout = 0;				/* Switch from global to bit timeouts */ 
+		}
+	}
+
+	__restore_flags(flags);					/* Done - relax */
+
+	return i;
+}
+
+/*
+ * js_sw_get_bits() and GB() compose bits from the triplet buffer into a __u64.
+ * Parameter 'pos' is bit number inside packet where to start at, 'num' is number
+ * of bits to be read, 'shift' is offset in the resulting __u64 to start at, bits
+ * is number of bits per triplet.
+ */
+
+#define GB(pos,num,shift) js_sw_get_bits(buf, pos, num, shift, info->bits)
+
+static __u64 js_sw_get_bits(unsigned char *buf, int pos, int num, char shift, char bits)
+
+{
+	__u64 data = 0;
+	int tri = pos % bits;						/* Start position */
+	int i   = pos / bits;
+	int bit = shift;
+
+	while (num--) {
+		data |= (__u64)((buf[i] >> tri++) & 1) << bit++;	/* Transfer bit */
+		if (tri == bits) {
+			i++;						/* Next triplet */
+			tri = 0;
+		}
+	}
+
+	return data;
+}
+
+/*
+ * js_sw_init_digital() initializes a SideWinder 3D Pro joystick
+ * into digital mode.
+ */
+
+static void js_sw_init_digital(int io)
+{
+	int seq[] = { 140, 140+726, 140+300, 0 };
+	unsigned long flags;
+	int i, t;
+
+        __save_flags(flags);
+        __cli();
+
+	i = 0;
+        do {
+                outb(0xff, io);					/* Trigger */
+		t = (js_io_speed * JS_SW_TIMEOUT) >> 10;
+		while ((inb(io) & 1) && t) t--;			/* Wait for axis to fall back to 0 */
+                udelay(seq[i]);					/* Delay magic time */
+        } while (seq[++i]);
+
+	outb(0xff, io);						/* Last trigger */
+
+	__restore_flags(flags);
+}
+
+/*
+ * js_sw_parity() computes parity of __u64
+ */
+
+static int js_sw_parity(__u64 t)
+{
+	int x = t ^ (t >> 32);
+	x ^= x >> 16;
+	x ^= x >> 8;
+	x ^= x >> 4;
+	x ^= x >> 2;
+	x ^= x >> 1;
+	return x & 1;
+}
+
+/*
+ * js_sw_ccheck() checks synchronization bits and computes checksum of nibbles.
+ */
+
+static int js_sw_check(__u64 t)
+{
+	char sum = 0;
+
+	if ((t & 0x8080808080808080ULL) ^ 0x80)			/* Sync */
+		return -1;
+
+	while (t) {						/* Sum */
+		sum += t & 0xf;
+		t >>= 4;
+	}
+
+	return sum & 0xf;
+}
+
+/*
+ * js_sw_parse() analyzes SideWinder joystick data, and writes the results into
+ * the axes and buttons arrays.
+ */
+
+static int js_sw_parse(unsigned char *buf, struct js_sw_info *info, int **axes, int **buttons)
+{
+	int hat, i;
+
+	switch (info->type) {
+
+		case JS_SW_TYPE_3DP:
+		case JS_SW_TYPE_F23:
+
+			if (js_sw_check(GB(0,64,0)) || (hat = GB(6,1,3) | GB(60,3,0))  > 8) return -1;
+
+			axes[0][0] = GB( 3,3,7) | GB(16,7,0);
+			axes[0][1] = GB( 0,3,7) | GB(24,7,0);
+			axes[0][2] = GB(35,2,7) | GB(40,7,0);
+			axes[0][3] = GB(32,3,7) | GB(48,7,0);
+			axes[0][4] = js_sw_hat_to_axis[hat].x;
+			axes[0][5] = js_sw_hat_to_axis[hat].y;
+			buttons[0][0] = ~(GB(37,1,8) | GB(38,1,7) | GB(8,7,0));
+
+			return 0;
+
+		case JS_SW_TYPE_GP:
+
+			for (i = 0; i < info->number * 15; i += 15) {
+
+				if (js_sw_parity(GB(i,15,0))) return -1;
+
+				axes[i][0] = GB(i+3,1,0) - GB(i+2,1,0);
+				axes[i][1] = GB(i+0,1,0) - GB(i+1,1,0);
+				buttons[i][0] = ~GB(i+4,10,0);
+
+			}
+
+			return 0;
+
+		case JS_SW_TYPE_PP:
+		case JS_SW_TYPE_FFP:
+
+			if (!js_sw_parity(GB(0,48,0)) || (hat = GB(42,4,0)) > 8) return -1;
+
+			axes[0][0] = GB( 9,10,0);
+			axes[0][1] = GB(19,10,0);
+			axes[0][2] = GB(29, 7,0);
+			axes[0][3] = GB(36, 6,0);
+			axes[0][4] = js_sw_hat_to_axis[hat].x;
+			axes[0][5] = js_sw_hat_to_axis[hat].y;
+			buttons[0][0] = ~GB(0,9,0);
+
+			return 0;
+
+		case JS_SW_TYPE_FSP:
+
+			if (!js_sw_parity(GB(0,43,0)) || (hat = GB(28,4,0)) > 8) return -1;
+
+			axes[0][0] = GB( 0,10,0);
+			axes[0][1] = GB(16,10,0);
+			axes[0][2] = GB(32, 6,0);
+			axes[0][3] = js_sw_hat_to_axis[hat].x;
+			axes[0][4] = js_sw_hat_to_axis[hat].y;
+			buttons[0][0] = ~(GB(10,6,0) | GB(26,2,6) | GB(38,2,8));
+
+			return 0;
+
+		case JS_SW_TYPE_FFW:
+
+			if (!js_sw_parity(GB(0,31,0))) return -1;
+
+			axes[0][0] = GB( 0,10,0);
+			axes[0][1] = GB(10, 6,0);
+			axes[0][2] = GB(16, 6,0);
+			buttons[0][0] = ~GB(22,8,0);
+
+			return 0;
+	}
+
+	return -1;
+}
+
+/*
+ * js_sw_read() reads SideWinder joystick data, and reinitializes
+ * the joystick in case of persistent problems. This is the function that is
+ * called from the generic code to poll the joystick.
+ */
+
+static int js_sw_read(void *xinfo, int **axes, int **buttons)
+{
+	struct js_sw_info *info = xinfo;
+	unsigned char buf[JS_SW_LENGTH];
+	int i;
+
+	i = js_sw_read_packet(info->io, buf, info->length, 0);
+
+	if (info->type <= JS_SW_TYPE_F23 && info->length == 66 && i != 66) {	/* Broken packet, try to fix */
+
+		if (i == 64 && !js_sw_check(js_sw_get_bits(buf,0,64,0,1))) {	/* Last init failed, 1 bit mode */
+			printk(KERN_WARNING "joy-sidewinder: Joystick in wrong mode on %#x"
+				" - going to reinitialize.\n", info->io);
+			info->fail = JS_SW_FAIL;				/* Reinitialize */
+			i = 128;						/* Bogus value */
+		}
+
+		if (i < 66 && GB(0,64,0) == GB(i*3-66,64,0))			/* 1 == 3 */
+			i = 66;							/* Everything is fine */
+
+		if (i < 66 && GB(0,64,0) == GB(66,64,0))			/* 1 == 2 */
+			i = 66;							/* Everything is fine */
+
+		if (i < 66 && GB(i*3-132,64,0) == GB(i*3-66,64,0)) {		/* 2 == 3 */
+			memmove(buf, buf + i - 22, 22);				/* Move data */
+			i = 66;							/* Carry on */
+		}
+	}
+
+	if (i == info->length && !js_sw_parse(buf, info, axes, buttons)) {	/* Parse data */
+
+		info->fail = 0;
+		info->ok++;
+
+		if (info->type <= JS_SW_TYPE_F23 && info->length == 66		/* Many packets OK */
+			&& info->ok > JS_SW_OK) {
+
+			printk(KERN_INFO "joy-sidewinder: No more trouble on %#x"
+				" - enabling optimization again.\n", info->io);
+			info->length = 22;
+		}
+
+		return 0;
+	}
+
+	info->ok = 0;
+	info->fail++;
+
+	if (info->type <= JS_SW_TYPE_F23 && info->length == 22			/* Consecutive bad packets */
+			&& info->fail > JS_SW_BAD) {
+
+		printk(KERN_INFO "joy-sidewinder: Many bit errors on %#x"
+			" - disabling optimization.\n", info->io);
+		info->length = 66;
+	}
+
+	if (info->fail < JS_SW_FAIL) return -1;					/* Not enough, don't reinitialize yet */
+
+	printk(KERN_WARNING "joy-sidewinder: Too many bit errors on %#x"
+		" - reinitializing joystick.\n", info->io);
+
+	if (!i && info->type <= JS_SW_TYPE_F23) {				/* 3D Pro can be in analog mode */
+		udelay(3 * JS_SW_TIMEOUT);
+		js_sw_init_digital(info->io);
+	}
+
+	udelay(JS_SW_TIMEOUT);
+	i = js_sw_read_packet(info->io, buf, JS_SW_LENGTH, 0);			/* Read normal data packet */
+	udelay(JS_SW_TIMEOUT);
+	js_sw_read_packet(info->io, buf, JS_SW_LENGTH, i);			/* Read ID packet, this initializes the stick */
+
+	info->fail = JS_SW_FAIL;
+	
+	return -1;
+}
+
+/*
+ * js_sw_open() is a callback from the file open routine.
+ */
+
+static int js_sw_open(struct js_dev *jd)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_sw_close() is a callback from the file release routine.
+ */
+
+static int js_sw_close(struct js_dev *jd)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_sw_init_corr() initializes the correction values for
+ * SideWinders.
+ */
+
+static void __init js_sw_init_corr(int num_axes, int type, int number, struct js_corr **corr)
+{
+	int i, j;
+
+	for (i = 0; i < number; i++) {
+
+		for (j = 0; j < num_axes; j++) {
+			corr[i][j].type = JS_CORR_BROKEN;
+			corr[i][j].prec = 8;
+			corr[i][j].coef[0] = 511 - 32;
+			corr[i][j].coef[1] = 512 + 32;
+			corr[i][j].coef[2] = (1 << 29) / (511 - 32);
+			corr[i][j].coef[3] = (1 << 29) / (511 - 32);
+		}
+
+		switch (type) {
+
+			case JS_SW_TYPE_3DP:
+			case JS_SW_TYPE_F23:
+
+				corr[i][2].type = JS_CORR_BROKEN;
+				corr[i][2].prec = 4;
+				corr[i][2].coef[0] = 255 - 16;
+				corr[i][2].coef[1] = 256 + 16;
+				corr[i][2].coef[2] = (1 << 29) / (255 - 16);
+				corr[i][2].coef[3] = (1 << 29) / (255 - 16);
+
+				j = 4;
+
+			break;
+
+			case JS_SW_TYPE_PP:
+			case JS_SW_TYPE_FFP:
+
+				corr[i][2].type = JS_CORR_BROKEN;
+				corr[i][2].prec = 1;
+				corr[i][2].coef[0] = 63 - 4;
+				corr[i][2].coef[1] = 64 + 4;
+				corr[i][2].coef[2] = (1 << 29) / (63 - 4);
+				corr[i][2].coef[3] = (1 << 29) / (63 - 4);
+
+				corr[i][3].type = JS_CORR_BROKEN;
+				corr[i][3].prec = 0;
+				corr[i][3].coef[0] = 31 - 2;
+				corr[i][3].coef[1] = 32 + 2;
+				corr[i][3].coef[2] = (1 << 29) / (31 - 2);
+				corr[i][3].coef[3] = (1 << 29) / (31 - 2);
+
+				j = 4;
+
+			break;
+
+			case JS_SW_TYPE_FFW:
+
+				corr[i][0].type = JS_CORR_BROKEN;
+				corr[i][0].prec = 2;
+				corr[i][0].coef[0] = 511 - 8;
+				corr[i][0].coef[1] = 512 + 8;
+				corr[i][0].coef[2] = (1 << 29) / (511 - 8);
+				corr[i][0].coef[3] = (1 << 29) / (511 - 8);
+
+				corr[i][1].type = JS_CORR_BROKEN;
+				corr[i][1].prec = 1;
+				corr[i][1].coef[0] = 63;
+				corr[i][1].coef[1] = 63;
+				corr[i][1].coef[2] = (1 << 29) / -63;
+				corr[i][1].coef[3] = (1 << 29) / -63;
+
+				corr[i][2].type = JS_CORR_BROKEN;
+				corr[i][2].prec = 1;
+				corr[i][2].coef[0] = 63;
+				corr[i][2].coef[1] = 63;
+				corr[i][2].coef[2] = (1 << 29) / -63;
+				corr[i][2].coef[3] = (1 << 29) / -63;
+
+				j = 3;
+
+			break;
+
+			case JS_SW_TYPE_FSP:
+				
+				corr[i][2].type = JS_CORR_BROKEN;
+				corr[i][2].prec = 0;
+				corr[i][2].coef[0] = 31 - 2;
+				corr[i][2].coef[1] = 32 + 2;
+				corr[i][2].coef[2] = (1 << 29) / (31 - 2);
+				corr[i][2].coef[3] = (1 << 29) / (31 - 2);
+
+				j = 3;
+
+			break;
+
+			default:
+
+				j = 0;
+
+		}
+
+		for (; j < num_axes; j++) {				/* Hats & other binary axes */
+			corr[i][j].type = JS_CORR_BROKEN;
+			corr[i][j].prec = 0;
+			corr[i][j].coef[0] = 0;
+			corr[i][j].coef[1] = 0;
+			corr[i][j].coef[2] = (1 << 29);
+			corr[i][j].coef[3] = (1 << 29);
+		}
+	}
+}
+
+/*
+ * js_sw_print_packet() prints the contents of a SideWinder packet.
+ */
+
+static void js_sw_print_packet(char *name, int length, unsigned char *buf, char bits)
+{
+	int i;
+
+	printk("joy-sidewinder: %s packet, %d bits. [", name, length);
+	for (i = (((length + 3) >> 2) - 1); i >= 0; i--)
+		printk("%x", (int)js_sw_get_bits(buf, i << 2, 4, 0, bits));
+	printk("]\n");
+}
+
+/*
+ * js_sw_3dp_id() translates the 3DP id into a human legible string.
+ * Unfortunately I don't know how to do this for the other SW types.
+ */
+
+static void js_sw_3dp_id(unsigned char *buf, char *comment)
+{
+	int i;
+	char pnp[8], rev[9];
+
+	for (i = 0; i < 7; i++)						/* ASCII PnP ID */
+		pnp[i] = js_sw_get_bits(buf, 24+8*i, 8, 0, 1);
+
+	for (i = 0; i < 8; i++)						/* ASCII firmware revision */
+		rev[i] = js_sw_get_bits(buf, 88+8*i, 8, 0, 1);
+
+	pnp[7] = rev[8] = 0;
+
+	sprintf(comment, " [PnP %d.%02d id %s rev %s]",
+		(int) (js_sw_get_bits(buf, 8, 6, 6, 1) |		/* Two 6-bit values */
+			js_sw_get_bits(buf, 16, 6, 0, 1)) / 100,
+		(int) (js_sw_get_bits(buf, 8, 6, 6, 1) |
+			js_sw_get_bits(buf, 16, 6, 0, 1)) % 100,
+		 pnp, rev);
+}
+
+/*
+ * js_sw_guess_mode() checks the upper two button bits for toggling -
+ * indication of that the joystick is in 3-bit mode. This is documented
+ * behavior for 3DP ID packet, and for example the FSP does this in
+ * normal packets instead. Fun ...
+ */
+
+static int js_sw_guess_mode(unsigned char *buf, int len)
+{
+	int i;
+	unsigned char xor = 0;
+	for (i = 1; i < len; i++) xor |= (buf[i - 1] ^ buf[i]) & 6;
+	return !!xor * 2 + 1;
+}
+
+/*
+ * js_sw_probe() probes for SideWinder type joysticks.
+ */
+
+static struct js_port __init *js_sw_probe(int io, struct js_port *port)
+{
+	struct js_sw_info info;
+	char *names[] = {NULL, "SideWinder 3D Pro", "Flight2000 F-23", "SideWinder GamePad", "SideWinder Precision Pro",
+			"SideWinder Force Feedback Pro", "SideWinder FreeStyle Pro", "SideWinder Force Feedback Wheel" };
+	char axes[] = { 0, 6, 6, 2, 6, 6, 5, 3 };
+	char buttons[] = { 0, 9, 9, 10, 9, 9, 10, 8 };
+	int i, j, k, l;
+	unsigned char buf[JS_SW_LENGTH];
+	unsigned char idbuf[JS_SW_LENGTH];
+	unsigned char u;
+	char comment[40];
+	char m;
+
+	comment[0] = 0;
+
+	if (check_region(io, 1)) return port;
+
+	outb(0xff,io);							/* Reasonable guess for mode */
+	u = inb(io);
+	udelay(JS_SW_TIMEOUT);
+	u = (inb(io) ^ u) & u;						/* Does the joystick see axis 2 ? */
+
+	if (~u & 1) return port;
+	m = 1 + ((u & 4) >> 1); 
+
+	i = js_sw_read_packet(io, buf, JS_SW_LENGTH, 0);		/* Read normal packet */
+	m |= js_sw_guess_mode(buf, i);					/* Data packet (1-bit) can carry mode info [FSP] */
+	udelay(JS_SW_TIMEOUT);
+
+	if (!i) {							/* No data. 3d Pro analog mode? */
+		js_sw_init_digital(io);					/* Switch to digital */
+		udelay(JS_SW_TIMEOUT);
+		i = js_sw_read_packet(io, buf, JS_SW_LENGTH, 0);	/* Retry reading packet */
+		udelay(JS_SW_TIMEOUT);
+		if (!i) return port;					/* No data -> FAIL */
+	}
+
+	j = js_sw_read_packet(io, idbuf, JS_SW_LENGTH, i);		/* Read ID. This initializes the stick */
+	m |= js_sw_guess_mode(idbuf, j);				/* ID packet should carry mode info [3DP] */
+
+	k = JS_SW_FAIL;							/* Try JS_SW_FAIL times */
+	l = 0;
+
+	do {
+		k--;
+		udelay(JS_SW_TIMEOUT);
+		i = js_sw_read_packet(io, buf, JS_SW_LENGTH, 0);	/* Read data packet */
+
+		if (i > l) {						/* Longer? As we can only lose bits, it makes */
+									/* no sense to try detection for a packet shorter */
+			l = i;						/* than the previous one */
+
+			info.number = 1;
+			info.io = io;
+			info.length = i;
+			info.bits = m;
+			info.fail = 0;
+			info.ok = 0;
+			info.type = 0;
+			info.strobe = JS_SW_STROBE;
+
+			switch (i * m) {
+				case 60:
+					info.number++;
+				case 45:				/* Ambiguous packet length */
+					if (j <= 40) {			/* ID length less or eq 40 -> FSP */	
+				case 43:
+						info.type = JS_SW_TYPE_FSP;
+						break;
+					}
+					info.number++;
+				case 30:
+					info.number++;
+				case 15:
+					info.type = JS_SW_TYPE_GP;
+					break;
+				case 33:
+				case 31:
+					info.type = JS_SW_TYPE_FFW;
+					break;
+				case 48:				/* Ambiguous */
+					if (j == 14) {			/* ID lenght 14 -> FFP */
+						info.type = JS_SW_TYPE_FFP;
+						sprintf(comment, "[AC %s]", js_sw_get_bits(idbuf,38,1,0,3) ? "off" : "on");
+					}
+					info.type = JS_SW_TYPE_PP;
+					break;
+				case 198:
+					info.length = 22;
+				case 64:
+					info.type = JS_SW_TYPE_3DP;
+					if (j == 160) js_sw_3dp_id(idbuf, comment);
+					break;
+			}
+		}
+
+	} while (k && !info.type);
+
+	if (!info.type) {
+		printk(KERN_WARNING "joy-sidewinder: unknown joystick device detected "
+			"(io=%#x), contact <vojtech@ucw.cz>\n", io);
+		js_sw_print_packet("ID", j * 3, idbuf, 3);
+		js_sw_print_packet("Data", i * m, buf, m);
+		return port;
+	}
+
+	request_region(io, 1, "joystick (sidewinder)");
+
+	port = js_register_port(port, &info, info.number, sizeof(struct js_sw_info), js_sw_read);
+
+	for (i = 0; i < info.number; i++)
+		printk(KERN_INFO "js%d: %s%s at %#x\n",
+			js_register_device(port, i, axes[info.type], buttons[info.type],
+				names[info.type], js_sw_open, js_sw_close), names[info.type], comment, io);
+
+	js_sw_init_corr(axes[info.type], info.type, info.number, port->corr);
+
+	return port;
+}
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_sw_init(void)
+#endif
+{
+	int *p;
+
+	for (p = js_sw_port_list; *p; p++) js_sw_port = js_sw_probe(*p, js_sw_port);
+	if (js_sw_port) return 0;
+
+#ifdef MODULE
+	printk(KERN_WARNING "joy-sidewinder: no joysticks found\n");
+#endif
+
+	return -ENODEV;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	int i;
+	struct js_sw_info *info;
+
+	while (js_sw_port) {
+		for (i = 0; i < js_sw_port->ndevs; i++)
+			if (js_sw_port->devs[i])
+				js_unregister_device(js_sw_port->devs[i]);
+		info = js_sw_port->info;
+		release_region(info->io, 1);
+		js_sw_port = js_unregister_port(js_sw_port);
+	}
+
+}
+#endif
diff -urN linux-2.0.36/drivers/char/joystick/joy-spaceorb.c linux-2.0.36-joystick/drivers/char/joystick/joy-spaceorb.c
--- linux-2.0.36/drivers/char/joystick/joy-spaceorb.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-spaceorb.c	Sat Feb 27 18:18:42 1999
@@ -0,0 +1,302 @@
+/*
+ *  joy-spaceorb.c  Version 0.1
+ *
+ *  Copyright (c) 1998 David Thompson
+ *  Copyright (c) 1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * the SpaceTec SpaceOrb 360 and SpaceBall Avenger 6dof controllers.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY ORBRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ *  Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/errno.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/tty.h>
+
+/*
+ * Constants.
+ */
+
+#define	N_JOYSTICK_ORB		15
+#define JS_ORB_MAX_LENGTH	64
+
+/*
+ * List of SpaceOrbs.
+ */
+
+static struct js_port* js_orb_port = NULL;
+
+/*
+ * Per-Orb data.
+ */
+
+struct js_orb_info {
+	struct tty_struct* tty;
+	struct js_port* port;
+	int idx;
+	unsigned char data[JS_ORB_MAX_LENGTH];
+	int js;
+	char used;
+};
+
+static unsigned char js_orb_xor[] = "SpaceWare";
+
+static unsigned char *js_orb_errors[] = { "EEPROM storing 0 failed", "Receive queue overflow", "Transmit queue timeout",
+		"Bad packet", "Power brown-out", "EEPROM checksum error", "Hardware fault" }; 
+
+/*
+ * js_orb_process_packet() decodes packets the driver receives from the
+ * SpaceOrb.
+ */
+
+static void js_orb_process_packet(struct js_orb_info* info)
+{
+	int i;
+	int **axes = info->port->axes;
+	int **buttons = info->port->buttons;
+	unsigned char *data = info->data;
+	unsigned char c = 0;
+
+	if (info->idx < 2) return;
+	for (i = 0; i < info->idx; i++) c ^= data[i];
+	if (c) return;
+
+	switch (info->data[0]) {
+
+		case 'R':				/* Reset packet */
+			info->data[info->idx - 1] = 0;
+			for (i = 1; i < info->idx && info->data[i] == ' '; i++);
+			printk(KERN_INFO "js%d: SpaceOrb 360 [%s] on %s%d\n",
+				info->js, info->data + i, info->tty->driver.name,
+				MINOR(info->tty->device) - info->tty->driver.minor_start);
+			break;
+
+		case 'D':				/* Ball + button data */
+			if (info->idx != 12) return;
+			if (!info->port->devs[0]) return;
+			for (i = 0; i < 9; i++) info->data[i+2] ^= js_orb_xor[i]; 
+			axes[0][0] = ( data[2]         << 3) | (data[ 3] >> 4);
+			axes[0][1] = ((data[3] & 0x0f) << 6) | (data[ 4] >> 1);
+			axes[0][2] = ((data[4] & 0x01) << 9) | (data[ 5] << 2) | (data[4] >> 5);
+			axes[0][3] = ((data[6] & 0x1f) << 5) | (data[ 7] >> 2);
+			axes[0][4] = ((data[7] & 0x03) << 8) | (data[ 8] << 1) | (data[7] >> 6);
+			axes[0][5] = ((data[9] & 0x3f) << 4) | (data[10] >> 3);
+			for(i = 0; i < 6; i ++) if (axes[0][i] & 0x200) axes[0][i] -= 1024;
+			buttons[0][0] = data[1];
+			break;
+
+		case 'K':				/* Button data */
+			if (info->idx != 5) return;
+			if (!info->port->devs[0]) return;
+			buttons[0][0] = data[2];
+			break;
+
+		case 'E':				/* Error packet */
+			if (info->idx != 4) return;
+			printk(KERN_ERR "joy-spaceorb: Device error. [ ");
+			for (i = 0; i < 7; i++)
+				if (data[1] & (1 << i))
+					printk("%s ", js_orb_errors[i]);
+			printk("]\n");
+			break;
+
+		case 'N':				/* Null region */
+			if (info->idx != 3) return;
+			break;
+
+		case 'P':				/* Pulse (update) speed */
+			if (info->idx != 4) return;
+			break;
+
+		default:
+			printk("joy-spaceorb: Unknown packet %d length %d:", data[0], info->idx);
+			for (i = 0; i < info->idx; i++) printk(" %02x", data[i]);
+			printk("\n");
+			return;
+	}
+}
+
+/*
+ * js_orb_open() is a callback from the joystick device open routine.
+ */
+
+static int js_orb_open(struct js_dev *jd)
+{
+	struct js_orb_info *info = jd->port->info;
+	info->used++;
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_orb_close() is a callback from the joystick device release routine.
+ */
+
+static int js_orb_close(struct js_dev *jd)
+{
+	struct js_orb_info *info = jd->port->info;
+	if (!--info->used) {
+		js_unregister_device(jd->port->devs[0]);
+		js_orb_port = js_unregister_port(jd->port);
+	}
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_orb_init_corr() initializes the correction values for the SpaceOrb.
+ */
+
+static void __init js_orb_init_corr(struct js_corr **corr)
+{
+	int j;
+
+	for (j = 0; j < 6; j++) {
+		corr[0][j].type = JS_CORR_BROKEN;
+		corr[0][j].prec = 0;
+		corr[0][j].coef[0] = 0 ;
+		corr[0][j].coef[1] = 0 ;
+		corr[0][j].coef[2] = (1 << 29) / 511;
+		corr[0][j].coef[3] = (1 << 29) / 511;
+	}
+}
+
+/*
+ * js_orb_ldisc_open() is the routine that is called upon setting our line
+ * discipline on a tty.
+ */
+
+static int js_orb_ldisc_open(struct tty_struct *tty)
+{
+	struct js_orb_info iniinfo;
+	struct js_orb_info *info = &iniinfo;
+
+	info->tty = tty;
+	info->idx = 0;
+	info->used = 1;
+
+	js_orb_port = js_register_port(js_orb_port, info, 1, sizeof(struct js_orb_info), NULL);
+	
+	info = js_orb_port->info;
+	info->port = js_orb_port;
+	tty->disc_data = info;
+
+	info->js = js_register_device(js_orb_port, 0, 6, 7, "SpaceOrb 360", js_orb_open, js_orb_close);
+
+	js_orb_init_corr(js_orb_port->corr);
+
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+/*
+ * js_orb_ldisc_close() is the opposite of js_orb_ldisc_open()
+ */
+
+static void js_orb_ldisc_close(struct tty_struct *tty)
+{
+	struct js_orb_info* info = (struct js_orb_info*) tty->disc_data;
+	if (!--info->used) {
+		js_unregister_device(info->port->devs[0]);
+		js_orb_port = js_unregister_port(info->port);
+	}
+	MOD_DEC_USE_COUNT;
+}
+
+/*
+ * js_orb_ldisc_receive() is called by the low level driver when characters
+ * are ready for us. We then buffer them for further processing, or call the
+ * packet processing routine.
+ */
+
+static void js_orb_ldisc_receive(struct tty_struct *tty, const unsigned char *cp, char *fp, int count)
+{
+	struct js_orb_info* info = (struct js_orb_info*) tty->disc_data;
+	int i;
+
+	for (i = 0; i < count; i++) {
+		if (~cp[i] & 0x80) {
+			if (info->idx) js_orb_process_packet(info);
+			info->idx = 0;
+		}
+		if (info->idx < JS_ORB_MAX_LENGTH)
+			info->data[info->idx++] = cp[i] & 0x7f;
+	}
+}
+
+/*
+ * js_orb_ldisc_room() reports how much room we do have for receiving data.
+ * Although we in fact have infinite room, we need to specify some value
+ * here, so why not the size of our packet buffer. It's big anyway.
+ */
+
+static int js_orb_ldisc_room(struct tty_struct *tty)
+{
+	return JS_ORB_MAX_LENGTH;
+}
+
+/*
+ * The line discipline structure.
+ */
+
+static struct tty_ldisc js_orb_ldisc = {
+	magic:		TTY_LDISC_MAGIC,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+	name:		"spaceorb",
+#endif
+	open:		js_orb_ldisc_open,
+	close:		js_orb_ldisc_close,
+	receive_buf:	js_orb_ldisc_receive,
+	receive_room:	js_orb_ldisc_room,
+};
+
+/*
+ * The functions for inserting/removing us as a module.
+ */
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_orb_init(void)
+#endif
+{
+        if (tty_register_ldisc(N_JOYSTICK_ORB, &js_orb_ldisc)) {
+                printk(KERN_ERR "joy-spaceorb: Error registering line discipline.\n");
+		return -ENODEV;
+	}
+
+	return  0;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	tty_register_ldisc(N_JOYSTICK_ORB, NULL);
+}
+#endif
diff -urN linux-2.0.36/drivers/char/joystick/joy-thrustmaster.c linux-2.0.36-joystick/drivers/char/joystick/joy-thrustmaster.c
--- linux-2.0.36/drivers/char/joystick/joy-thrustmaster.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-thrustmaster.c	Mon Mar  8 16:18:36 1999
@@ -0,0 +1,292 @@
+/*
+ *  joy-thrustmaster.c  Version 1.2
+ *
+ *  Copyright (c) 1998-1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * ThrustMaster DirectConnect (BSP) joystick family.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+
+#define JS_TM_MAX_START		400
+#define JS_TM_MAX_STROBE	45
+#define JS_TM_MAX_LENGTH	13
+
+#define JS_TM_MODE_M3DI		1
+#define JS_TM_MODE_3DRP		3
+
+#define JS_TM_MODE_MAX		4	/* Last mode + 1 */
+
+#define JS_TM_BYTE_ID		10
+#define JS_TM_BYTE_REV		11
+#define JS_TM_BYTE_DEF		12
+
+static int js_tm_port_list[] __initdata = {0x201, 0};
+static struct js_port* js_tm_port __initdata = NULL;
+
+static unsigned char js_tm_byte_a[16] = { 0, 1, 3, 4, 6, 7 };
+static unsigned char js_tm_byte_d[16] = { 2, 5, 8, 9 };
+
+struct js_tm_info {
+	int io;
+	unsigned char mode;
+};
+
+/*
+ * js_tm_read_packet() reads a ThrustMaster packet.
+ */
+
+static int js_tm_read_packet(int io, unsigned char *data)
+{
+	unsigned int t;
+	unsigned char u, v, error;
+	int i, j;
+	unsigned long flags;
+
+	int start = (js_io_speed * JS_TM_MAX_START) >> 10;
+	int strobe = (js_io_speed * JS_TM_MAX_STROBE) >> 10;
+
+	error = 0;
+	i = j = 0;
+
+	__save_flags(flags);
+	__cli();
+	outb(0xff,io);
+	
+	v = inb(io) >> 4;
+	t = start;
+
+	do {
+		t--;
+		u = v; v = inb(io) >> 4;
+		if (~v & u & 2) {
+			if (j) {
+				if (j < 9) {				/* Data bit */
+					data[i] |= (~v & 1) << (j - 1);
+					j++;
+				} else {				/* Stop bit */
+					error |= v & 1;
+					j = 0;
+					i++;
+				}
+			} else {					/* Start bit */
+				data[i] = 0;
+				error |= ~v & 1;
+				j++;
+			}
+			t = strobe;
+		}
+	} while (!error && i < JS_TM_MAX_LENGTH && t > 0);
+
+	__restore_flags(flags);
+
+	return -(i != JS_TM_MAX_LENGTH);
+}
+
+/*
+ * js_tm_read() reads and analyzes ThrustMaster joystick data.
+ */
+
+static int js_tm_read(void *xinfo, int **axes, int **buttons)
+{
+	struct js_tm_info *info = xinfo;
+	unsigned char data[JS_TM_MAX_LENGTH];
+	int i;
+
+	if (js_tm_read_packet(info->io, data)) return -1;
+	if (data[JS_TM_BYTE_ID] != info->mode) return -1;
+
+	for (i = 0; i < data[JS_TM_BYTE_DEF] >> 4; i++) axes[0][i] = data[js_tm_byte_a[i]];
+
+	switch (info->mode) {
+
+		case JS_TM_MODE_M3DI:
+
+			axes[0][4] = ((data[js_tm_byte_d[0]] >> 3) & 1) - ((data[js_tm_byte_d[0]] >> 1) & 1);
+			axes[0][5] = ((data[js_tm_byte_d[0]] >> 2) & 1) - ( data[js_tm_byte_d[0]]       & 1);
+
+			buttons[0][0] = ((data[js_tm_byte_d[0]] >> 6) & 0x01) | ((data[js_tm_byte_d[0]] >> 3) & 0x06)
+				      | ((data[js_tm_byte_d[0]] >> 4) & 0x08) | ((data[js_tm_byte_d[1]] >> 2) & 0x30);
+
+			return 0;
+
+		case JS_TM_MODE_3DRP:
+
+			buttons[0][0] = (data[js_tm_byte_d[0]] & 0x3f) | ((data[js_tm_byte_d[1]] << 6) & 0xc0)
+				      | (( ((int) data[js_tm_byte_d[0]]) << 2) & 0x300);
+
+			return 0;
+
+		default:
+
+			buttons[0][0] = 0;
+
+			for (i = 0; i < (data[JS_TM_BYTE_DEF] & 0xf); i++)
+				buttons[0][0] |= ((int) data[js_tm_byte_d[i]]) << (i << 3);
+
+			return 0;
+
+	}
+
+	return -1;
+}
+
+/*
+ * js_tm_open() is a callback from the file open routine.
+ */
+
+static int js_tm_open(struct js_dev *jd)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_tm_close() is a callback from the file release routine.
+ */
+
+static int js_tm_close(struct js_dev *jd)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_tm_init_corr() initializes the correction values for
+ * ThrustMaster joysticks.
+ */
+
+static void __init js_tm_init_corr(int num_axes, int mode, int **axes, struct js_corr **corr)
+{
+	int j;
+
+	for (j = 0; j < num_axes; j++) {
+		corr[0][j].type = JS_CORR_BROKEN;
+		corr[0][j].prec = 0;
+		corr[0][j].coef[0] = 127 - 2;
+		corr[0][j].coef[1] = 128 + 2;
+		corr[0][j].coef[2] = (1 << 29) / (127 - 4);
+		corr[0][j].coef[3] = (1 << 29) / (127 - 4);
+	}
+
+	switch (mode) {
+		case JS_TM_MODE_M3DI: j = 4; break;
+		case JS_TM_MODE_3DRP: j = 2; break;
+		default:	      j = 0; break;
+	}
+
+	for (; j < num_axes; j++) {
+		corr[0][j].type = JS_CORR_BROKEN;
+		corr[0][j].prec = 0;
+		corr[0][j].coef[0] = 0;
+		corr[0][j].coef[1] = 0;
+		corr[0][j].coef[2] = (1 << 29);
+		corr[0][j].coef[3] = (1 << 29);
+	}
+
+}
+
+/*
+ * js_tm_probe() probes for ThrustMaster type joysticks.
+ */
+
+static struct js_port __init *js_tm_probe(int io, struct js_port *port)
+{
+	struct js_tm_info info;
+	char *names[JS_TM_MODE_MAX] = { NULL, "ThrustMaster Millenium 3D Inceptor", NULL, "ThrustMaster Rage 3D Gamepad" };
+	char axes[JS_TM_MODE_MAX] = { 0, 6, 0, 2 };
+	char buttons[JS_TM_MODE_MAX] = { 0, 6, 0, 10 };
+	char name[64];
+	unsigned char data[JS_TM_MAX_LENGTH];
+	unsigned char a, b;
+
+	if (check_region(io, 1)) return port;
+
+	if(js_tm_read_packet(io, data)) return port;
+
+	info.io = io;
+	info.mode = data[JS_TM_BYTE_ID];
+
+	if (!info.mode) return port;
+
+	if (info.mode >= JS_TM_MODE_MAX || !names[info.mode]) {
+		a = data[JS_TM_BYTE_DEF] >> 4;
+		b = (data[JS_TM_BYTE_DEF] & 0xf) << 3;
+		sprintf(name, "Unknown %d-axis, %d-button TM device %d", a, b, info.mode);
+	} else {
+		sprintf(name, names[info.mode]);
+		a = axes[info.mode];
+		b = buttons[info.mode];
+	}
+
+	request_region(io, 1, "joystick (thrustmaster)");
+	port = js_register_port(port, &info, 1, sizeof(struct js_tm_info), js_tm_read);
+	printk(KERN_INFO "js%d: %s revision %d at %#x\n",
+		js_register_device(port, 0, a, b, name, js_tm_open, js_tm_close), name, data[JS_TM_BYTE_REV], io);
+	js_tm_init_corr(a, info.mode, port->axes, port->corr);
+
+	return port;
+}
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_tm_init(void)
+#endif
+{
+	int *p;
+
+	for (p = js_tm_port_list; *p; p++) js_tm_port = js_tm_probe(*p, js_tm_port);
+	if (js_tm_port) return 0;
+
+#ifdef MODULE
+	printk(KERN_WARNING "joy-thrustmaster: no joysticks found\n");
+#endif
+
+	return -ENODEV;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	struct js_tm_info *info;
+
+	while (js_tm_port) {
+		js_unregister_device(js_tm_port->devs[0]);
+		info = js_tm_port->info;
+		release_region(info->io, 1);
+		js_tm_port = js_unregister_port(js_tm_port);
+	}
+}
+#endif
diff -urN linux-2.0.36/drivers/char/joystick/joy-turbografx.c linux-2.0.36-joystick/drivers/char/joystick/joy-turbografx.c
--- linux-2.0.36/drivers/char/joystick/joy-turbografx.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-turbografx.c	Mon Mar  8 16:18:59 1999
@@ -0,0 +1,281 @@
+/*
+ *  joy-turbografx.c  Version 1.2
+ *
+ *  Copyright (c) 1998-1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * Steffen Schwenke's <schwenke@burg-halle.de> TurboGraFX parallel port
+ * interface.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+
+
+MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
+MODULE_PARM(js_tg, "2-8i");
+MODULE_PARM(js_tg_2, "2-8i");
+MODULE_PARM(js_tg_3, "2-8i");
+
+#define JS_TG_BUTTON1	0x08
+#define JS_TG_UP	0x10
+#define JS_TG_DOWN	0x20	
+#define JS_TG_LEFT	0x40
+#define JS_TG_RIGHT	0x80
+
+#define JS_TG_BUTTON2	0x02
+#define JS_TG_BUTTON3	0x04
+#define JS_TG_BUTTON4	0x01
+#define JS_TG_BUTTON5	0x08
+
+static struct js_port* js_tg_port __initdata = NULL;
+
+static int js_tg[] __initdata = { -1, 0, 0, 0, 0, 0, 0, 0 };
+static int js_tg_2[] __initdata = { -1, 0, 0, 0, 0, 0, 0, 0 };
+static int js_tg_3[] __initdata = { -1, 0, 0, 0, 0, 0, 0, 0 };
+
+struct js_tg_info {
+#ifdef USE_PARPORT
+	struct pardevice *port;	/* parport device */
+#else
+	int port;		/* hw port */
+#endif
+	int sticks;		/* joysticks connected */
+};
+
+/*
+ * js_tg_read() reads and analyzes tg joystick data.
+ */
+
+static int js_tg_read(void *xinfo, int **axes, int **buttons)
+{
+	struct js_tg_info *info = xinfo;
+	int data1, data2, i;
+
+	for (i = 0; i < 7; i++)
+		if ((info->sticks >> i) & 1) {
+
+		JS_PAR_DATA_OUT(~(1 << i), info->port);
+		data1 = JS_PAR_STATUS(info->port) ^ ~JS_PAR_STATUS_INVERT;
+		data2 = JS_PAR_CTRL_IN(info->port) ^ JS_PAR_CTRL_INVERT;
+
+		axes[i][0] = ((data1 & JS_TG_RIGHT) ? 1 : 0) - ((data1 & JS_TG_LEFT) ? 1 : 0);
+		axes[i][1] = ((data1 & JS_TG_DOWN ) ? 1 : 0) - ((data1 & JS_TG_UP  ) ? 1 : 0);
+
+		buttons[i][0] = ((data1 & JS_TG_BUTTON1) ? 0x01 : 0) | ((data2 & JS_TG_BUTTON2) ? 0x02 : 0)
+			      | ((data2 & JS_TG_BUTTON3) ? 0x04 : 0) | ((data2 & JS_TG_BUTTON4) ? 0x08 : 0)
+			      | ((data2 & JS_TG_BUTTON5) ? 0x10 : 0);
+
+	}
+
+	return 0;
+}
+
+/*
+ * open callback: claim parport.
+ */
+
+int js_tg_open(struct js_dev *dev)
+{
+	struct js_tg_info *info = dev->port->info;
+
+	if (!MOD_IN_USE) {
+#ifdef USE_PARPORT
+		if (parport_claim(info->port)) return -EBUSY; 
+#endif
+		JS_PAR_CTRL_OUT(0x04, info->port);
+	}
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * close callback: release parport
+ */
+
+int js_tg_close(struct js_dev *dev)
+{
+        struct js_tg_info *info = dev->port->info;
+
+        MOD_DEC_USE_COUNT;
+	if (!MOD_IN_USE) {
+		JS_PAR_CTRL_OUT(0x00, info->port);
+#ifdef USE_PARPORT
+        	parport_release(info->port);
+#endif
+	}
+        return 0;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	struct js_tg_info *info;
+	int i;
+
+	while (js_tg_port) {
+		for (i = 0; i < js_tg_port->ndevs; i++)
+			if (js_tg_port->devs[i])
+				js_unregister_device(js_tg_port->devs[i]);
+		info = js_tg_port->info;
+#ifdef USE_PARPORT
+		parport_unregister_device(info->port);
+#else
+		release_region(info->port, 3);
+#endif
+		js_tg_port = js_unregister_port(js_tg_port);
+	}
+}
+#endif
+
+/*
+ * js_tg_init_corr() initializes correction values of
+ * tg gamepads.
+ */
+
+static void __init js_tg_init_corr(int sticks, struct js_corr **corr)
+{
+	int i, j;
+
+	for (i = 0; i < 7; i++)
+		if ((sticks >> i) & 1)
+			for (j = 0; j < 2; j++) {
+				corr[i][j].type = JS_CORR_BROKEN;
+				corr[i][j].prec = 0;
+				corr[i][j].coef[0] = 0;
+				corr[i][j].coef[1] = 0;
+				corr[i][j].coef[2] = (1 << 29);
+				corr[i][j].coef[3] = (1 << 29);
+			}
+}
+
+/*
+ * js_tg_probe() probes for tg gamepads.
+ */
+
+static struct js_port __init *js_tg_probe(int *config, struct js_port *port)
+{
+	struct js_tg_info iniinfo;
+	struct js_tg_info *info = &iniinfo;
+	int i;
+
+	if (config[0] < 0) return port;
+
+#ifdef USE_PARPORT
+	{
+		struct parport *pp;
+
+		if (config[0] > 0x10)
+			for (pp=parport_enumerate(); pp && (pp->base!=config[0]); pp=pp->next);
+		else
+			for (pp=parport_enumerate(); pp && (config[0]>0); pp=pp->next) config[0]--;
+
+		if (!pp) {
+			printk(KERN_ERR "joy-tg: no such parport\n");
+			return port;
+		}
+
+		info->port = parport_register_device(pp, "joystick (turbografx)", NULL, NULL, NULL, PARPORT_DEV_EXCL, NULL);
+		if (!info->port)
+			return port;
+	}
+#else
+	info->port = config[0];
+	if (check_region(info->port, 3)) return port;
+	request_region(info->port, 3, "joystick (turbografx)");
+#endif
+
+	port = js_register_port(port, info, 7, sizeof(struct js_tg_info), js_tg_read);
+	info = port->info;
+
+	info->sticks = 0;
+
+	for (i = 0; i < 7; i++)
+		if (config[i+1] > 0 && config[i+1] < 6) {
+#ifdef USE_PARPORT
+			printk(KERN_INFO "js%d: Multisystem joystick on %s\n",
+				js_register_device(port, i, 2, config[i+1], "Multisystem joystick", js_tg_open, js_tg_close),
+				info->port->port->name);
+#else
+			printk(KERN_INFO "js%d: Multisystem joystick at %#x\n",
+				js_register_device(port, i, 2, config[i+1], "Multisystem joystick", js_tg_open, js_tg_close),
+				info->port);
+#endif
+			info->sticks |= (1 << i);
+		}
+
+        if (!info->sticks) {
+#ifdef USE_PARPORT
+		parport_unregister_device(info->port);
+#else
+		release_region(info->port, 3);
+#endif
+		return port;
+        }
+		
+	js_tg_init_corr(info->sticks, port->corr);
+
+	return port;
+}
+
+#ifndef MODULE
+void __init js_tg_setup(char *str, int *ints)
+{
+	int i;
+
+	if (!strcmp(str,"js_tg"))
+		for (i = 0; i <= ints[0] && i < 2; i++) js_tg[i] = ints[i+1];
+	if (!strcmp(str,"js_tg_2"))
+		for (i = 0; i <= ints[0] && i < 2; i++) js_tg_2[i] = ints[i+1];
+	if (!strcmp(str,"js_tg_3"))
+		for (i = 0; i <= ints[0] && i < 2; i++) js_tg_3[i] = ints[i+1];
+
+}
+#endif
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_tg_init(void)
+#endif
+{
+	js_tg_port = js_tg_probe(js_tg, js_tg_port);
+	js_tg_port = js_tg_probe(js_tg_2, js_tg_port);
+	js_tg_port = js_tg_probe(js_tg_3, js_tg_port);
+
+	if (js_tg_port) return 0;
+
+#ifdef MODULE
+	printk(KERN_WARNING "joy-tg: no joysticks specified\n");
+#endif
+	return -ENODEV;
+}
diff -urN linux-2.0.36/drivers/char/joystick/joy-warrior.c linux-2.0.36-joystick/drivers/char/joystick/joy-warrior.c
--- linux-2.0.36/drivers/char/joystick/joy-warrior.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joy-warrior.c	Sun Feb 28 01:28:47 1999
@@ -0,0 +1,315 @@
+/*
+ *  joy-warrior.c  Version 0.1
+ *
+ *  Copyright (c) 1998 David Thompson
+ *  Copyright (c) 1999 Vojtech Pavlik
+ */
+
+/*
+ * This is a module for the Linux joystick driver, supporting
+ * the Logitech WingMan Warrior joystick.
+ */
+
+/*
+ * This program is free warftware; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ *  Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/errno.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/tty.h>
+
+/*
+ * Constants.
+ */
+
+#define	N_JOYSTICK_WAR		13
+#define JS_WAR_MAX_LENGTH	16
+
+/*
+ * List of Warriors.
+ */
+
+static struct js_port* js_war_port = NULL;
+
+static char js_war_lengths[] = { 0, 4, 12, 3, 4, 4, 0, 0 }; 
+
+/*
+ * Per-Warrior data.
+ */
+
+struct js_war_info {
+	struct tty_struct* tty;
+	struct js_port* port;
+	int idx;
+	int len;
+	unsigned char data[JS_WAR_MAX_LENGTH];
+	char used;
+};
+
+/*
+ * js_war_process_packet() decodes packets the driver receives from the
+ * Warrior. It updates the data accordingly.
+ */
+
+static void js_war_process_packet(struct js_war_info* info)
+{
+	int **axes = info->port->axes;
+	int **buttons = info->port->buttons;
+	unsigned char *data = info->data;
+	int i;
+
+	if (!info->idx) return;
+
+	switch ((data[0] >> 4) & 7) {
+
+		case 1:					/* Button data */
+			if (!info->port->devs[0]) return;
+			buttons[0][0] = ((data[3] & 0xa) >> 1) | ((data[3] & 0x5) << 1);
+			return;
+		case 2:					/* Static status (Send !S to get one) */
+#if 0
+			printk("joy-warrior: Static status:");
+			for (i = 0; i < 12; i++)
+				printk(" %02x", info->data[i]);
+			printk("\n");
+#endif
+			return;
+		case 3:					/* XY-axis info->data */
+			if (!info->port->devs[0]) return;
+			axes[0][0] = ((data[0] & 8) << 5) - (data[2] | ((data[0] & 4) << 5));
+			axes[0][1] = (data[1] | ((data[0] & 1) << 7)) - ((data[0] & 2) << 7);
+			return;
+			break;
+		case 4:					/* Dynamic status */
+#if 0
+			printk("joy-warrior: Dynamic status:");
+			for (i = 0; i < 4; i++)
+				printk(" %02x", info->data[i]);
+			printk("\n");
+#endif
+			return;
+		case 5:					/* Throttle, spinner, hat info->data */
+			if (!info->port->devs[0]) return;
+			axes[0][2] = (data[1] | ((data[0] & 1) << 7)) - ((data[0] & 2) << 7);
+			axes[0][3] = (data[3] & 2 ? 1 : 0) - (info->data[3] & 1 ? 1 : 0);
+			axes[0][4] = (data[3] & 8 ? 1 : 0) - (info->data[3] & 4 ? 1 : 0);
+			axes[0][5] = (data[2] | ((data[0] & 4) << 5)) - ((data[0] & 8) << 5);
+			return;
+		default:
+			printk("joy-warrior: Unknown packet %d length %d:", (data[0] >> 4) & 7, info->idx);
+			for (i = 0; i < info->idx; i++)
+				printk(" %02x", data[i]);
+			printk("\n");
+			return;
+	}
+}
+
+/*
+ * js_war_open() is a callback from the joystick device open routine.
+ */
+
+static int js_war_open(struct js_dev *jd)
+{
+	struct js_war_info *info = jd->port->info;
+	info->used++;
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_war_close() is a callback from the joystick device release routine.
+ */
+
+static int js_war_close(struct js_dev *jd)
+{
+	struct js_war_info *info = jd->port->info;
+	if (!--info->used) {
+		js_unregister_device(jd->port->devs[0]);
+		js_war_port = js_unregister_port(jd->port);
+	}
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * js_war_init_corr() initializes the correction values for the Warrior.
+ */
+
+static void __init js_war_init_corr(struct js_corr **corr)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		corr[0][i].type = JS_CORR_BROKEN;
+		corr[0][i].prec = 0;
+		corr[0][i].coef[0] = -8;
+		corr[0][i].coef[1] = 8;
+		corr[0][i].coef[2] = (1 << 29) / (128 - 64);
+		corr[0][i].coef[3] = (1 << 29) / (128 - 64);
+	}
+
+	corr[0][2].coef[2] = (1 << 29) / (128 - 16);
+	corr[0][2].coef[3] = (1 << 29) / (128 - 16);
+
+	for (i = 3; i < 5; i++) {
+		corr[0][i].coef[0] = 0;
+		corr[0][i].coef[1] = 0;
+		corr[0][i].coef[2] = (1 << 29);
+		corr[0][i].coef[3] = (1 << 29);
+	}
+
+	corr[0][5].prec = -1;
+	corr[0][5].coef[0] = 0;
+	corr[0][5].coef[1] = 0;
+	corr[0][5].coef[2] = (1 << 29) / 128;
+	corr[0][5].coef[3] = (1 << 29) / 128;
+}
+
+/*
+ * js_war_ldisc_open() is the routine that is called upon setting our line
+ * discipline on a tty.
+ */
+
+static int js_war_ldisc_open(struct tty_struct *tty)
+{
+	struct js_war_info iniinfo;
+	struct js_war_info *info = &iniinfo;
+
+	info->tty = tty;
+	info->idx = 0;
+	info->len = 0;
+	info->used = 0;
+
+	js_war_port = js_register_port(js_war_port, info, 1, sizeof(struct js_war_info), NULL);
+
+	info = js_war_port->info;
+	info->port = js_war_port;
+	tty->disc_data = info;
+
+	printk(KERN_INFO "js%d: WingMan Warrior on %s%d\n",
+		js_register_device(js_war_port, 0, 6, 4, "WingMan Warrior", js_war_open, js_war_close),
+		tty->driver.name, MINOR(tty->device) - tty->driver.minor_start);
+
+	js_war_init_corr(js_war_port->corr);
+
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+/*
+ * js_war_ldisc_close() is the opposite of js_war_ldisc_open()
+ */
+
+static void js_war_ldisc_close(struct tty_struct *tty)
+{
+	struct js_war_info* info = (struct js_war_info*) tty->disc_data;
+	if (!--info->used) {
+		js_unregister_device(info->port->devs[0]);
+		js_war_port = js_unregister_port(info->port);
+	}
+	MOD_DEC_USE_COUNT;
+}
+
+/*
+ * js_war_ldisc_receive() is called by the low level driver when characters
+ * are ready for us. We then buffer them for further processing, or call the
+ * packet processing routine.
+ */
+
+static void js_war_ldisc_receive(struct tty_struct *tty, const unsigned char *cp, char *fp, int count)
+{
+	struct js_war_info* info = (struct js_war_info*) tty->disc_data;
+	int i;
+
+	for (i = 0; i < count; i++) {
+		if (cp[i] & 0x80) {
+			if (info->idx)
+				js_war_process_packet(info);
+			info->idx = 0;
+			info->len = js_war_lengths[(cp[i] >> 4) & 7];
+		}
+
+		if (info->idx < JS_WAR_MAX_LENGTH)
+			info->data[info->idx++] = cp[i];
+
+		if (info->idx == info->len) {
+			if (info->idx)
+				js_war_process_packet(info);	
+			info->idx = 0;
+			info->len = 0;
+		}
+	}
+}
+
+/*
+ * js_war_ldisc_room() reports how much room we do have for receiving data.
+ * Although we in fact have infinite room, we need to specify some value
+ * here, so why not the size of our packet buffer. It's big anyway.
+ */
+
+static int js_war_ldisc_room(struct tty_struct *tty)
+{
+	return JS_WAR_MAX_LENGTH;
+}
+
+/*
+ * The line discipline structure.
+ */
+
+static struct tty_ldisc js_war_ldisc = {
+        magic:          TTY_LDISC_MAGIC,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+        name:           "warrior",
+#endif
+	open:		js_war_ldisc_open,
+	close:		js_war_ldisc_close,
+	receive_buf:	js_war_ldisc_receive,
+	receive_room:	js_war_ldisc_room,
+};
+
+/*
+ * The functions for inserting/removing us as a module.
+ */
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_war_init(void)
+#endif
+{
+        if (tty_register_ldisc(N_JOYSTICK_WAR, &js_war_ldisc)) {
+                printk(KERN_ERR "joy-warrior: Error registering line discipline.\n");
+		return -ENODEV;
+	}
+
+	return  0;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	tty_register_ldisc(N_JOYSTICK_WAR, NULL);
+}
+#endif
diff -urN linux-2.0.36/drivers/char/joystick/joystick.c linux-2.0.36-joystick/drivers/char/joystick/joystick.c
--- linux-2.0.36/drivers/char/joystick/joystick.c	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/drivers/char/joystick/joystick.c	Mon Mar  8 15:39:31 1999
@@ -0,0 +1,1052 @@
+/*
+ *  joystick.c  Version 1.2
+ *
+ *  Copyright (c) 1996-1999 Vojtech Pavlik
+ */
+
+/*
+ * This is the main joystick driver for Linux. It doesn't support any
+ * devices directly, rather is lets you use sub-modules to do that job. See
+ * Documentation/joystick.txt for more info.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/joystick.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/malloc.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+#include <asm/spinlock.h>
+#include <linux/poll.h>
+#endif
+
+/*
+ * Configurable parameters.
+ */
+
+#define JS_REFRESH_TIME		HZ/50	/* Time between two reads of joysticks (20ms) */
+
+/*
+ * Buffer macros.
+ */
+
+#define ROT(A,B,C)	((((A)<(C))&&(((B)>(A))&&((B)<(C))))||(((A)>(C))&&(((B)>(A))||((B)<(C)))))
+#define GOF(X)		(((X)==JS_BUFF_SIZE-1)?0:(X)+1)
+#define GOB(X)		((X)?(X)-1:JS_BUFF_SIZE-1)
+#define DIFF(X,Y)	((X)>(Y)?(X)-(Y):(Y)-(X))
+
+/*
+ * Global variables.
+ */
+
+static struct JS_DATA_SAVE_TYPE js_comp_glue;
+static struct js_port  *js_port  = NULL;
+static struct js_dev   *js_dev   = NULL;
+static struct timer_list js_timer;
+spinlock_t js_lock = SPIN_LOCK_UNLOCKED;
+static int js_use_count = 0;
+
+/*
+ * Gameport speed.
+ */
+
+unsigned int js_io_speed = 0;
+
+/*
+ * Module info.
+ */
+
+MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
+MODULE_SUPPORTED_DEVICE("js");
+
+/*
+ * js_measure_io_speed() measures the gameport i/o speed.
+ */
+
+static int __init js_measure_io_speed(void)
+{
+#ifdef __i386__
+
+#define GET_TIME(x)     do { outb(0, 0x43); x = inb(0x40); x |= inb(0x40) << 8; } while (0)
+#define DELTA(x,y)      ((y)-(x)+((y)<(x)?1193180L/HZ:0))
+
+	unsigned int i, t, t1, t2, t3, tx;
+	unsigned long flags;
+
+	tx = 1 << 30;
+
+	for(i = 0; i < 50; i++) {
+		save_flags(flags);	/* Yes, all CPUs */
+		cli();
+		GET_TIME(t1);
+		for(t = 0; t < 50; t++) inb(0x201);
+		GET_TIME(t2);
+		GET_TIME(t3);
+		restore_flags(flags);
+		udelay(i * 10);
+		if ((t = DELTA(t2,t1) - DELTA(t3,t2)) < tx) tx = t;
+	}
+
+	return 59659 / t;
+
+#else
+
+	unsigned int j, t = 0;
+
+	j = jiffies; while (j == jiffies);
+	j = jiffies; while (j == jiffies) { t++; inb(0x201); }
+
+	return t * HZ / 1000;
+
+#endif
+
+}
+
+/*
+ * js_correct() performs correction of raw joystick data.
+ */
+
+static int js_correct(int value, struct js_corr *corr)
+{
+	switch (corr->type) {
+		case JS_CORR_NONE:
+			break;
+		case JS_CORR_BROKEN:
+			value = value > corr->coef[0] ? (value < corr->coef[1] ? 0 :
+				((corr->coef[3] * (value - corr->coef[1])) >> 14)) :
+				((corr->coef[2] * (value - corr->coef[0])) >> 14);
+			break;
+
+		default:
+			return 0;
+	}
+
+	if (value < -32767) return -32767;
+	if (value >  32767) return  32767;
+
+	return value;
+}
+
+/*
+ * js_button() returns value of button number i.
+ */
+
+static inline int js_button(int *buttons, int i)
+{
+	return (buttons[i >> 5] >> (i & 0x1f)) & 1;
+}
+
+/*
+ * js_add_event() adds an event to the buffer. This requires additional
+ * queue post-processing done by js_sync_buff.
+ */
+
+static void js_add_event(struct js_dev *jd, __u32 time, __u8 type, __u8 number, __s16 value)
+{
+	jd->buff[jd->ahead].time = time;
+	jd->buff[jd->ahead].type = type;
+	jd->buff[jd->ahead].number = number;
+	jd->buff[jd->ahead].value = value;
+	if (++jd->ahead == JS_BUFF_SIZE) jd->ahead = 0;
+}
+
+/*
+ * js_flush_data() does the same as js_process_data, except for that it doesn't
+ * generate any events - it just copies the data from new to cur.
+ */
+
+static void js_flush_data(struct js_dev *jd)
+{
+	int i;
+
+	for (i = 0; i < ((jd->num_buttons - 1) >> 5) + 1; i++)
+		jd->cur.buttons[i] = jd->new.buttons[i];
+	for (i = 0; i < jd->num_axes; i++)
+		jd->cur.axes[i] = jd->new.axes[i];
+}
+
+/*
+ * js_process_data() finds changes in button states and axis positions and adds
+ * them as events to the buffer.
+ */
+
+static void js_process_data(struct js_dev *jd)
+{
+	int i, t;
+
+	for (i = 0; i < jd->num_buttons; i++)
+	if ((t = js_button(jd->new.buttons, i)) != js_button(jd->cur.buttons, i)) {
+		js_add_event(jd, jiffies, JS_EVENT_BUTTON, i, t);
+		jd->cur.buttons[i >> 5] ^= (1 << (i & 0x1f));
+	}
+
+	for (i = 0; i < jd->num_axes; i++) {
+		t = js_correct(jd->new.axes[i], &jd->corr[i]);
+		if (((jd->corr[i].prec == -1) && t) ||
+			((DIFF(jd->new.axes[i], jd->cur.axes[i]) > jd->corr[i].prec) &&
+			(t != js_correct(jd->cur.axes[i], &jd->corr[i])))) {
+			js_add_event(jd, jiffies, JS_EVENT_AXIS, i, t);
+			jd->cur.axes[i] = jd->new.axes[i];
+		}
+	}
+}
+
+/*
+ * js_sync_buff() checks for all overflows caused by recent additions to the buffer.
+ * These happen only if some process is reading the data too slowly. It
+ * wakes up any process waiting for data.
+ */
+
+static void js_sync_buff(struct js_dev *jd)
+{
+	struct js_list *curl = jd->list;
+
+	if (jd->bhead != jd->ahead) {
+		if(ROT(jd->bhead, jd->tail, jd->ahead) || (jd->tail == jd->bhead)) {
+			while (curl) {
+				if (ROT(jd->bhead, curl->tail, jd->ahead) || (curl->tail == jd->bhead)) {
+					curl->tail = jd->ahead;
+					curl->startup = 0;
+				}
+				curl = curl->next;
+			}
+			jd->tail = jd->ahead;
+		}
+		jd->bhead = jd->ahead;
+		wake_up_interruptible(&jd->wait);
+	}
+}
+
+/*
+ * js_do_timer() acts as an interrupt replacement. It reads the data
+ * from all ports and then generates events for all devices.
+ */
+
+static void js_do_timer(unsigned long data)
+{
+	struct js_port *curp = js_port;
+	struct js_dev *curd = js_dev;
+	unsigned long flags;
+
+	while (curp) {
+		if (curp->read) 
+			if (curp->read(curp->info, curp->axes, curp->buttons))
+				curp->fail++;
+		curp->total++;
+		curp = curp->next;
+	}
+
+	spin_lock_irqsave(&js_lock, flags);
+
+	while (curd) {
+		if (data) {
+			js_process_data(curd);
+			js_sync_buff(curd);
+		} else {
+			js_flush_data(curd);
+		}
+		curd = curd->next;
+	}
+
+	spin_unlock_irqrestore(&js_lock, flags);
+
+	js_timer.expires = jiffies + JS_REFRESH_TIME;
+	add_timer(&js_timer);
+}
+
+/*
+ * js_read() copies one or more entries from jsd[].buff to user
+ * space.
+ */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+static ssize_t js_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+#else
+static int js_read(struct inode *inode, struct file *file, char *buf, int count)
+#endif
+{
+	struct wait_queue wait = { current, NULL };
+	struct js_event *buff = (void *) buf;
+	struct js_list *curl;
+	struct js_dev *jd;
+	unsigned long blocks = count / sizeof(struct js_event);
+	int written = 0;
+	int new_tail, orig_tail;
+	int retval = 0;
+	unsigned long flags;
+
+	curl = file->private_data;
+	jd = curl->dev;
+	orig_tail = curl->tail;
+
+/*
+ * Check user data.
+ */
+
+	if (!blocks)
+		return -EINVAL;
+
+/*
+ * Lock it.
+ */
+
+	spin_lock_irqsave(&js_lock, flags);
+
+/*
+ * Handle (non)blocking i/o.
+ */
+	if (count != sizeof(struct JS_DATA_TYPE)) {
+
+		if (GOF(curl->tail) == jd->bhead && curl->startup == jd->num_axes + jd->num_buttons) {
+
+			add_wait_queue(&jd->wait, &wait);
+			current->state = TASK_INTERRUPTIBLE;
+
+			while (GOF(curl->tail) == jd->bhead) {
+
+				if (file->f_flags & O_NONBLOCK) {
+					retval = -EAGAIN;
+					break;
+				}
+				if (signal_pending(current)) {
+					retval = -ERESTARTSYS;
+					break;
+				}
+
+				spin_unlock_irqrestore(&js_lock, flags);
+				schedule();
+				spin_lock_irqsave(&js_lock, flags);
+
+			}
+
+			current->state = TASK_RUNNING;
+			remove_wait_queue(&jd->wait, &wait);
+		}
+
+		if (retval) {
+			spin_unlock_irqrestore(&js_lock, flags);
+			return retval;
+		}
+
+/*
+ * Initial state.
+ */
+
+		while (curl->startup < jd->num_axes + jd->num_buttons && written < blocks && !retval) {
+
+			struct js_event tmpevent;
+
+			if (curl->startup < jd->num_buttons) {
+				tmpevent.type = JS_EVENT_BUTTON | JS_EVENT_INIT;
+				tmpevent.value = js_button(jd->cur.buttons, curl->startup);
+				tmpevent.number = curl->startup;
+			} else {
+				tmpevent.type = JS_EVENT_AXIS | JS_EVENT_INIT;
+				tmpevent.value = js_correct(jd->cur.axes[curl->startup - jd->num_buttons],
+								&jd->corr[curl->startup - jd->num_buttons]);
+				tmpevent.number = curl->startup - jd->num_buttons;
+			}
+
+			tmpevent.time = jiffies * (1000/HZ);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+			if (copy_to_user(&buff[written], &tmpevent, sizeof(struct js_event)))
+				retval = -EFAULT;
+#else
+			if (!(retval = verify_area(VERIFY_WRITE, &buff[written], sizeof(struct js_event))))
+				memcpy_tofs(&buff[written], &tmpevent, sizeof(struct js_event));
+#endif
+
+			curl->startup++;
+			written++;
+		}
+
+/*
+ * Buffer data.
+ */
+
+		while ((jd->bhead != (new_tail = GOF(curl->tail))) && (written < blocks) && !retval) {
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+			if (copy_to_user(&buff[written], &jd->buff[new_tail], sizeof(struct js_event)))
+				retval = -EFAULT;
+			if (put_user((__u32)(jd->buff[new_tail].time * (1000/HZ)), &buff[written].time))
+				retval = -EFAULT;
+#else
+			if (!(retval = verify_area(VERIFY_WRITE, &buff[written], sizeof(struct js_event)))) {
+				memcpy_tofs(&buff[written], &jd->buff[new_tail], sizeof(struct js_event));
+				put_user((__u32)(jd->buff[new_tail].time * (1000/HZ)), &buff[written].time);
+			}
+#endif
+			curl->tail = new_tail;
+			written++;
+		}
+	}
+
+	else
+
+/*
+ * Handle version 0.x compatibility.
+ */
+
+	{
+		struct JS_DATA_TYPE data;
+
+		data.buttons = jd->new.buttons[0];
+		data.x = jd->num_axes < 1 ? 0 :
+			((js_correct(jd->new.axes[0], &jd->corr[0]) / 256) + 128) >> js_comp_glue.JS_CORR.x;
+		data.y = jd->num_axes < 2 ? 0 :
+			((js_correct(jd->new.axes[1], &jd->corr[1]) / 256) + 128) >> js_comp_glue.JS_CORR.y;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+		retval = copy_to_user(buf, &data, sizeof(struct JS_DATA_TYPE)) ? -EFAULT : 0;
+#else
+		if (!(retval = verify_area(VERIFY_WRITE, buf, sizeof(struct JS_DATA_TYPE)))) {
+			memcpy_tofs(buf, &data, sizeof(struct JS_DATA_TYPE));
+		}
+#endif
+
+		curl->startup = jd->num_axes + jd->num_buttons;
+		curl->tail = GOB(jd->bhead);
+		if (!retval) retval = sizeof(struct JS_DATA_TYPE);
+	}
+
+/*
+ * Check main tail and move it.
+ */
+
+	if (orig_tail == jd->tail) {
+		new_tail = curl->tail;
+		curl = jd->list;
+		while (curl && curl->tail != jd->tail) {
+			if (ROT(jd->bhead, new_tail, curl->tail) ||
+				(jd->bhead == curl->tail)) new_tail = curl->tail;
+			curl = curl->next;
+		}
+		if (!curl) jd->tail = new_tail;
+	}
+
+	spin_unlock_irqrestore(&js_lock, flags);
+
+	return retval ? retval : written * sizeof(struct js_event);
+}
+
+/*
+ * js_poll() does select() support.
+ */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+
+static unsigned int js_poll(struct file *file, poll_table *wait)
+{
+	struct js_list *curl = file->private_data;
+	unsigned long flags;
+	int retval = 0;
+	poll_wait(file, &curl->dev->wait, wait);
+	spin_lock_irqsave(&js_lock, flags);	
+	if (GOF(curl->tail) != curl->dev->bhead ||
+		curl->startup < curl->dev->num_axes + curl->dev->num_buttons) retval = POLLIN | POLLRDNORM;
+	spin_unlock_irqrestore(&js_lock, flags);
+	return retval;
+}
+
+#else
+
+static int js_select(struct inode *inode, struct file *file, int sel_type, select_table *wait)
+{
+	struct js_list *curl = file->private_data;
+	if (sel_type == SEL_IN) {
+		if (GOF(curl->tail) != curl->dev->bhead ||
+			curl->startup < curl->dev->num_axes + curl->dev->num_buttons) return 1;
+		select_wait(&curl->dev->wait, wait);
+	}
+	return 0;
+}
+
+#endif
+
+/*
+ * js_ioctl handles misc ioctl calls.
+ */
+
+static int js_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct js_list *curl;
+	struct js_dev *jd;
+	int len;
+
+	curl = file->private_data;
+	jd = curl->dev;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+
+	switch (cmd) {
+
+/*
+ * 0.x compatibility
+ */
+
+		case JS_SET_CAL:
+			return copy_from_user(&js_comp_glue.JS_CORR, (struct JS_DATA_TYPE *) arg,
+				sizeof(struct JS_DATA_TYPE)) ? -EFAULT : 0;
+		case JS_GET_CAL:
+			return copy_to_user((struct JS_DATA_TYPE *) arg, &js_comp_glue.JS_CORR,
+				sizeof(struct JS_DATA_TYPE)) ? -EFAULT : 0;
+		case JS_SET_TIMEOUT:
+			return get_user(js_comp_glue.JS_TIMEOUT, (int *) arg);
+		case JS_GET_TIMEOUT:
+			return put_user(js_comp_glue.JS_TIMEOUT, (int *) arg);
+		case JS_SET_TIMELIMIT:
+			return get_user(js_comp_glue.JS_TIMELIMIT, (long *) arg);
+		case JS_GET_TIMELIMIT:
+			return put_user(js_comp_glue.JS_TIMELIMIT, (long *) arg);
+		case JS_SET_ALL:
+			return copy_from_user(&js_comp_glue, (struct JS_DATA_SAVE_TYPE *) arg,
+						sizeof(struct JS_DATA_SAVE_TYPE)) ? -EFAULT : 0;
+		case JS_GET_ALL:
+			return copy_to_user((struct JS_DATA_SAVE_TYPE *) arg, &js_comp_glue,
+						sizeof(struct JS_DATA_SAVE_TYPE)) ? -EFAULT : 0;
+
+/*
+ * 1.x ioctl calls
+ */
+
+		case JSIOCGVERSION:
+			return put_user(JS_VERSION, (__u32 *) arg);
+		case JSIOCGAXES:
+			return put_user(jd->num_axes, (__u8 *) arg);
+		case JSIOCGBUTTONS:
+			return put_user(jd->num_buttons, (__u8 *) arg);
+		case JSIOCSCORR:
+			return copy_from_user(jd->corr, (struct js_corr *) arg,
+						sizeof(struct js_corr) * jd->num_axes) ? -EFAULT : 0;
+		case JSIOCGCORR:
+			return copy_to_user((struct js_corr *) arg, jd->corr,
+						sizeof(struct js_corr) * jd->num_axes) ? -EFAULT : 0;
+		default:
+			if ((cmd & ~(_IOC_SIZEMASK << _IOC_SIZESHIFT)) == JSIOCGNAME(0)) {
+				len = strlen(jd->name) + 1;
+				if (len > _IOC_SIZE(cmd)) len = _IOC_SIZE(cmd);
+				if (copy_to_user((char *) arg, jd->name, len)) return -EFAULT;
+				return len;
+			}
+	}
+
+#else
+
+	switch (cmd) {
+
+/*
+ * 0.x compatibility
+ */
+
+		case JS_SET_CAL:
+			if (verify_area(VERIFY_READ, (struct JS_DATA_TYPE *) arg,
+				sizeof(struct JS_DATA_TYPE))) return -EFAULT;
+			memcpy_fromfs(&js_comp_glue.JS_CORR, (struct JS_DATA_SAVE_TYPE *) arg,
+				sizeof(struct JS_DATA_TYPE));
+			return 0;
+		case JS_GET_CAL:
+			if (verify_area(VERIFY_WRITE, (struct JS_DATA_TYPE *) arg,
+				sizeof(struct JS_DATA_TYPE))) return -EFAULT;
+			memcpy_tofs((struct JS_DATA_SAVE_TYPE *) arg, &js_comp_glue.JS_CORR,
+				sizeof(struct JS_DATA_TYPE));
+			return 0;
+		case JS_SET_TIMEOUT:
+			if (verify_area(VERIFY_READ, (int *) arg, sizeof(int))) return -EFAULT;
+			js_comp_glue.JS_TIMEOUT = get_user((int *) arg);
+			return 0;
+		case JS_GET_TIMEOUT:
+			if (verify_area(VERIFY_WRITE, (int *) arg, sizeof(int))) return -EFAULT;
+			put_user(js_comp_glue.JS_TIMEOUT, (int *) arg);
+			return 0;
+		case JS_SET_TIMELIMIT:
+			if (verify_area(VERIFY_READ, (long *) arg, sizeof(long))) return -EFAULT;
+			js_comp_glue.JS_TIMELIMIT = get_user((long *) arg);
+			return 0;
+		case JS_GET_TIMELIMIT:
+			if (verify_area(VERIFY_WRITE, (long *) arg, sizeof(long))) return -EFAULT;
+			put_user(js_comp_glue.JS_TIMELIMIT, (long *) arg);
+			return 0;
+		case JS_SET_ALL:
+			if (verify_area(VERIFY_READ, (struct JS_DATA_SAVE_TYPE *) arg,
+				sizeof(struct JS_DATA_SAVE_TYPE))) return -EFAULT;
+			memcpy_fromfs(&js_comp_glue, (struct JS_DATA_SAVE_TYPE *) arg,
+				sizeof(struct JS_DATA_SAVE_TYPE));
+			return 0;
+		case JS_GET_ALL:
+			if (verify_area(VERIFY_WRITE, (struct JS_DATA_SAVE_TYPE *) arg,
+				sizeof(struct JS_DATA_SAVE_TYPE))) return -EFAULT;
+			memcpy_tofs((struct JS_DATA_SAVE_TYPE *) arg, &js_comp_glue,
+				sizeof(struct JS_DATA_SAVE_TYPE));
+			return 0;
+
+/*
+ * 1.x ioctl calls
+ */
+
+		case JSIOCGVERSION:
+			if (verify_area(VERIFY_WRITE, (__u32 *) arg, sizeof(__u32))) return -EFAULT;
+			put_user(JS_VERSION, (__u32 *) arg);
+			return 0;
+		case JSIOCGAXES:
+			if (verify_area(VERIFY_WRITE, (__u8 *) arg, sizeof(__u8))) return -EFAULT;
+			put_user(jd->num_axes, (__u8 *) arg);
+			return 0;
+		case JSIOCGBUTTONS:
+			if (verify_area(VERIFY_WRITE, (__u8 *) arg, sizeof(__u8))) return -EFAULT;
+			put_user(jd->num_buttons, (__u8 *) arg);
+			return 0;
+		case JSIOCSCORR:
+			if (verify_area(VERIFY_READ, (struct js_corr *) arg,
+				sizeof(struct js_corr) * jd->num_axes)) return -EFAULT;
+			memcpy_fromfs(jd->corr, (struct js_corr *) arg,
+				sizeof(struct js_corr) * jd->num_axes);
+			return 0;
+		case JSIOCGCORR:
+			if (verify_area(VERIFY_WRITE, (struct js_corr *) arg,
+				sizeof(struct js_corr) * jd->num_axes)) return -EFAULT;
+			memcpy_tofs((struct js_corr *) arg,
+				jd->corr, sizeof(struct js_corr) * jd->num_axes);
+			return 0;
+		default:
+			if ((cmd & ~(_IOC_SIZEMASK << _IOC_SIZESHIFT)) == JSIOCGNAME(0)) {
+				len = strlen(jd->name) + 1;
+				if (verify_area(VERIFY_WRITE, (char *) arg, len)) return -EFAULT;
+				if (len > _IOC_SIZE(cmd)) len = _IOC_SIZE(cmd);
+				memcpy_tofs((char *) arg, jd->name, len);
+				return len;
+			}
+	}
+
+#endif
+
+	return -EINVAL;
+}
+
+/*
+ * js_open() performs necessary initialization and adds
+ * an entry to the linked list.
+ */
+
+static int js_open(struct inode *inode, struct file *file)
+{
+	struct js_list *curl, *new;
+	struct js_dev *jd = js_dev;
+	int i = MINOR(inode->i_rdev);
+	unsigned long flags;
+	int result; 
+
+	if (MAJOR(inode->i_rdev) != JOYSTICK_MAJOR)
+		return -EINVAL;
+
+	spin_lock_irqsave(&js_lock, flags);
+
+	while (i > 0 && jd) {
+		jd = jd->next;
+		i--;
+	}
+
+	spin_unlock_irqrestore(&js_lock, flags);
+
+	if (!jd) return -ENODEV;
+
+	if ((result = jd->open(jd))) return result;
+
+	MOD_INC_USE_COUNT;
+	if (!js_use_count++) js_do_timer(0);
+
+	if ((new = kmalloc(sizeof(struct js_list), GFP_KERNEL))) {
+
+		spin_lock_irqsave(&js_lock, flags);
+
+		curl = jd->list;
+
+		jd->list = new;
+		jd->list->next = curl;
+		jd->list->dev = jd;
+		jd->list->startup = 0;
+		jd->list->tail = GOB(jd->bhead);
+		file->private_data = jd->list;
+
+		spin_unlock_irqrestore(&js_lock, flags);
+
+	} else {
+		result = -ENOMEM;
+	}
+
+	return result;
+}
+
+/*
+ * js_release() removes an entry from list and deallocates memory
+ * used by it.
+ */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+static int js_release(struct inode *inode, struct file *file)
+#else
+static void js_release(struct inode *inode, struct file *file)
+#endif
+{
+	struct js_list *curl = file->private_data;
+	struct js_dev *jd = curl->dev;
+	struct js_list **curp = &jd->list;
+	int new_tail;
+	unsigned long flags;
+
+	spin_lock_irqsave(&js_lock, flags);
+
+	while (*curp && (*curp != curl)) curp = &((*curp)->next);
+	*curp = (*curp)->next;
+
+	if (jd->list)
+	if (curl->tail == jd->tail) {
+		curl = jd->list;
+		new_tail = curl->tail;
+		while (curl && curl->tail != jd->tail) {
+			if (ROT(jd->bhead, new_tail, curl->tail) ||
+			       (jd->bhead == curl->tail)) new_tail = curl->tail;
+			curl = curl->next;
+		}
+		if (!curl) jd->tail = new_tail;
+	}
+
+	spin_unlock_irqrestore(&js_lock, flags);
+
+	kfree(file->private_data);
+
+	if (!--js_use_count) del_timer(&js_timer);
+	MOD_DEC_USE_COUNT;
+
+	jd->close(jd);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+	return 0;
+#endif
+}
+
+/*
+ * js_dump_mem() dumps all data structures in memory.
+ * It's used for debugging only.
+ */
+
+#if 0
+static void js_dump_mem(void)
+{
+
+	struct js_port *curp = js_port;
+	struct js_dev *curd = js_dev;
+	int i;
+
+	printk(",--- Dumping Devices:\n");
+	printk("| js_dev = %x\n", (int) js_dev);
+
+	while (curd) {
+		printk("|  %s-device %x, next %x axes %d, buttons %d, port %x - %#x\n",
+			curd->next ? "|":"`",
+			(int) curd, (int) curd->next, curd->num_axes, curd->num_buttons, (int) curd->port, curd->port->io);
+		curd = curd->next;
+	}
+
+	printk(">--- Dumping ports:\n");
+	printk("| js_port = %x\n", (int) js_port);
+
+	while (curp) {
+		printk("|  %s-port %x, next %x, io %#x, devices %d\n",
+			curp->next ? "|":"`",
+			(int) curp, (int) curp->next, curp->io, curp->ndevs);
+		for (i = 0; i < curp->ndevs; i++) {
+			curd = curp->devs[i];
+			if (curd)
+			printk("|  %s %s-device %x, next %x axes %d, buttons %d, port %x\n",
+				curp->next ? "|":" ", (i < curp->ndevs-1) ? "|":"`",
+				(int) curd, (int) curd->next, curd->num_axes, curd->num_buttons, (int) curd->port);
+			else
+			printk("|  %s %s-device %x, not there\n",
+				curp->next ? "|":" ", (i < curp->ndevs-1) ? "|":"`", (int) curd);
+
+		}
+		curp = curp->next;
+	}
+
+	printk("`--- Done\n");
+}
+#endif
+
+
+struct js_port *js_register_port(struct js_port *port,
+				void *info, int devs, int infos, js_read_func read)
+{
+	struct js_port **ptrp = &js_port;
+	struct js_port *curp;
+	void *all;
+	int i;
+	unsigned long flags;
+
+	if (!(all = kmalloc(sizeof(struct js_port) + 4 * devs * sizeof(void*) + infos, GFP_KERNEL)))
+		return NULL;
+
+	curp = all;
+
+	curp->next = NULL;
+	curp->prev = port;
+	curp->read = read;
+	curp->ndevs = devs;
+	curp->fail = 0;
+	curp->total = 0;
+
+	curp->devs = all += sizeof(struct js_port);
+	for (i = 0; i < devs; i++) curp->devs[i] = NULL;
+
+	curp->axes = all += devs * sizeof(void*);
+	curp->buttons = (void*) all += devs * sizeof(void*);
+	curp->corr = all += devs * sizeof(void*);
+
+	if (infos) {
+		curp->info = all += devs * sizeof(void*); 
+		memcpy(curp->info, info, infos);
+	} else {
+		curp->info = NULL;
+	}
+
+	spin_lock_irqsave(&js_lock, flags);
+
+	while (*ptrp) ptrp=&((*ptrp)->next);
+	*ptrp = curp;
+
+	spin_unlock_irqrestore(&js_lock, flags);
+
+	return curp;
+}
+
+struct js_port *js_unregister_port(struct js_port *port)
+{
+	struct js_port **curp = &js_port;
+	struct js_port *prev;
+	unsigned long flags;
+
+	spin_lock_irqsave(&js_lock, flags);
+
+	printk("js: There were %d failures out of %d read attempts.\n", port->fail, port->total);
+
+	while (*curp && (*curp != port)) curp = &((*curp)->next);
+	*curp = (*curp)->next;
+
+	spin_unlock_irqrestore(&js_lock, flags);
+
+	prev = port->prev;
+	kfree(port);
+
+	return prev;
+}
+
+int js_register_device(struct js_port *port, int number, int axes, int buttons, char *name,
+					js_ops_func open, js_ops_func close)
+{
+	struct js_dev **ptrd = &js_dev;
+	struct js_dev *curd;
+	void *all;
+	int i = 0;
+	unsigned long flags;
+
+	if (!(all = kmalloc(sizeof(struct js_dev) + 2 * axes * sizeof(int) +
+			2 * (((buttons - 1) >> 5) + 1) * sizeof(int) +
+			axes * sizeof(struct js_corr) + strlen(name) + 1, GFP_KERNEL)))
+		return -1;
+
+	curd = all;
+
+	curd->next = NULL;
+	curd->list = NULL;
+	curd->port = port;
+	curd->wait = NULL;
+	curd->open = open;
+	curd->close = close;
+
+	curd->ahead = 0;
+	curd->bhead = 0;
+	curd->tail = JS_BUFF_SIZE - 1;
+	curd->num_axes = axes;
+	curd->num_buttons = buttons;
+
+	curd->cur.axes = all += sizeof(struct js_dev);
+	curd->cur.buttons = all += axes * sizeof(int);
+	curd->new.axes = all += (((buttons - 1) >> 5) + 1) * sizeof(int);
+	curd->new.buttons = all += axes * sizeof(int);
+	curd->corr = all += (((buttons -1 ) >> 5) + 1) * sizeof(int);
+
+	curd->name = all += axes * sizeof(struct js_corr);
+	strcpy(curd->name, name);
+
+	port->devs[number] = curd;
+	port->axes[number] = curd->new.axes;
+	port->buttons[number] = curd->new.buttons;
+	port->corr[number] = curd->corr;
+
+	spin_lock_irqsave(&js_lock, flags);
+
+	while (*ptrd) { ptrd=&(*ptrd)->next; i++; }
+	*ptrd = curd;
+
+	spin_unlock_irqrestore(&js_lock, flags);	
+
+	return i;
+}
+
+void js_unregister_device(struct js_dev *dev)
+{
+	struct js_dev **curd = &js_dev;
+	unsigned long flags;
+
+	spin_lock_irqsave(&js_lock, flags);
+
+	while (*curd && (*curd != dev)) curd = &((*curd)->next);
+	*curd = (*curd)->next;
+
+	spin_unlock_irqrestore(&js_lock, flags);	
+
+	kfree(dev);
+}
+
+/*
+ * The operations structure.
+ */
+
+static struct file_operations js_fops =
+{
+	read:		js_read,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+	poll:		js_poll,
+#else
+	select:		js_select,
+#endif
+	ioctl:		js_ioctl,
+	open:		js_open,
+	release:	js_release,
+};
+
+/*
+ * js_init() registers the driver and calls the probe function.
+ * also initializes some crucial variables.
+ */
+
+#ifdef MODULE
+int init_module(void)
+#else
+int __init js_init(void)
+#endif
+{
+	js_io_speed = js_measure_io_speed();
+
+	printk(KERN_INFO "js: Version %d.%d.%d using %d kHz gameport.\n",
+		JS_VERSION >> 16 & 0xff, JS_VERSION >> 8 & 0xff, JS_VERSION & 0xff, js_io_speed);
+
+	if (register_chrdev(JOYSTICK_MAJOR, "js", &js_fops)) {
+		printk(KERN_ERR "js: unable to get major %d for joystick\n", JOYSTICK_MAJOR);
+		return -EBUSY;
+	}
+
+	spin_lock_init(&js_lock);
+
+	init_timer(&js_timer);
+	js_timer.function = js_do_timer;
+	js_timer.data = 1;
+
+	memset(&js_comp_glue, 0, sizeof(struct JS_DATA_SAVE_TYPE));
+	js_comp_glue.JS_TIMEOUT = JS_DEF_TIMEOUT;
+	js_comp_glue.JS_TIMELIMIT = JS_DEF_TIMELIMIT;
+
+#ifndef MODULE
+#ifdef CONFIG_JOY_LIGHTNING
+	js_l4_init();
+#endif
+#ifdef CONFIG_JOY_SIDEWINDER
+	js_sw_init();
+#endif
+#ifdef CONFIG_JOY_ASSASSIN
+	js_as_init();
+#endif
+#ifdef CONFIG_JOY_LOGITECH
+	js_lt_init();
+#endif
+#ifdef CONFIG_JOY_THRUSTMASTER
+	js_tm_init();
+#endif
+#ifdef CONFIG_JOY_GRAVIS
+	js_gr_init();
+#endif
+#ifdef CONFIG_JOY_CREATIVE
+	js_cr_init();
+#endif
+#ifdef CONFIG_JOY_ANALOG
+	js_an_init();
+#endif
+#ifdef CONFIG_JOY_CONSOLE
+	js_console_init();
+#endif
+#ifdef CONFIG_JOY_DB9
+	js_db9_init();
+#endif
+#ifdef CONFIG_JOY_TURBOGRAFX
+	js_tg_init();
+#endif
+#ifdef CONFIG_JOY_AMIGA
+	js_am_init();
+#endif
+#ifdef CONFIG_JOY_MAGELLAN
+	js_mag_init();
+#endif
+#ifdef CONFIG_JOY_WARRIOR
+	js_war_init();
+#endif
+#ifdef CONFIG_JOY_SPACEORB
+	js_orb_init();
+#endif
+#ifdef CONFIG_JOY_KEYBOARD
+	js_key_init();
+#endif
+#endif
+
+	return 0;
+}
+
+/*
+ * cleanup_module() handles module removal.
+ */
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	del_timer(&js_timer);
+	if (unregister_chrdev(JOYSTICK_MAJOR, "js"))
+		printk(KERN_ERR "js: can't unregister device\n");
+}
+#endif
+
diff -urN linux-2.0.36/drivers/char/mem.c linux-2.0.36-joystick/drivers/char/mem.c
--- linux-2.0.36/drivers/char/mem.c	Sun Nov 15 19:32:54 1998
+++ linux-2.0.36-joystick/drivers/char/mem.c	Mon Mar  8 14:48:52 1999
@@ -18,6 +18,7 @@
 #include <linux/mman.h>
 #include <linux/mm.h>
 #include <linux/random.h>
+#include <linux/joystick.h>
 
 #include <asm/segment.h>
 #include <asm/io.h>
@@ -406,6 +407,13 @@
 #endif
 #ifdef CONFIG_SOUND
 	soundcard_init();
+#endif
+#ifdef CONFIG_JOYSTICK
+        /*
+         *      Some joysticks only appear when the soundcard they are
+         *      connected to is configured. Keep the sound/joystick ordering.
+         */
+        js_init();
 #endif
 #if CONFIG_QIC02_TAPE
 	qic02_tape_init();
diff -urN linux-2.0.36/include/linux/joystick.h linux-2.0.36-joystick/include/linux/joystick.h
--- linux-2.0.36/include/linux/joystick.h	Thu Jan  1 01:00:00 1970
+++ linux-2.0.36-joystick/include/linux/joystick.h	Mon Mar  8 14:31:56 1999
@@ -0,0 +1,290 @@
+#ifndef _LINUX_JOYSTICK_H
+#define _LINUX_JOYSTICK_H
+
+/*
+ * /usr/include/linux/joystick.h  Version 1.2
+ *
+ * Copyright (C) 1996-1999 Vojtech Pavlik
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <asm/types.h>
+#include <linux/module.h>
+
+/*
+ * Version
+ */
+
+#define JS_VERSION		0x01020e
+
+/*
+ * Types and constants for reading from /dev/js
+ */
+
+#define JS_EVENT_BUTTON		0x01	/* button pressed/released */
+#define JS_EVENT_AXIS		0x02	/* joystick moved */
+#define JS_EVENT_INIT		0x80	/* initial state of device */
+
+struct js_event {
+	__u32 time;	/* event timestamp in miliseconds */
+	__s16 value;	/* value */
+	__u8 type;	/* event type */
+	__u8 number;	/* axis/button number */
+};
+
+/*
+ * IOCTL commands for joystick driver
+ */
+
+#define JSIOCGVERSION		_IOR('j', 0x01, __u32)			/* get driver version */
+
+#define JSIOCGAXES		_IOR('j', 0x11, __u8)			/* get number of axes */
+#define JSIOCGBUTTONS		_IOR('j', 0x12, __u8)			/* get number of buttons */
+#define JSIOCGNAME(len)		_IOC(_IOC_READ, 'j', 0x13, len)         /* get identifier string */
+
+#define JSIOCSCORR		_IOW('j', 0x21, struct js_corr)		/* set correction values */
+#define JSIOCGCORR		_IOR('j', 0x22, struct js_corr)		/* get correction values */
+
+/*
+ * Types and constants for get/set correction
+ */
+
+#define JS_CORR_NONE		0x00	/* returns raw values */
+#define JS_CORR_BROKEN		0x01	/* broken line */
+
+struct js_corr {
+	__s32 coef[8];
+	__s16 prec;
+	__u16 type;
+};
+
+/*
+ * v0.x compatibility definitions
+ */
+
+#define JS_RETURN		sizeof(struct JS_DATA_TYPE)
+#define JS_TRUE			1
+#define JS_FALSE		0
+#define JS_X_0			0x01
+#define JS_Y_0			0x02
+#define JS_X_1			0x04
+#define JS_Y_1			0x08
+#define JS_MAX			2
+
+#define JS_DEF_TIMEOUT		0x1300
+#define JS_DEF_CORR		0
+#define JS_DEF_TIMELIMIT	10L
+
+#define JS_SET_CAL		1
+#define JS_GET_CAL		2
+#define JS_SET_TIMEOUT		3
+#define JS_GET_TIMEOUT		4
+#define JS_SET_TIMELIMIT	5
+#define JS_GET_TIMELIMIT	6
+#define JS_GET_ALL		7
+#define JS_SET_ALL		8
+
+struct JS_DATA_TYPE {
+	int buttons;
+	int x;
+	int y;
+};
+
+struct JS_DATA_SAVE_TYPE {
+	int JS_TIMEOUT;
+	int BUSY;
+	long JS_EXPIRETIME;
+	long JS_TIMELIMIT;
+	struct JS_DATA_TYPE JS_SAVE;
+	struct JS_DATA_TYPE JS_CORR;
+};
+
+/*
+ * Internal definitions
+ */
+
+#ifdef __KERNEL__
+
+#define JS_BUFF_SIZE		64		/* output buffer size */
+
+#include <linux/version.h>
+
+#ifndef KERNEL_VERSION
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
+#endif
+
+#ifndef LINUX_VERSION_CODE
+#error "You need to use at least 2.0 Linux kernel."
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,0,0)
+#error "You need to use at least 2.0 Linux kernel."
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0)
+#define __initdata
+#define __init
+#define __cli cli
+#define __save_flags(flags) save_flags(flags)
+#define __restore_flags(flags)	restore_flags(flags)
+#define mdelay(x) udelay(1000*x)
+#define spin_lock_irqsave(x, flags) do { save_flags(flags); cli(); } while (0)
+#define spin_unlock_irqrestore(x, flags) restore_flags(flags)
+#define spin_lock_init(x) do { } while (0)
+typedef struct { int something; } spinlock_t;
+#define SPIN_LOCK_UNLOCKED { 0 }
+#define MODULE_AUTHOR(x)
+#define MODULE_PARM(x,y)
+#define MODULE_SUPPORTED_DEVICE(x)
+#define signal_pending(x) (((x)->signal) & ~((x)->blocked))
+#ifdef CONFIG_M686
+#define CONFIG_X86_TSC
+#elif CONFIG_M586
+#define CONFIG_X86_TSC
+#endif
+#else
+#include <linux/init.h>
+#endif
+
+/*
+ * Parport stuff
+ */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+#define USE_PARPORT
+#endif
+
+#ifdef USE_PARPORT
+#include <linux/parport.h>
+#define JS_PAR_DATA_IN(y)	parport_read_data(y->port)
+#define JS_PAR_DATA_OUT(x,y)	parport_write_data(y->port, x)
+#define JS_PAR_STATUS(y)	parport_read_status(y->port)
+#define JS_PAR_CTRL_IN(y)	parport_read_control(y->port)
+#define JS_PAR_CTRL_OUT(x,y)	parport_write_control(y->port, x)
+#define JS_PAR_ECTRL_OUT(x,y)	parport_write_econtrol(y->port, x)
+#else
+#define JS_PAR_DATA_IN(y)	inb(y)
+#define JS_PAR_DATA_OUT(x,y)	outb(x,y)
+#define JS_PAR_STATUS(y)	inb(y+1)
+#define JS_PAR_CTRL_IN(y)	inb(y+2)
+#define JS_PAR_CTRL_OUT(x,y)	outb(x,y+2)
+#define JS_PAR_ECTRL_OUT(x,y)	outb(x,y+0x402)
+#endif
+
+#define JS_PAR_STATUS_INVERT	(0x80)
+#define JS_PAR_CTRL_INVERT	(0x04)
+
+/*
+ * Internal types
+ */
+
+struct js_dev;
+
+typedef int (*js_read_func)(void *info, int **axes, int **buttons);
+typedef int (*js_ops_func)(struct js_dev *dev);
+
+struct js_data {
+	int *axes;
+	int *buttons;
+};
+
+struct js_dev {
+	struct js_dev *next;
+	struct js_list *list;
+	struct js_port *port;
+	struct wait_queue *wait;
+	struct js_data cur;
+	struct js_data new;
+	struct js_corr *corr;
+	struct js_event buff[JS_BUFF_SIZE];
+	js_ops_func open;
+	js_ops_func close;
+	int ahead;
+	int bhead;
+	int tail;
+	int num_axes;
+	int num_buttons;
+	char *name;
+};
+
+struct js_list {
+	struct js_list *next;
+	struct js_dev *dev;
+	int tail;
+	int startup;
+};
+
+struct js_port {
+	struct js_port *next;
+	struct js_port *prev;
+	js_read_func read;
+	struct js_dev **devs;
+	int **axes;
+	int **buttons;
+	struct js_corr **corr;
+	void *info;
+	int ndevs;
+	int fail;
+	int total;
+};
+
+/*
+ * Sub-module interface
+ */
+
+extern unsigned int js_io_speed;
+
+extern struct js_port *js_register_port(struct js_port *port, void *info,
+	int devs, int infos, js_read_func read);
+extern struct js_port *js_unregister_port(struct js_port *port);
+
+extern int js_register_device(struct js_port *port, int number, int axes,
+	int buttons, char *name, js_ops_func open, js_ops_func close);
+extern void js_unregister_device(struct js_dev *dev);
+
+/*
+ * Kernel interface
+ */
+
+extern int js_init(void);
+extern int js_am_init(void);
+extern int js_key_init(void);
+extern int js_an_init(void);
+extern int js_as_init(void);
+extern int js_console_init(void);
+extern int js_db9_init(void);
+extern int js_gr_init(void);
+extern int js_l4_init(void);
+extern int js_lt_init(void);
+extern int js_sw_init(void);
+extern int js_tm_init(void);
+
+extern void js_am_setup(char *str, int *ints);
+extern void js_an_setup(char *str, int *ints);
+extern void js_as_setup(char *str, int *ints);
+extern void js_console_setup(char *str, int *ints);
+extern void js_db9_setup(char *str, int *ints);
+extern void js_l4_setup(char *str, int *ints);
+
+#endif /* __KERNEL__ */
+
+#endif /* _LINUX_JOYSTICK_H */
diff -urN linux-2.0.36/init/main.c linux-2.0.36-joystick/init/main.c
--- linux-2.0.36/init/main.c	Sun Nov 15 19:33:19 1998
+++ linux-2.0.36-joystick/init/main.c	Mon Mar  8 14:48:52 1999
@@ -79,6 +79,27 @@
 extern void bmouse_setup(char *str, int *ints);
 extern void msmouse_setup(char *str, int *ints);
 extern void lp_setup(char *str, int *ints);
+#ifdef CONFIG_JOY_AMIGA
+extern void js_am_setup(char *str, int *ints);
+#endif
+#ifdef CONFIG_JOY_ANALOG
+extern void js_an_setup(char *str, int *ints);
+#endif
+#ifdef CONFIG_JOY_ASSASSIN
+extern void js_as_setup(char *str, int *ints);
+#endif
+#ifdef CONFIG_JOY_CONSOLE
+extern void js_console_setup(char *str, int *ints);
+#endif
+#ifdef CONFIG_JOY_DB9
+extern void js_db9_setup(char *str, int *ints);
+#endif
+#ifdef CONFIG_JOY_TURBOGRAFX
+extern void js_tg_setup(char *str, int *ints);
+#endif
+#ifdef CONFIG_JOY_LIGHTNING
+extern void js_l4_setup(char *str, int *ints);
+#endif
 extern void eth_setup(char *str, int *ints);
 extern void xd_setup(char *str, int *ints);
 extern void xd_manual_geo_init(char *str, int *ints);
@@ -309,6 +330,33 @@
 #endif
 #ifdef CONFIG_PRINTER
         { "lp=", lp_setup },
+#endif
+#ifdef CONFIG_JOY_AMIGA
+        { "js_am=", js_am_setup },
+#endif
+#ifdef CONFIG_JOY_ANALOG
+        { "js_an=", js_an_setup },
+#endif
+#ifdef CONFIG_JOY_ASSASSIN
+        { "js_as=", js_as_setup },
+#endif
+#ifdef CONFIG_JOY_CONSOLE
+        { "js_console=", js_console_setup },
+        { "js_console2=", js_console_setup },
+        { "js_console3=", js_console_setup },
+#endif
+#ifdef CONFIG_JOY_DB9
+        { "js_db9=", js_db9_setup },
+        { "js_db9_2=", js_db9_setup },
+        { "js_db9_3=", js_db9_setup },
+#endif
+#ifdef CONFIG_JOY_TURBOGRAFX
+        { "js_tg=", js_tg_setup },
+        { "js_tg_2=", js_tg_setup },
+        { "js_tg_3=", js_tg_setup },
+#endif
+#ifdef CONFIG_JOY_LIGHTNING
+        { "js_l4=", js_as_setup },
 #endif
 #ifdef CONFIG_SCSI
 	{ "max_scsi_luns=", scsi_luns_setup },
diff -urN linux-2.0.36/kernel/ksyms.c linux-2.0.36-joystick/kernel/ksyms.c
--- linux-2.0.36/kernel/ksyms.c	Sun Nov 15 19:33:20 1998
+++ linux-2.0.36-joystick/kernel/ksyms.c	Mon Mar  8 14:48:52 1999
@@ -384,10 +384,21 @@
 	/* Modular sound */
 	X(sys_open),
 	X(sys_read),
+
+	/* Joysticks */
+#ifdef CONFIG_JOYSTICK
+	X(js_io_speed),
+	X(js_register_port),
+	X(js_unregister_port),
+	X(js_register_device),
+	X(js_unregister_device),
+#endif
+
 	/********************************************************
 	 * Do not add anything below this line,
 	 * as the stacked modules depend on this!
 	 */
+
 #include <linux/symtab_end.h>
 };
 
